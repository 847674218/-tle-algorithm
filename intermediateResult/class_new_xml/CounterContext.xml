<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.2.1\src\java\org\apache\cassandra\db\context\CounterContext.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>context</name></name>;</package>

<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>security</name>.<name>MessageDigest</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>ArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Iterator</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>List</name></name>;</import>

<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>TypeSizes</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>CompactionManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>MarshalException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name></name>.*;</import>

<comment type="block" format="javadoc">/**
 * An implementation of a partitioned counter context.
 *
 * A context is primarily a list of tuples (counter id, clock, count) -- called
 * shard in the following. But with some shard are flagged as delta (with
 * special resolution rules in merge()).
 *
 * The data structure has two parts:
 *   a) a header containing the lists of "delta" (a list of references to the second parts)
 *   b) a list of shard -- (counter id, logical clock, count) tuples -- (the so-called 'body' below)
 *
 * The exact layout is:
 *            | header  |   body   |
 * context :  |--|------|----------|
 *             ^     ^
 *             |   list of indices in the body list (2*#elt bytes)
 *    #elt in rest of header (2 bytes)
 *
 * The body layout being:
 *
 * body:     |----|----|----|----|----|----|....
 *             ^    ^    ^     ^   ^    ^
 *             |    |  count_1 |   |   count_2
 *             |  clock_1      |  clock_2
 *       counterid_1         counterid_2
 *
 * The rules when merging two shard with the same counterid are:
 *   - delta + delta = sum counts (and logical clock)
 *   - delta + other = keep the delta one
 *   - other + other = keep the shard with highest logical clock
 *
 * For a detailed description of the meaning of a delta and why the merging
 * rules work this way, see CASSANDRA-1938 - specifically the 1938_discussion
 * attachment.
 */</comment>
<class><specifier>public</specifier> class <name>CounterContext</name> <super><implements>implements <name>IContext</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>HEADER_SIZE_LENGTH</name> <init>= <expr><call><name><name>TypeSizes</name>.<name>NATIVE</name>.<name>sizeof</name></name><argument_list>(<argument><expr><name><name>Short</name>.<name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>HEADER_ELT_LENGTH</name> <init>= <expr><call><name><name>TypeSizes</name>.<name>NATIVE</name>.<name>sizeof</name></name><argument_list>(<argument><expr><name><name>Short</name>.<name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>CLOCK_LENGTH</name> <init>= <expr><call><name><name>TypeSizes</name>.<name>NATIVE</name>.<name>sizeof</name></name><argument_list>(<argument><expr><name><name>Long</name>.<name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>COUNT_LENGTH</name> <init>= <expr><call><name><name>TypeSizes</name>.<name>NATIVE</name>.<name>sizeof</name></name><argument_list>(<argument><expr><name><name>Long</name>.<name>MAX_VALUE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>STEP_LENGTH</name> <init>= <expr><name><name>CounterId</name>.<name>LENGTH</name></name> + <name>CLOCK_LENGTH</name> + <name>COUNT_LENGTH</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>CounterContext</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// lazy-load singleton</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>LazyHolder</name>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>CounterContext</name></type> <name>counterContext</name> <init>= <expr>new <call><name>CounterContext</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    }</block></class>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>CounterContext</name></type> <name>instance</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>LazyHolder</name>.<name>counterContext</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Creates an initial counter context with an initial value for the local node.
     *
     *
     * @param value the value for this initial update
     *
     * @param allocator
     * @return an empty counter context.
     */</comment>
    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>create</name><parameter_list>(<param><decl><type><name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name>Allocator</name></type> <name>allocator</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>context</name> <init>= <expr><call><name><name>allocator</name>.<name>allocate</name></name><argument_list>(<argument><expr><name>HEADER_SIZE_LENGTH</name> + <name>HEADER_ELT_LENGTH</name> + <name>STEP_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// The first (and only) elt is a delta</comment>
        <expr_stmt><expr><call><name><name>context</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>short</name>)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>HEADER_SIZE_LENGTH</name></expr></argument>, <argument><expr>(<name>short</name>)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>writeElementAtOffset</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>HEADER_SIZE_LENGTH</name> + <name>HEADER_ELT_LENGTH</name></expr></argument>, <argument><expr><call><name><name>CounterId</name>.<name>getLocalId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>1L</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>context</name></expr>;</return>
    }</block></function>

    <comment type="line">// Provided for use by unit tests</comment>
    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>create</name><parameter_list>(<param><decl><type><name>CounterId</name></type> <name>id</name></decl></param>, <param><decl><type><name>long</name></type> <name>clock</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isDelta</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>context</name> <init>= <expr><call><name><name>ByteBuffer</name>.<name>allocate</name></name><argument_list>(<argument><expr><name>HEADER_SIZE_LENGTH</name> + (<name>isDelta</name> ? <name>HEADER_ELT_LENGTH</name> : 0) + <name>STEP_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call>(<name>short</name>)<argument_list>(<argument><expr><name>isDelta</name> ? 1 : 0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>isDelta</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>context</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>HEADER_SIZE_LENGTH</name></expr></argument>, <argument><expr>(<name>short</name>)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>writeElementAtOffset</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>HEADER_SIZE_LENGTH</name> + (<name>isDelta</name> ? <name>HEADER_ELT_LENGTH</name> : 0)</expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>clock</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>context</name></expr>;</return>
    }</block></function>

    <comment type="line">// write a tuple (counter id, clock, count) at an absolute (bytebuffer-wise) offset</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>writeElementAtOffset</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><name>CounterId</name></type> <name>id</name></decl></param>, <param><decl><type><name>long</name></type> <name>clock</name></decl></param>, <param><decl><type><name>long</name></type> <name>count</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>context</name> = <call><name><name>context</name>.<name>duplicate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>position</name></name><argument_list>(<argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>id</name>.<name>bytes</name></name><argument_list>()</argument_list></call>.<call><name>duplicate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>putLong</name></name><argument_list>(<argument><expr><name>clock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>context</name>.<name>putLong</name></name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>headerLength</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name>HEADER_SIZE_LENGTH</name> + <call><name><name>Math</name>.<name>abs</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>getShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> * <name>HEADER_ELT_LENGTH</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>compareId</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>bb1</name></decl></param>, <param><decl><type><name>int</name></type> <name>pos1</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>bb2</name></decl></param>, <param><decl><type><name>int</name></type> <name>pos2</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>ByteBufferUtil</name>.<name>compareSubArrays</name></name><argument_list>(<argument><expr><name>bb1</name></expr></argument>, <argument><expr><name>pos1</name></expr></argument>, <argument><expr><name>bb2</name></expr></argument>, <argument><expr><name>pos2</name></expr></argument>, <argument><expr><name><name>CounterId</name>.<name>LENGTH</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Determine the count relationship between two contexts.
     *
     * EQUAL:        Equal set of nodes and every count is equal.
     * GREATER_THAN: Superset of nodes and every count is equal or greater than its corollary.
     * LESS_THAN:    Subset of nodes and every count is equal or less than its corollary.
     * DISJOINT:     Node sets are not equal and/or counts are not all greater or less than.
     *
     * Strategy: compare node logical clocks (like a version vector).
     *
     * @param left counter context.
     * @param right counter context.
     * @return the ContextRelationship between the contexts.
     */</comment>
    <function><type><specifier>public</specifier> <name>ContextRelationship</name></type> <name>diff</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>left</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>right</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ContextRelationship</name></type> <name>relationship</name> <init>= <expr><name><name>ContextRelationship</name>.<name>EQUAL</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ContextState</name></type> <name>leftState</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><call><name>headerLength</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ContextState</name></type> <name>rightState</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><call><name>headerLength</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>leftState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>rightState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <comment type="line">// compare id bytes</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>compareId</name> <init>= <expr><call><name><name>leftState</name>.<name>compareIdTo</name></name><argument_list>(<argument><expr><name>rightState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>compareId</name> == 0</expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>long</name></type> <name>leftClock</name>  <init>= <expr><call><name><name>leftState</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>rightClock</name> <init>= <expr><call><name><name>rightState</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>leftCount</name> <init>= <expr><call><name><name>leftState</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>rightCount</name> <init>= <expr><call><name><name>rightState</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// advance</comment>
                <expr_stmt><expr><call><name><name>leftState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rightState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// process clock comparisons</comment>
                <if>if <condition>(<expr><name>leftClock</name> == <name>rightClock</name></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>leftCount</name> != <name>rightCount</name></expr>)</condition><then>
                    <block>{
                        <comment type="line">// Inconsistent shard (see the corresponding code in merge()). We return DISJOINT in this</comment>
                        <comment type="line">// case so that it will be treated as a difference, allowing read-repair to work.</comment>
                        <return>return <expr><name><name>ContextRelationship</name>.<name>DISJOINT</name></name></expr>;</return>
                    }</block></then>
                    <else>else
                    <block>{
                        <continue>continue;</continue>
                    }</block></else></if>
                }</block></then>
                <else>else <if>if <condition>(<expr>(<name>leftClock</name> &gt;= 0 &amp;&amp; <name>rightClock</name> &gt; 0 &amp;&amp; <name>leftClock</name> &gt; <name>rightClock</name>)
                      || (<name>leftClock</name> &lt; 0 &amp;&amp; (<name>rightClock</name> &gt; 0 || <name>leftClock</name> &lt; <name>rightClock</name>))</expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>EQUAL</name></name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>relationship</name> = <name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>)</condition><then>
                    <block>{
                        <continue>continue;</continue>
                    }</block></then>
                    <else>else
                    <block>{
                        <comment type="line">// relationship == ContextRelationship.LESS_THAN</comment>
                        <return>return <expr><name><name>ContextRelationship</name>.<name>DISJOINT</name></name></expr>;</return>
                    }</block></else></if></else></if>
                }</block></then>
                <else>else
                <block>{
                    <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>EQUAL</name></name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>relationship</name> = <name><name>ContextRelationship</name>.<name>LESS_THAN</name></name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>)</condition><then>
                    <block>{
                        <return>return <expr><name><name>ContextRelationship</name>.<name>DISJOINT</name></name></expr>;</return>
                    }</block></then>
                    <else>else
                    <block>{
                        <comment type="line">// relationship == ContextRelationship.LESS_THAN</comment>
                        <continue>continue;</continue>
                    }</block></else></if></else></if>
                }</block></else></if></else></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>compareId</name> &gt; 0</expr>)</condition><then>
            <block>{
                <comment type="line">// only advance the right context</comment>
                <expr_stmt><expr><call><name><name>rightState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>EQUAL</name></name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>relationship</name> = <name><name>ContextRelationship</name>.<name>LESS_THAN</name></name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>)</condition><then>
                <block>{
                    <return>return <expr><name><name>ContextRelationship</name>.<name>DISJOINT</name></name></expr>;</return>
                }</block></then>
                <else>else
                <block>{
                    <comment type="line">// relationship == ContextRelationship.LESS_THAN</comment>
                    <continue>continue;</continue>
                }</block></else></if></else></if>
            }</block></then>
            <else>else <comment type="line">// compareId &lt; 0</comment>
            <block>{
                <comment type="line">// only advance the left context</comment>
                <expr_stmt><expr><call><name><name>leftState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>EQUAL</name></name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>relationship</name> = <name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>)</condition><then>
                <block>{
                    <continue>continue;</continue>
                }</block></then>
                <else>else
                <comment type="line">// relationship == ContextRelationship.LESS_THAN</comment>
                <block>{
                    <return>return <expr><name><name>ContextRelationship</name>.<name>DISJOINT</name></name></expr>;</return>
                }</block></else></if></else></if>
            }</block></else></if></else></if>
        }</block></while>

        <comment type="line">// check final lengths</comment>
        <if>if <condition>(<expr><call><name><name>leftState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>EQUAL</name></name></expr>)</condition><then>
            <block>{
                <return>return <expr><name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>;</return>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>LESS_THAN</name></name></expr>)</condition><then>
            <block>{
                <return>return <expr><name><name>ContextRelationship</name>.<name>DISJOINT</name></name></expr>;</return>
            }</block></then></if></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name><name>rightState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>EQUAL</name></name></expr>)</condition><then>
            <block>{
                <return>return <expr><name><name>ContextRelationship</name>.<name>LESS_THAN</name></name></expr>;</return>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>relationship</name> == <name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name></expr>)</condition><then>
            <block>{
                <return>return <expr><name><name>ContextRelationship</name>.<name>DISJOINT</name></name></expr>;</return>
            }</block></then></if></else></if>
        }</block></then></if></else></if>

        <return>return <expr><name>relationship</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Return a context w/ an aggregated count for each counter id.
     *
     * @param left counter context.
     * @param right counter context.
     * @param allocator An allocator for the merged value.
     */</comment>
    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>merge</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>left</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>right</name></decl></param>, <param><decl><type><name>Allocator</name></type> <name>allocator</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ContextState</name></type> <name>leftState</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><call><name>headerLength</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ContextState</name></type> <name>rightState</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><call><name>headerLength</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Compute size of result</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>mergedHeaderLength</name> <init>= <expr><name>HEADER_SIZE_LENGTH</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>mergedBodyLength</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>leftState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>rightState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name><name>leftState</name>.<name>compareIdTo</name></name><argument_list>(<argument><expr><name>rightState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>mergedBodyLength</name> += <name>STEP_LENGTH</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>leftState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call> || <call><name><name>rightState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>mergedHeaderLength</name> += <name>HEADER_ELT_LENGTH</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name><name>leftState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rightState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>mergedBodyLength</name> += <name>STEP_LENGTH</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>rightState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>mergedHeaderLength</name> += <name>HEADER_ELT_LENGTH</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name><name>rightState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <comment type="line">// cmp &lt; 0</comment>
            <block>{
                <expr_stmt><expr><name>mergedBodyLength</name> += <name>STEP_LENGTH</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>leftState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>mergedHeaderLength</name> += <name>HEADER_ELT_LENGTH</name></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name><name>leftState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></while>
        <expr_stmt><expr><name>mergedHeaderLength</name> += <call><name><name>leftState</name>.<name>remainingHeaderLength</name></name><argument_list>()</argument_list></call> + <call><name><name>rightState</name>.<name>remainingHeaderLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>mergedBodyLength</name> += <call><name><name>leftState</name>.<name>remainingBodyLength</name></name><argument_list>()</argument_list></call> + <call><name><name>rightState</name>.<name>remainingBodyLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Do the actual merge</comment>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>merged</name> <init>= <expr><call><name><name>allocator</name>.<name>allocate</name></name><argument_list>(<argument><expr><name>mergedHeaderLength</name> + <name>mergedBodyLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>merged</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>merged</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call>(<name>short</name>) <argument_list>(<argument><expr>(<name>mergedHeaderLength</name> - <name>HEADER_SIZE_LENGTH</name>) / <name>HEADER_ELT_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ContextState</name></type> <name>mergedState</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>merged</name></expr></argument>, <argument><expr><name>mergedHeaderLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>leftState</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>rightState</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>leftState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>rightState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name><name>leftState</name>.<name>compareIdTo</name></name><argument_list>(<argument><expr><name>rightState</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>leftState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call> || <call><name><name>rightState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// Local id and at least one is a delta</comment>
                    <if>if <condition>(<expr><call><name><name>leftState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>rightState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <block>{
                        <comment type="line">// both delta, sum</comment>
                        <decl_stmt><decl><type><name>long</name></type> <name>clock</name> <init>= <expr><call><name><name>leftState</name>.<name>getClock</name></name><argument_list>()</argument_list></call> + <call><name><name>rightState</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><call><name><name>leftState</name>.<name>getCount</name></name><argument_list>()</argument_list></call> + <call><name><name>rightState</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>mergedState</name>.<name>writeElement</name></name><argument_list>(<argument><expr><call><name><name>leftState</name>.<name>getCounterId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>clock</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else
                    <block>{
                        <comment type="line">// Only one have delta, keep that one</comment>
                        <expr_stmt><expr>(<call><name><name>leftState</name>.<name>isDelta</name></name><argument_list>()</argument_list></call> ? <name>leftState</name> : <name>rightState</name>).<call><name>copyTo</name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then>
                <else>else
                <block>{
                    <decl_stmt><decl><type><name>long</name></type> <name>leftClock</name> <init>= <expr><call><name><name>leftState</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>long</name></type> <name>rightClock</name> <init>= <expr><call><name><name>rightState</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><name>leftClock</name> == <name>rightClock</name></expr>)</condition><then>
                    <block>{
                        <comment type="line">// We should never see non-delta shards w/ same id+clock but different counts. However, if we do</comment>
                        <comment type="line">// we should "heal" the problem by being deterministic in our selection of shard - and</comment>
                        <comment type="line">// log the occurrence so that the operator will know something is wrong.</comment>
                        <decl_stmt><decl><type><name>long</name></type> <name>leftCount</name> <init>= <expr><call><name><name>leftState</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>long</name></type> <name>rightCount</name> <init>= <expr><call><name><name>rightState</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if>if <condition>(<expr><name>leftCount</name> != <name>rightCount</name> &amp;&amp; <call><name><name>CompactionManager</name>.<name>isCompactionManager</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"invalid counter shard detected; ({}, {}, {}) and ({}, {}, {}) differ only in "
                                        + "count; will pick highest to self-heal on compaction"</expr></argument>,
                                        <argument><expr><call><name><name>leftState</name>.<name>getCounterId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>leftClock</name></expr></argument>, <argument><expr><name>leftCount</name></expr></argument>, <argument><expr><call><name><name>rightState</name>.<name>getCounterId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rightClock</name></expr></argument>, <argument><expr><name>rightCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <if>if <condition>(<expr><name>leftCount</name> &gt; <name>rightCount</name></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><call><name><name>leftState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then>
                        <else>else
                        <block>{
                            <expr_stmt><expr><call><name><name>rightState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then>
                    <else>else
                    <block>{
                        <if>if <condition>(<expr>(<name>leftClock</name> &gt;= 0 &amp;&amp; <name>rightClock</name> &gt; 0 &amp;&amp; <name>leftClock</name> &gt;= <name>rightClock</name>)
                                || (<name>leftClock</name> &lt; 0 &amp;&amp; (<name>rightClock</name> &gt; 0 || <name>leftClock</name> &lt; <name>rightClock</name>))</expr>)</condition><then>
                            <expr_stmt><expr><call><name><name>leftState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                        <else>else
                            <expr_stmt><expr><call><name><name>rightState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                    }</block></else></if>
                }</block></else></if>
                <expr_stmt><expr><call><name><name>rightState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>leftState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>cmp</name> &gt; 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>rightState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rightState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <comment type="line">// cmp &lt; 0</comment>
            <block>{
                <expr_stmt><expr><call><name><name>leftState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>leftState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></while>
        <while>while <condition>(<expr><call><name><name>leftState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <expr_stmt><expr><call><name><name>leftState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>leftState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <while>while <condition>(<expr><call><name><name>rightState</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <expr_stmt><expr><call><name><name>rightState</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>mergedState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>rightState</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <return>return <expr><name>merged</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Human-readable String from context.
     *
     * @param context counter context.
     * @return a human-readable String of the context.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ContextState</name></type> <name>state</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"["</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <while>while <condition>(<expr><call><name><name>state</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <if>if <condition>(<expr><call><name><name>state</name>.<name>elementIdx</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"{"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>state</name>.<name>getCounterId</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>state</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
            <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"}"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>state</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>state</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>sb</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the aggregated count across all counter ids.
     *
     * @param context a counter context
     * @return the aggregated count represented by {@code context}
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>total</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>total</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>

        <comment type="line">// we could use a ContextState but it is easy enough that we avoid the object creation</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>offset</name> &lt; <call><name><name>context</name>.<name>limit</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>offset</name> += <name>STEP_LENGTH</name></expr></incr>)
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><call><name><name>context</name>.<name>getLong</name></name><argument_list>(<argument><expr><name>offset</name> + <name><name>CounterId</name>.<name>LENGTH</name></name> + <name>CLOCK_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>total</name> += <name>count</name></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>total</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Mark context to delete delta afterward.
     * Marking is done by multiply #elt by -1 to preserve header length
     * and #elt count in order to clear all delta later.
     *
     * @param context a counter context
     * @return context that marked to delete delta
     */</comment>
    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>markDeltaToBeCleared</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>headerLength</name> <init>= <expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>headerLength</name> == 0</expr>)</condition><then>
            <return>return <expr><name>context</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>marked</name> <init>= <expr><call><name><name>context</name>.<name>duplicate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>short</name></type> <name>count</name> <init>= <expr><call><name><name>context</name>.<name>getShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// negate #elt to mark as deleted, without changing its size.</comment>
        <if>if <condition>(<expr><name>count</name> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>marked</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>marked</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call>(<name>short</name>) <argument_list>(<argument><expr><name>count</name> * -1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>marked</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Remove all the delta of a context (i.e, set an empty header).
     *
     * @param context a counter context
     * @return a version of {@code context} where no count are a delta.
     */</comment>
    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>clearAllDelta</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>headerLength</name> <init>= <expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>headerLength</name> == 0</expr>)</condition><then>
            <return>return <expr><name>context</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>cleaned</name> <init>= <expr><call><name><name>ByteBuffer</name>.<name>allocate</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>remaining</name></name><argument_list>()</argument_list></call> - <name>headerLength</name> + <name>HEADER_SIZE_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cleaned</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>cleaned</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>short</name>)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ByteBufferUtil</name>.<name>arrayCopy</name></name><argument_list>(
                <argument><expr><name>context</name></expr></argument>,
                <argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>headerLength</name></expr></argument>,
                <argument><expr><name>cleaned</name></expr></argument>,
                <argument><expr><call><name><name>cleaned</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>HEADER_SIZE_LENGTH</name></expr></argument>,
                <argument><expr><call><name><name>context</name>.<name>remaining</name></name><argument_list>()</argument_list></call> - <name>headerLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cleaned</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>validateContext</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>MarshalException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>headerLength</name> <init>= <expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>headerLength</name> &lt; 0 || (<call><name><name>context</name>.<name>remaining</name></name><argument_list>()</argument_list></call> - <name>headerLength</name>) %  <name>STEP_LENGTH</name> != 0</expr>)</condition><then>
            <throw>throw <expr>new <call><name>MarshalException</name><argument_list>(<argument><expr>"Invalid size for a counter context"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Update a MessageDigest with the content of a context.
     * Note that this skips the header entirely since the header information
     * has local meaning only, while digests a meant for comparison across
     * nodes. This means in particular that we always have:
     *  updateDigest(ctx) == updateDigest(clearAllDelta(ctx))
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateDigest</name><parameter_list>(<param><decl><type><name>MessageDigest</name></type> <name>message</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>hlength</name> <init>= <expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>dup</name> <init>= <expr><call><name><name>context</name>.<name>duplicate</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>dup</name>.<name>position</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>hlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>message</name>.<name>update</name></name><argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Checks whether the provided context has a count for the provided
     * CounterId.
     *
     * TODO: since the context is sorted, we could implement a binary search.
     * This is however not called in any critical path and contexts will be
     * fairly small so it doesn't matter much.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasCounterId</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>, <param><decl><type><name>CounterId</name></type> <name>id</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// we could use a ContextState but it is easy enough that we avoid the object creation</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</init> <condition><expr><name>offset</name> &lt; <call><name><name>context</name>.<name>limit</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>offset</name> += <name>STEP_LENGTH</name></expr></incr>)
        <block>{
            <if>if <condition>(<expr><call><name><name>id</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>CounterId</name>.<name>wrap</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <return>return <expr>true</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Compute a new context such that if applied to context yields the same
     * total but with old local counter ids nulified and there content merged to
     * the current localCounterId.
     */</comment>
    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>computeOldShardMerger</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>CounterId</name>.<name>CounterIdRecord</name></name></argument>&gt;</argument_list></name></type> <name>oldIds</name></decl></param>, <param><decl><type><name>long</name></type> <name>mergeBefore</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>now</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>hlength</name> <init>= <expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CounterId</name></type> <name>localId</name> <init>= <expr><call><name><name>CounterId</name>.<name>getLocalId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>CounterId</name>.<name>CounterIdRecord</name></name></argument>&gt;</argument_list></name></type> <name>recordIterator</name> <init>= <expr><call><name><name>oldIds</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>CounterId</name>.<name>CounterIdRecord</name></name></type> <name>currRecord</name> <init>= <expr><call><name><name>recordIterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>recordIterator</name>.<name>next</name></name><argument_list>()</argument_list></call> : null</expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>ContextState</name></type> <name>state</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>hlength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>CounterId</name></argument>&gt;</argument_list></name></type> <name>toMerge</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>CounterId</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>mergeTotal</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>state</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>currRecord</name> != null</expr>)</condition>
        <block>{
            <assert>assert <expr>!<call><name><name>currRecord</name>.<name>id</name>.<name>equals</name></name><argument_list>(<argument><expr><name>localId</name></expr></argument>)</argument_list></call></expr>;</assert>

            <decl_stmt><decl><type><name>CounterId</name></type> <name>counterId</name> <init>= <expr><call><name><name>state</name>.<name>getCounterId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name><name>counterId</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>currRecord</name>.<name>id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>c</name> &gt; 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>currRecord</name> = <call><name><name>recordIterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>recordIterator</name>.<name>next</name></name><argument_list>()</argument_list></call> : null</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <if>if <condition>(<expr><call><name><name>state</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>state</name>.<name>getClock</name></name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
                <block>{
                    <comment type="line">// Already merged shard, waiting to be collected</comment>

                    <if>if <condition>(<expr><call><name><name>counterId</name>.<name>equals</name></name><argument_list>(<argument><expr><name>localId</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <comment type="line">// we should not get there, but we have been creating problematic context prior to #2968</comment>
                        <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Current counterId with a negative clock (likely due to #2968). You need to restart this node with -Dcassandra.renew_counter_id=true to fix."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <if>if <condition>(<expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
                    <block>{
                        <comment type="line">// This should not happen, but previous bugs have generated this (#2968 in particular) so fixing it.</comment>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Invalid counter context (clock is %d and count is %d for CounterId %s), will fix"</expr></argument>, <argument><expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>counterId</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>toMerge</name>.<name>add</name></name><argument_list>(<argument><expr><name>counterId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>mergeTotal</name> += <call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then>
                <block>{
                    <comment type="line">// Found an old id. However, merging an oldId that has just been renewed isn't safe, so</comment>
                    <comment type="line">// we check that it has been renewed before mergeBefore.</comment>
                    <if>if <condition>(<expr><name><name>currRecord</name>.<name>timestamp</name></name> &lt; <name>mergeBefore</name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>toMerge</name>.<name>add</name></name><argument_list>(<argument><expr><name>counterId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>mergeTotal</name> += <call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if></else></if>
            }</block></then></if>

            <if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then>
                <expr_stmt><expr><name>currRecord</name> = <call><name><name>recordIterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>recordIterator</name>.<name>next</name></name><argument_list>()</argument_list></call> : null</expr>;</expr_stmt></then></if>

            <expr_stmt><expr><call><name><name>state</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <comment type="line">// Continuing the iteration so that we can repair invalid shards</comment>
        <while>while <condition>(<expr><call><name><name>state</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>CounterId</name></type> <name>counterId</name> <init>= <expr><call><name><name>state</name>.<name>getCounterId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>state</name>.<name>isDelta</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>state</name>.<name>getClock</name></name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>counterId</name>.<name>equals</name></name><argument_list>(<argument><expr><name>localId</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <comment type="line">// we should not get there, but we have been creating problematic context prior to #2968</comment>
                    <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Current counterId with a negative clock (likely due to #2968). You need to restart this node with -Dcassandra.renew_counter_id=true to fix."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <if>if <condition>(<expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
                <block>{
                    <comment type="line">// This should not happen, but previous bugs have generated this (#2968 in particular) so fixing it.</comment>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Invalid counter context (clock is %d and count is %d for CounterId %s), will fix"</expr></argument>, <argument><expr><call><name><name>state</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>counterId</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>toMerge</name>.<name>add</name></name><argument_list>(<argument><expr><name>counterId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>mergeTotal</name> += <call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>state</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr><call><name><name>toMerge</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if>

        <decl_stmt><decl><type><name>ContextState</name></type> <name>merger</name> <init>= <expr><call><name><name>ContextState</name>.<name>allocate</name></name><argument_list>(<argument><expr><call><name><name>toMerge</name>.<name>size</name></name><argument_list>()</argument_list></call> + 1</expr></argument>, <argument><expr><call><name><name>toMerge</name>.<name>size</name></name><argument_list>()</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>state</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>removedTotal</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>localWritten</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>state</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>CounterId</name></type> <name>counterId</name> <init>= <expr><call><name><name>state</name>.<name>getCounterId</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>counterId</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>localId</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>merger</name>.<name>writeElement</name></name><argument_list>(<argument><expr><name>localId</name></expr></argument>, <argument><expr>1L</expr></argument>, <argument><expr><name>mergeTotal</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>localWritten</name> = true</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>i</name> &lt; <call><name><name>toMerge</name>.<name>size</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>counterId</name>.<name>compareTo</name></name><argument_list>(<argument><expr><call><name><name>toMerge</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>removedTotal</name> += <name>count</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>merger</name>.<name>writeElement</name></name><argument_list>(<argument><expr><name>counterId</name></expr></argument>, <argument><expr>-<name>now</name> - <call><name><name>state</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>-<name>count</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
            }</block></then></if></else></if>
            <expr_stmt><expr><call><name><name>state</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>!<name>localWritten</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>merger</name>.<name>writeElement</name></name><argument_list>(<argument><expr><name>localId</name></expr></argument>, <argument><expr>1L</expr></argument>, <argument><expr><name>mergeTotal</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// sanity check</comment>
        <assert>assert <expr><name>mergeTotal</name> == <name>removedTotal</name></expr>;</assert>
        <return>return <expr><name><name>merger</name>.<name>context</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Remove shards that have been canceled through computeOldShardMerger
     * since a time older than gcBefore.
     * Used by compaction to strip context of unecessary information,
     * shrinking them.
     */</comment>
    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>removeOldShards</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>hlength</name> <init>= <expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ContextState</name></type> <name>state</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>hlength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>removedShards</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>removedDelta</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>state</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>clock</name> <init>= <expr><call><name><name>state</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>clock</name> &lt; 0</expr>)</condition><then>
            <block>{
                <comment type="line">// We should never have a count != 0 when clock &lt; 0.</comment>
                <comment type="line">// We know that previous may have created those situation though, so:</comment>
                <comment type="line">//   * for delta shard: we throw an exception since computeOldShardMerger should</comment>
                <comment type="line">//     have corrected that situation</comment>
                <comment type="line">//   * for non-delta shard: it is a much more crappier situation because there is</comment>
                <comment type="line">//     not much we can do since we are not responsible for that shard. So we simply</comment>
                <comment type="line">//     ignore the shard.</comment>
                <if>if <condition>(<expr><call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call> != 0</expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name><name>state</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <block>{
                        <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Counter shard with negative clock but count != 0; context = " + <call><name>toString</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></then>
                    <else>else
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Ignoring non-removable non-delta corrupted shard in context " + <call><name>toString</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>state</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></else></if>
                }</block></then></if>

                <if>if <condition>(<expr>-(<call>(<name>int</name>)<argument_list>(<argument><expr><name>clock</name> / 1000</expr></argument>)</argument_list></call>) &lt; <name>gcBefore</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>removedShards</name>++</expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>state</name>.<name>isDelta</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><name>removedDelta</name>++</expr>;</expr_stmt></then></if>
                }</block></then></if>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>state</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr><name>removedShards</name> == 0</expr>)</condition><then>
            <return>return <expr><name>context</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name>int</name></type> <name>removedHeaderSize</name> <init>= <expr><name>removedDelta</name> * <name>HEADER_ELT_LENGTH</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>removedBodySize</name> <init>= <expr><name>removedShards</name> * <name>STEP_LENGTH</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>newSize</name> <init>= <expr><call><name><name>context</name>.<name>remaining</name></name><argument_list>()</argument_list></call> - <name>removedHeaderSize</name> - <name>removedBodySize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>newHlength</name> <init>= <expr><name>hlength</name> - <name>removedHeaderSize</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>cleanedContext</name> <init>= <expr><call><name><name>HeapAllocator</name>.<name>instance</name>.<name>allocate</name></name><argument_list>(<argument><expr><name>newSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>cleanedContext</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>cleanedContext</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call>(<name>short</name>) <argument_list>(<argument><expr>(<name>newHlength</name> - <name>HEADER_SIZE_LENGTH</name>) / <name>HEADER_ELT_LENGTH</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>ContextState</name></type> <name>cleaned</name> <init>= <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>cleanedContext</name></expr></argument>, <argument><expr><name>newHlength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>state</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>state</name>.<name>hasRemaining</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>clock</name> <init>= <expr><call><name><name>state</name>.<name>getClock</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>clock</name> &gt;= 0 || <call><name><name>state</name>.<name>getCount</name></name><argument_list>()</argument_list></call> != 0 || -(<call>(<name>int</name>)<argument_list>(<argument><expr><name>clock</name> / 1000</expr></argument>)</argument_list></call>) &gt;= <name>gcBefore</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>state</name>.<name>copyTo</name></name><argument_list>(<argument><expr><name>cleaned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name><name>state</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name>cleanedContext</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Helper class to work on contexts (works by iterating over them).
     * A context being abstractly a list of tuple (counterid, clock, count), a
     * ContextState encapsulate a context and a position to one of the tuple.
     * It also allow to create new context iteratively.
     *
     * Note: this is intrinsically a private class intended for use by the
     * methods of CounterContext only. It is however public because it is
     * convenient to create handcrafted context for unit tests.
     */</comment>
    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ContextState</name>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>ByteBuffer</name></type> <name>context</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>headerLength</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>headerOffset</name></decl>;</decl_stmt>  <comment type="line">// offset from context.position()</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>bodyOffset</name></decl>;</decl_stmt>    <comment type="line">// offset from context.position()</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>currentIsDelta</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>ContextState</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>headerLength</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>headerLength</name></expr></argument>, <argument><expr><name>HEADER_SIZE_LENGTH</name></expr></argument>, <argument><expr><name>headerLength</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>updateIsDelta</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><specifier>public</specifier> <name>ContextState</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name>headerLength</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><specifier>private</specifier> <name>ContextState</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>context</name></decl></param>, <param><decl><type><name>int</name></type> <name>headerLength</name></decl></param>, <param><decl><type><name>int</name></type> <name>headerOffset</name></decl></param>, <param><decl><type><name>int</name></type> <name>bodyOffset</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>currentIsDelta</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>context</name></name> = <name>context</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>headerLength</name></name> = <name>headerLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>headerOffset</name></name> = <name>headerOffset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>bodyOffset</name></name> = <name>bodyOffset</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>currentIsDelta</name></name> = <name>currentIsDelta</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isDelta</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><name>currentIsDelta</name></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>updateIsDelta</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><name>currentIsDelta</name> = (<name>headerOffset</name> &lt; <name>headerLength</name>) &amp;&amp; <call><name><name>context</name>.<name>getShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>headerOffset</name></expr></argument>)</argument_list></call> == (<name>short</name>) <call><name>elementIdx</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasRemaining</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><name>bodyOffset</name> &lt; <call><name><name>context</name>.<name>remaining</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>remainingHeaderLength</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><name>headerLength</name> - <name>headerOffset</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>remainingBodyLength</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>context</name>.<name>remaining</name></name><argument_list>()</argument_list></call> - <name>bodyOffset</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>moveToNext</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><name>bodyOffset</name> += <name>STEP_LENGTH</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>currentIsDelta</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>headerOffset</name> += <name>HEADER_ELT_LENGTH</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>updateIsDelta</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <comment type="line">// This advance other to the next position (but not this)</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>copyTo</name><parameter_list>(<param><decl><type><name>ContextState</name></type> <name>other</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>ByteBufferUtil</name>.<name>arrayCopy</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>bodyOffset</name></expr></argument>, <argument><expr><name><name>other</name>.<name>context</name></name></expr></argument>, <argument><expr><call><name><name>other</name>.<name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name><name>other</name>.<name>bodyOffset</name></name></expr></argument>, <argument><expr><name>STEP_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>currentIsDelta</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>other</name>.<name>context</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>other</name>.<name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name><name>other</name>.<name>headerOffset</name></name></expr></argument>, <argument><expr>(<name>short</name>) <call><name><name>other</name>.<name>elementIdx</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>other</name>.<name>currentIsDelta</name></name> = <name>currentIsDelta</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>other</name>.<name>moveToNext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>compareIdTo</name><parameter_list>(<param><decl><type><name>ContextState</name></type> <name>other</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><call><name>compareId</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>bodyOffset</name></expr></argument>, <argument><expr><name><name>other</name>.<name>context</name></name></expr></argument>, <argument><expr><call><name><name>other</name>.<name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name><name>other</name>.<name>bodyOffset</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>reset</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>headerOffset</name></name> = <name>HEADER_SIZE_LENGTH</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>bodyOffset</name></name> = <name>headerLength</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>updateIsDelta</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>CounterId</name></type> <name>getCounterId</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>CounterId</name>.<name>wrap</name></name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>bodyOffset</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>long</name></type> <name>getClock</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>context</name>.<name>getLong</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>bodyOffset</name> + <name><name>CounterId</name>.<name>LENGTH</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>long</name></type> <name>getCount</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>context</name>.<name>getLong</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>bodyOffset</name> + <name><name>CounterId</name>.<name>LENGTH</name></name> + <name>CLOCK_LENGTH</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="line">// Advance this to the next position</comment>
        <function><type><specifier>public</specifier> <name>void</name></type> <name>writeElement</name><parameter_list>(<param><decl><type><name>CounterId</name></type> <name>id</name></decl></param>, <param><decl><type><name>long</name></type> <name>clock</name></decl></param>, <param><decl><type><name>long</name></type> <name>count</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isDelta</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>writeElementAtOffset</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>bodyOffset</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>clock</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>isDelta</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>context</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call> + <name>headerOffset</name></expr></argument>, <argument><expr>(<name>short</name>)<call><name>elementIdx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>currentIsDelta</name> = <name>isDelta</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>moveToNext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>writeElement</name><parameter_list>(<param><decl><type><name>CounterId</name></type> <name>id</name></decl></param>, <param><decl><type><name>long</name></type> <name>clock</name></decl></param>, <param><decl><type><name>long</name></type> <name>count</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>writeElement</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>clock</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>elementIdx</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr>(<name>bodyOffset</name> - <name>headerLength</name>) / <name>STEP_LENGTH</name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>ContextState</name></type> <name>duplicate</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>headerLength</name></expr></argument>, <argument><expr><name>headerOffset</name></expr></argument>, <argument><expr><name>bodyOffset</name></expr></argument>, <argument><expr><name>currentIsDelta</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <comment type="block">/*
         * Allocate a new context big enough for {@code elementCount} elements
         * with {@code deltaCount} of them being delta, and return the initial
         * ContextState corresponding.
         */</comment>
        <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ContextState</name></type> <name>allocate</name><parameter_list>(<param><decl><type><name>int</name></type> <name>elementCount</name></decl></param>, <param><decl><type><name>int</name></type> <name>deltaCount</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><call><name>allocate</name><argument_list>(<argument><expr><name>elementCount</name></expr></argument>, <argument><expr><name>deltaCount</name></expr></argument>, <argument><expr><name><name>HeapAllocator</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ContextState</name></type> <name>allocate</name><parameter_list>(<param><decl><type><name>int</name></type> <name>elementCount</name></decl></param>, <param><decl><type><name>int</name></type> <name>deltaCount</name></decl></param>, <param><decl><type><name>Allocator</name></type> <name>allocator</name></decl></param>)</parameter_list>
        <block>{
            <assert>assert <expr><name>deltaCount</name> &lt;= <name>elementCount</name></expr>;</assert>
            <decl_stmt><decl><type><name>int</name></type> <name>hlength</name> <init>= <expr><name>HEADER_SIZE_LENGTH</name> + <name>deltaCount</name> * <name>HEADER_ELT_LENGTH</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>context</name> <init>= <expr><call><name><name>allocator</name>.<name>allocate</name></name><argument_list>(<argument><expr><name>hlength</name> + <name>elementCount</name> * <name>STEP_LENGTH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>context</name>.<name>putShort</name></name><argument_list>(<argument><expr><call><name><name>context</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>short</name>)<name>deltaCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>new <call><name>ContextState</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>hlength</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>
}</block></class>
</unit>
