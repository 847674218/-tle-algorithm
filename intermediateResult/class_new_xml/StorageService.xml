<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.2.1\src\java\org\apache\cassandra\service\StorageService.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>ByteArrayInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>DataInputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>management</name>.<name>ManagementFactory</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>InetAddress</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>UnknownHostException</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicLong</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>MBeanServer</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>Notification</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>NotificationBroadcasterSupport</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>ObjectName</name></name>;</import>

<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>collect</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>log4j</name>.<name>Level</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>lang</name>.<name>StringUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>auth</name>.<name>Auth</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>DebuggableScheduledThreadPoolExecutor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>Stage</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>StageManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>KSMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>Schema</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>Table</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>commitlog</name>.<name>CommitLog</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>Range</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>exceptions</name>.<name>ConfigurationException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>exceptions</name>.<name>InvalidRequestException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>exceptions</name>.<name>UnavailableException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>gms</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name>.<name>SSTableDeletingTask</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name>.<name>SSTableLoader</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>metrics</name>.<name>StorageMetrics</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>IAsyncResult</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>MessageOut</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>MessagingService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>ResponseVerbHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>AntiEntropyService</name>.<name>TreeRequestVerbHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>streaming</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>Constants</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>EndpointDetails</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>TokenRange</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>tracing</name>.<name>Tracing</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name></name>.*;</import>

<import>import static <name><name>com</name>.<name>google</name>.<name>common</name>.<name>base</name>.<name>Charsets</name>.<name>ISO_8859_1</name></name>;</import>

<comment type="block" format="javadoc">/**
 * This abstraction contains the token/identifier of this node
 * on the identifier space. This token gets gossiped around.
 * This class will also maintain histograms of the load information
 * of other nodes in the cluster.
 */</comment>
<class><specifier>public</specifier> class <name>StorageService</name> <super><extends>extends <name>NotificationBroadcasterSupport</name></extends> <implements>implements <name>IEndpointStateChangeSubscriber</name>, <name>StorageServiceMBean</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>StorageService</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>RING_DELAY</name> <init>= <expr><call><name>getRingDelay</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// delay after which we assume ring has stablized</comment>

    <comment type="block">/* JMX notification serial number counter */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicLong</name></type> <name>notificationSerialNumber</name> <init>= <expr>new <call><name>AtomicLong</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getRingDelay</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>newdelay</name> <init>= <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.ring_delay_ms"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newdelay</name> != null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Overriding RING_DELAY to {}ms"</expr></argument>, <argument><expr><name>newdelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name>newdelay</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
            <return>return <expr>30 * 1000</expr>;</return></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This pool is used for periodic short (sub-second) tasks.
     */</comment>
     <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>DebuggableScheduledThreadPoolExecutor</name></type> <name>scheduledTasks</name> <init>= <expr>new <call><name>DebuggableScheduledThreadPoolExecutor</name><argument_list>(<argument><expr>"ScheduledTasks"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * This pool is used by tasks that can have longer execution times, and usually are non periodic.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>DebuggableScheduledThreadPoolExecutor</name></type> <name>tasks</name> <init>= <expr>new <call><name>DebuggableScheduledThreadPoolExecutor</name><argument_list>(<argument><expr>"NonPeriodicTasks"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/**
     * tasks that do not need to be waited for on shutdown/drain
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>DebuggableScheduledThreadPoolExecutor</name></type> <name>optionalTasks</name> <init>= <expr>new <call><name>DebuggableScheduledThreadPoolExecutor</name><argument_list>(<argument><expr>"OptionalTasks"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>static
    <block>{
        <expr><call><name><name>tasks</name>.<name>setExecuteExistingDelayedTasksAfterShutdownPolicy</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;
    }</block>

    <comment type="block">/* This abstraction maintains the token/endpoint metadata information */</comment>
    private <name>TokenMetadata</name> <name>tokenMetadata</name> = new <call><name>TokenMetadata</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <name><name>VersionedValue</name>.<name>VersionedValueFactory</name></name></type> <name>valueFactory</name> <init>= <expr>new <call><name><name>VersionedValue</name>.<name>VersionedValueFactory</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>StorageService</name></type> <name>instance</name> <init>= <expr>new <call><name>StorageService</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>StorageMetrics</name></type> <name>metrics</name> <init>= <expr>new <call><name>StorageMetrics</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>IPartitioner</name></type> <name>getPartitioner</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getLocalRanges</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getRangesForEndpoint</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getLocalPrimaryRanges</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getPrimaryRangesForEndpoint</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Deprecated</name></annotation>
    <specifier>public</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getLocalPrimaryRange</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getPrimaryRangeForEndpoint</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// For JMX's sake. Use getLocalPrimaryRange for internal uses</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getPrimaryRange</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>replicatingNodes</name> <init>= <expr><call><name><name>Collections</name>.<name>synchronizedSet</name></name><argument_list>(<argument><expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>CassandraDaemon</name></type> <name>daemon</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>InetAddress</name></type> <name>removingNode</name></decl>;</decl_stmt>

    <comment type="block">/* Are we starting this node in bootstrap mode? */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isBootstrapMode</name></decl>;</decl_stmt>

    <comment type="block">/* we bootstrap but do NOT join the ring unless told to do so */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isSurveyMode</name><init>= <expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.write_survey"</expr></argument>, <argument><expr>"false"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* when intialized as a client, we shouldn't write to the system table. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isClientMode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>initialized</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>joined</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

    <comment type="block">/* the probability for tracing any particular request, 0 disables tracing and 1 enables for all */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>double</name></type> <name>tracingProbability</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>

    <enum><specifier>private</specifier> <specifier>static</specifier> enum <name>Mode</name> <block>{ <decl><name>NORMAL</name></decl>, <decl><name>CLIENT</name></decl>, <decl><name>JOINING</name></decl>, <decl><name>LEAVING</name></decl>, <decl><name>DECOMMISSIONED</name></decl>, <decl><name>MOVING</name></decl>, <decl><name>DRAINING</name></decl>, <decl><name>DRAINED</name></decl>, <decl><name>RELOCATING</name></decl> }</block></enum>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Mode</name></type> <name>operationMode</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>MigrationManager</name></type> <name>migrationManager</name> <init>= <expr><name><name>MigrationManager</name>.<name>instance</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Used for tracking drain progress */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>totalCFs</name></decl>, <decl><type ref="prev"/><name>remainingCFs</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>nextRepairCommand</name> <init>= <expr>new <call><name>AtomicInteger</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>ScheduledRangeTransferExecutorService</name></type> <name>rangeXferExecutor</name> <init>= <expr>new <call><name>ScheduledRangeTransferExecutorService</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>IEndpointLifecycleSubscriber</name></argument>&gt;</argument_list></name></type> <name>lifecycleSubscribers</name> <init>= <expr>new <call><name><name>CopyOnWriteArrayList</name><argument_list>&lt;<argument><name>IEndpointLifecycleSubscriber</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ObjectName</name></type> <name>jmxObjectName</name></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>finishBootstrapping</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><name>isBootstrapMode</name> = false</expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/** This method updates the local token on disk  */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTokens</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Setting tokens to {}"</expr></argument>, <argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// order is important here, the gossiper can fire in between adding these two states.  It's ok to send TOKENS without STATUS, but *not* vice versa.</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>TOKENS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>tokens</name></name><argument_list>(<argument><expr><call><name>getLocalTokens</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>normal</name></name><argument_list>(<argument><expr><call><name>getLocalTokens</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>NORMAL</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <constructor><specifier>public</specifier> <name>StorageService</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>MBeanServer</name></type> <name>mbs</name> <init>= <expr><call><name><name>ManagementFactory</name>.<name>getPlatformMBeanServer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>jmxObjectName</name> = new <call><name>ObjectName</name><argument_list>(<argument><expr>"org.apache.cassandra.db:type=StorageService"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mbs</name>.<name>registerMBean</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jmxObjectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <comment type="block">/* register the verb handlers */</comment>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>MUTATION</name></name></expr></argument>, <argument><expr>new <call><name>RowMutationVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>READ_REPAIR</name></name></expr></argument>, <argument><expr>new <call><name>ReadRepairVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>READ</name></name></expr></argument>, <argument><expr>new <call><name>ReadVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>RANGE_SLICE</name></name></expr></argument>, <argument><expr>new <call><name>RangeSliceVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>INDEX_SCAN</name></name></expr></argument>, <argument><expr>new <call><name>IndexScanVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>COUNTER_MUTATION</name></name></expr></argument>, <argument><expr>new <call><name>CounterMutationVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>TRUNCATE</name></name></expr></argument>, <argument><expr>new <call><name>TruncateVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// see BootStrapper for a summary of how the bootstrap verbs interact</comment>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>BOOTSTRAP_TOKEN</name></name></expr></argument>, <argument><expr>new <call><name><name>BootStrapper</name>.<name>BootstrapTokenVerbHandler</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>STREAM_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name>StreamRequestVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>STREAM_REPLY</name></name></expr></argument>, <argument><expr>new <call><name>StreamReplyVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>REPLICATION_FINISHED</name></name></expr></argument>, <argument><expr>new <call><name>ReplicationFinishedVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>REQUEST_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name>ResponseVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>INTERNAL_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name>ResponseVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>TREE_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name>TreeRequestVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>TREE_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name><name>AntiEntropyService</name>.<name>TreeResponseVerbHandler</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>STREAMING_REPAIR_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name><name>StreamingRepairTask</name>.<name>StreamingRepairRequest</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>STREAMING_REPAIR_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name><name>StreamingRepairTask</name>.<name>StreamingRepairResponse</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>GOSSIP_SHUTDOWN</name></name></expr></argument>, <argument><expr>new <call><name>GossipShutdownVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>GOSSIP_DIGEST_SYN</name></name></expr></argument>, <argument><expr>new <call><name>GossipDigestSynVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>GOSSIP_DIGEST_ACK</name></name></expr></argument>, <argument><expr>new <call><name>GossipDigestAckVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>GOSSIP_DIGEST_ACK2</name></name></expr></argument>, <argument><expr>new <call><name>GossipDigestAck2VerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>DEFINITIONS_UPDATE</name></name></expr></argument>, <argument><expr>new <call><name>DefinitionsUpdateVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>SCHEMA_CHECK</name></name></expr></argument>, <argument><expr>new <call><name>SchemaCheckVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>MIGRATION_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name>MigrationRequestVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>SNAPSHOT</name></name></expr></argument>, <argument><expr>new <call><name>SnapshotVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// spin up the streaming service so it is available for jmx tools.</comment>
        <if>if <condition>(<expr><name><name>StreamingService</name>.<name>instance</name></name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Streaming service is unavailable."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
    }</block></constructor>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>registerDaemon</name><parameter_list>(<param><decl><type><name>CassandraDaemon</name></type> <name>daemon</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name><name>this</name>.<name>daemon</name></name> = <name>daemon</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>register</name><parameter_list>(<param><decl><type><name>IEndpointLifecycleSubscriber</name></type> <name>subscriber</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>lifecycleSubscribers</name>.<name>add</name></name><argument_list>(<argument><expr><name>subscriber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>unregister</name><parameter_list>(<param><decl><type><name>IEndpointLifecycleSubscriber</name></type> <name>subscriber</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>lifecycleSubscribers</name>.<name>remove</name></name><argument_list>(<argument><expr><name>subscriber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// should only be called via JMX</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopGossiping</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Stopping gossip by operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>initialized</name> = false</expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="line">// should only be called via JMX</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>startGossiping</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Starting gossip by operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>start</name></name><argument_list>(<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>initialized</name> = true</expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="line">// should only be called via JMX</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>startRPCServer</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"No configured daemon"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>daemon</name>.<name>thriftServer</name>.<name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopRPCServer</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"No configured daemon"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>daemon</name>.<name>thriftServer</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isRPCServerRunning</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>daemon</name>.<name>thriftServer</name>.<name>isRunning</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>startNativeTransport</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"No configured daemon"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>daemon</name>.<name>nativeServer</name>.<name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopNativeTransport</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"No configured  daemon"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>daemon</name>.<name>nativeServer</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isNativeTransportRunning</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>daemon</name>.<name>nativeServer</name>.<name>isRunning</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopClient</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>unregister</name></name><argument_list>(<argument><expr><name>migrationManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>unregister</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// give it a second so that task accepted before the MessagingService shutdown gets submitted to the stage (to avoid RejectedExecutionException)</comment>
        <try>try <block>{ <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000L</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block> <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list> <block>{}</block></catch></try>
        <expr_stmt><expr><call><name><name>StageManager</name>.<name>shutdownNow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isInitialized</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>initialized</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initClient</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>initClient</name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initClient</name><parameter_list>(<param><decl><type><name>int</name></type> <name>delay</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"StorageService does not support switching modes."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>initialized</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>isClientMode</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Starting up client gossip"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>CLIENT</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>register</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>start</name></name><argument_list>(<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// needed for node-ring gathering.</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>NET_VERSION</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>networkVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>listen</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getLocalAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// sleep a while to allow gossip to warm up (the other nodes need to know about this one before they can reply).</comment>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initServer</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>initServer</name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initServer</name><parameter_list>(<param><decl><type><name>int</name></type> <name>delay</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Cassandra version: " + <call><name><name>FBUtilities</name>.<name>getReleaseVersionString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Thrift API version: " + <name><name>Constants</name>.<name>VERSION</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"CQL supported versions: " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><call><name><name>ClientState</name>.<name>getCQLSupportedVersion</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call> + " (default: " + <name><name>ClientState</name>.<name>DEFAULT_CQL_VERSION</name></name> + ")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name>isClientMode</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"StorageService does not support switching modes."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>initialized</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>isClientMode</name> = false</expr>;</expr_stmt>

        <comment type="line">// Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797.</comment>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Class</name>.<name>forName</name></name><argument_list>(<argument><expr>"org.apache.cassandra.service.StorageProxy"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ClassNotFoundException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <expr_stmt><expr><call><name><name>PBSPredictor</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.load_ring_state"</expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Loading persisted ring state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>loadedTokens</name> <init>= <expr><call><name><name>SystemTable</name>.<name>loadTokens</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>loadedHostIds</name> <init>= <expr><call><name><name>SystemTable</name>.<name>loadHostIds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>ep</name> <range>: <expr><call><name><name>loadedTokens</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>ep</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// entry has been mistakenly added, delete it</comment>
                    <expr_stmt><expr><call><name><name>SystemTable</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><call><name><name>loadedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateHostId</name></name><argument_list>(<argument><expr><call><name><name>loadedHostIds</name>.<name>get</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addSavedEndpoint</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.renew_counter_id"</expr></argument>, <argument><expr>"false"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Renewing local node id (as requested)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>CounterId</name>.<name>renewLocalId</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// daemon threads, like our executors', continue to run while shutdown hooks are invoked</comment>
        <decl_stmt><decl><type><name>Thread</name></type> <name>drainOnShutdown</name> <init>= <expr>new <call><name>Thread</name><argument_list>(<argument><expr>new <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{
                <decl_stmt><decl><type><name>ExecutorService</name></type> <name>mutationStage</name> <init>= <expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>mutationStage</name>.<name>isShutdown</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <return>return;</return></then></if> <comment type="line">// drained already</comment>

                <expr_stmt><expr><call><name>stopRPCServer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>optionalTasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// In-progress writes originating here could generate hints to be written, so shut down MessagingService</comment>
                <comment type="line">// before mutation stage, so we can get all the hints saved before shutting down</comment>
                <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mutationStage</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mutationStage</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>3600</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>SECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>instance</name>.<name>verifyNoHintsInProgress</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>flushes</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>KSMetaData</name></type> <name>ksm</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getKSMetaData</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name><name>ksm</name>.<name>durableWrites</name></name></expr>)</condition><then>
                    <block>{
                        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                            <expr_stmt><expr><call><name><name>flushes</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>cfs</name>.<name>forceFlush</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                    }</block></then></if>
                }</block></for>
                <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>waitOnFutures</name></name><argument_list>(<argument><expr><name>flushes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>shutdownBlocking</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// wait for miscellaneous tasks like sstable and commitlog segment deletion</comment>
                <expr_stmt><expr><call><name><name>tasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name><name>tasks</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MINUTES</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Miscellaneous task executor still busy after one minute; proceeding with shutdown"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></function>
        }</block></class></expr></argument>, <argument><expr>"StorageServiceShutdownHook"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Runtime</name>.<name>getRuntime</name></name><argument_list>()</argument_list></call>.<call><name>addShutdownHook</name><argument_list>(<argument><expr><name>drainOnShutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.join_ring"</expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>joinTokenRing</name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Not joining ring as requested. Use JMX (StorageService-&gt;joinRing()) to initiate ring joining"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>joinTokenRing</name><parameter_list>(<param><decl><type><name>int</name></type> <name>delay</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Starting up server gossip"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>joined</name> = true</expr>;</expr_stmt>

        <comment type="line">// Seed the host ID-to-endpoint map with our own ID.</comment>
        <expr_stmt><expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>updateHostId</name><argument_list>(<argument><expr><call><name><name>SystemTable</name>.<name>getLocalHostId</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// have to start the gossip service before we can see any info on other nodes.  this is necessary</comment>
        <comment type="line">// for bootstrap to get the load info it needs.</comment>
        <comment type="line">// (we won't be part of the storage ring though until we add a counterId to our state, below.)</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>ApplicationState</name></argument>, <argument><name>VersionedValue</name></argument>&gt;</argument_list></name></type> <name>appStates</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>ApplicationState</name></argument>, <argument><name>VersionedValue</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>appStates</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>NET_VERSION</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>networkVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>appStates</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>HOST_ID</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>hostId</name></name><argument_list>(<argument><expr><call><name><name>SystemTable</name>.<name>getLocalHostId</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>appStates</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RPC_ADDRESS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>rpcaddress</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>0 != <call><name><name>DatabaseDescriptor</name>.<name>getReplaceTokens</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>appStates</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>hibernate</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name><name>appStates</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RELEASE_VERSION</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>releaseVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>register</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>register</name></name><argument_list>(<argument><expr><name>migrationManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>start</name></name><argument_list>(<argument><expr><call><name><name>SystemTable</name>.<name>incrementAndGetGeneration</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>appStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// needed for node-ring gathering.</comment>
        <comment type="line">// gossip snitch infos (local DC and rack)</comment>
        <expr_stmt><expr><call><name>gossipSnitchInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// gossip Schema.emptyVersion forcing immediate check for schema updates (see MigrationManager#maybeScheduleSchemaPull)</comment>
        <expr_stmt><expr><call><name><name>Schema</name>.<name>instance</name>.<name>updateVersionAndAnnounce</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Ensure we know our own actual Schema UUID in preparation for updates</comment>


        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>listen</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getLocalAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>LoadBroadcaster</name>.<name>instance</name>.<name>startBroadcasting</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>BatchlogManager</name>.<name>instance</name>.<name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// We bootstrap if we haven't successfully bootstrapped before, as long as we are not a seed.</comment>
        <comment type="line">// If we are a seed, or if the user manually sets auto_bootstrap to false,</comment>
        <comment type="line">// we'll skip streaming data from other nodes and jump directly into the ring.</comment>
        <comment type="line">//</comment>
        <comment type="line">// The seed check allows us to skip the RING_DELAY sleep for the single-node cluster case,</comment>
        <comment type="line">// which is useful for both new users and testing.</comment>
        <comment type="line">//</comment>
        <comment type="line">// We attempted to replace this with a schema-presence check, but you need a meaningful sleep</comment>
        <comment type="line">// to get schema info from gossip which defeats the purpose.  See CASSANDRA-4427 for the gory details.</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>current</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Bootstrap variables: {} {} {} {}"</expr></argument>,
                      <argument><expr>new <name><name>Object</name><index>[]</index></name><block>{ <expr><call><name><name>DatabaseDescriptor</name>.<name>isAutoBootstrap</name></name><argument_list>()</argument_list></call></expr>,
                                    <expr><call><name><name>SystemTable</name>.<name>bootstrapInProgress</name></name><argument_list>()</argument_list></call></expr>,
                                    <expr><call><name><name>SystemTable</name>.<name>bootstrapComplete</name></name><argument_list>()</argument_list></call></expr>,
                                    <expr><call><name><name>DatabaseDescriptor</name>.<name>getSeeds</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name>.<name>isAutoBootstrap</name></name><argument_list>()</argument_list></call>
            &amp;&amp; !<call><name><name>SystemTable</name>.<name>bootstrapComplete</name></name><argument_list>()</argument_list></call>
            &amp;&amp; !<call><name><name>DatabaseDescriptor</name>.<name>getSeeds</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><call><name><name>SystemTable</name>.<name>bootstrapInProgress</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Detected previous bootstrap failure; retrying"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>IN_PROGRESS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"waiting for ring information"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// first sleep the delay to make sure we see all our peers</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>delay</name></expr>;</condition> <incr><expr><name>i</name> += 1000</expr></incr>)
            <block>{
                <comment type="line">// if we see schema, we can proceed to the next check directly</comment>
                <if>if <condition>(<expr>!<call><name><name>Schema</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name><name>Schema</name>.<name>emptyVersion</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"got schema: {}"</expr></argument>, <argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <try>try
                <block>{
                    <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></for>
            <comment type="line">// if our schema hasn't matched yet, keep sleeping until it does</comment>
            <comment type="line">// (post CASSANDRA-1391 we don't expect this to be necessary very often, but it doesn't hurt to be careful)</comment>
            <while>while <condition>(<expr>!<call><name><name>MigrationManager</name>.<name>isReadyForBootstrap</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"waiting for schema information to complete"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <try>try
                <block>{
                    <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></while>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"schema complete, ready to bootstrap"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>


            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"... got ring + schema info"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name>.<name>getReplaceTokens</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isMember</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr>"This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)"</expr></init></decl>;</decl_stmt>
                    <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"getting bootstrap token"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tokens</name> = <call><name><name>BootStrapper</name>.<name>getBootstrapTokens</name></name><argument_list>(<argument><expr><name>tokenMetadata</name></expr></argument>, <argument><expr><call><name><name>LoadBroadcaster</name>.<name>instance</name>.<name>getLoadInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <try>try
                <block>{
                    <comment type="line">// Sleeping additionally to make sure that the server actually is not alive</comment>
                    <comment type="line">// and giving it more time to gossip if alive.</comment>
                    <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name><name>LoadBroadcaster</name>.<name>BROADCAST_INTERVAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
                <expr_stmt><expr><name>tokens</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <for>for (<init><decl><type><name>String</name></type> <name>token</name> <range>: <expr><call><name><name>DatabaseDescriptor</name>.<name>getReplaceTokens</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

                <comment type="line">// check for operator errors...</comment>
                <for>for (<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>InetAddress</name></type> <name>existing</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>existing</name> != null</expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call>.<call><name>getUpdateTimestamp</name><argument_list>()</argument_list></call> &gt; (<call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> - <name>delay</name>)</expr>)</condition><then>
                            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Cannnot replace a token for a Live node... "</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                        <expr_stmt><expr><call><name><name>current</name>.<name>add</name></name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>

                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"Replacing a node with token: " + <name>tokens</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><call><name>bootstrap</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr>!<name>isBootstrapMode</name></expr>;</assert> <comment type="line">// bootstrap will block until finished</comment>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name>tokens</name> = <call><name><name>SystemTable</name>.<name>getSavedTokens</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>tokens</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>initialTokens</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getInitialTokens</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>initialTokens</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; 1</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>tokens</name> = <call><name><name>BootStrapper</name>.<name>getRandomTokens</name></name><argument_list>(<argument><expr><name>tokenMetadata</name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getNumTokens</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name>.<name>getNumTokens</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Generated random token " + <name>tokens</name> + ". Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                    <else>else
                        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Generated random tokens. tokens are {}"</expr></argument>, <argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><name>tokens</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name>String</name></type> <name>token</name> <range>: <expr><name>initialTokens</name></expr></range></decl></init>)
                        <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Saved token not found. Using " + <name>tokens</name> + " from configuration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
            <else>else
            <block>{
                <comment type="line">// if we were already bootstrapped with 1 token but num_tokens is set higher in the config,</comment>
                <comment type="line">// then we need to migrate to multi-token</comment>
                <if>if <condition>(<expr><call><name><name>tokens</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1 &amp;&amp; <call><name><name>DatabaseDescriptor</name>.<name>getNumTokens</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                <block>{
                    <comment type="line">// wait for ring info</comment>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Sleeping for ring delay (" + <name>delay</name> + "ms)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <try>try
                    <block>{
                        <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                    <block>{
                        <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Calculating new tokens"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// calculate num_tokens tokens evenly spaced in the range (left, right]</comment>
                    <decl_stmt><decl><type><name>Token</name></type> <name>right</name> <init>= <expr><call><name><name>tokens</name>.<name>iterator</name></name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>clone</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>clone</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <decl_stmt><decl><type><name>Token</name></type> <name>left</name> <init>= <expr><call><name><name>clone</name>.<name>getPredecessor</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// get (num_tokens - 1) tokens spaced evenly, and the last token will be our current token (right)</comment>
                    <for>for (<init><decl><type><name>int</name></type> <name>tok</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>tok</name> &lt; <call><name><name>DatabaseDescriptor</name>.<name>getNumTokens</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr>++<name>tok</name></expr></incr>)
                    <block>{
                        <decl_stmt><decl><type><name>Token</name></type> <name>l</name> <init>= <expr><name>left</name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Token</name></type> <name>r</name> <init>= <expr><name>right</name></expr></init></decl>;</decl_stmt>
                        <comment type="line">// iteratively calculate the location of the token using midpoint</comment>
                        <comment type="line">// num iterations is number of bits in IEE754 mantissa (including implicit leading 1)</comment>
                        <comment type="line">// we stop early for terminating fractions</comment>
                        <comment type="line">// TODO: alternatively we could add an interpolate() method to IPartitioner</comment>
                        <decl_stmt><decl><type><name>double</name></type> <name>frac</name> <init>= <expr>(<name>double</name>)<name>tok</name> / (<name>double</name>)<call><name><name>DatabaseDescriptor</name>.<name>getNumTokens</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Token</name></type> <name>midpoint</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>midpoint</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 53</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
                        <block>{
                            <expr_stmt><expr><name>frac</name> *= 2</expr>;</expr_stmt>
                            <if>if <condition>(<expr><name>frac</name> == 1.0</expr>)</condition><then> <comment type="block">/* not a bug */</comment>
                                <break>break;</break></then>
                            <else>else <if>if <condition>(<expr><name>frac</name> &gt; 1.0</expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>l</name> = <name>midpoint</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>frac</name> -= 1.0</expr>;</expr_stmt>
                            }</block></then>
                            <else>else
                                <expr_stmt><expr><name>r</name> = <name>midpoint</name></expr>;</expr_stmt></else></if></else></if>
                            <expr_stmt><expr><name>midpoint</name> = <call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>midpoint</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></for>
                        <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><name>midpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Split previous range (" + <name>left</name> + ", " + <name>right</name> + "] into " + <name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                    <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Using saved token " + <name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></else></if>
        }</block></else></if>

        <if>if <condition>(<expr>!<name>isSurveyMode</name></expr>)</condition><then>
        <block>{
            <comment type="line">// start participating in the ring.</comment>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>COMPLETED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setTokens</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// remove the existing info about the replaced node.</comment>
            <if>if <condition>(<expr>!<call><name><name>current</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <for>for (<init><decl><type><name>InetAddress</name></type> <name>existing</name> <range>: <expr><name>current</name></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>replacedEndpoint</name></name><argument_list>(<argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Startup completed! Now serving reads."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name><name>tokenMetadata</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>;</assert>

            <comment type="line">// setup default superuser (if needed).</comment>
            <expr_stmt><expr><call><name><name>Auth</name>.<name>setupSuperuser</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Startup complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService-&gt;joinRing()) to finalize ring joining."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>gossipSnitchInfo</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>dc</name> <init>= <expr><call><name><name>snitch</name>.<name>getDatacenter</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>rack</name> <init>= <expr><call><name><name>snitch</name>.<name>getRack</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>DC</name></name></expr></argument>, <argument><expr><call><name><name>StorageService</name>.<name>instance</name>.<name>valueFactory</name>.<name>datacenter</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RACK</name></name></expr></argument>, <argument><expr><call><name><name>StorageService</name>.<name>instance</name>.<name>valueFactory</name>.<name>rack</name></name><argument_list>(<argument><expr><name>rack</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>joinRing</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr>!<name>joined</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Joining ring by operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name>joinTokenRing</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>isSurveyMode</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>setTokens</name><argument_list>(<argument><expr><call><name><name>SystemTable</name>.<name>getSavedTokens</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>COMPLETED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isSurveyMode</name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Leaving write survey mode and joining ring at operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name><name>tokenMetadata</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>;</assert>

            <comment type="line">// setup default superuser (if needed).</comment>
            <expr_stmt><expr><call><name><name>Auth</name>.<name>setupSuperuser</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isJoined</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>joined</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>rebuild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>sourceDc</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"rebuild from dc: {}"</expr></argument>, <argument><expr><name>sourceDc</name> == null ? "(any dc)" : <name>sourceDc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>RangeStreamer</name></type> <name>streamer</name> <init>= <expr>new <call><name>RangeStreamer</name><argument_list>(<argument><expr><name>tokenMetadata</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>REBUILD</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>streamer</name>.<name>addSourceFilter</name></name><argument_list>(<argument><expr>new <call><name><name>RangeStreamer</name>.<name>FailureDetectorSourceFilter</name></name><argument_list>(<argument><expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>sourceDc</name> != null</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>streamer</name>.<name>addSourceFilter</name></name><argument_list>(<argument><expr>new <call><name><name>RangeStreamer</name>.<name>SingleDatacenterFilter</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sourceDc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>streamer</name>.<name>addRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getLocalRanges</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <expr_stmt><expr><call><name><name>streamer</name>.<name>fetch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStreamThroughputMbPerSec</name><parameter_list>(<param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setStreamThroughputOutboundMegabitsPerSec</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"setstreamthroughput: throttle set to {}"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getStreamThroughputMbPerSec</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getStreamThroughputOutboundMegabitsPerSec</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCompactionThroughputMbPerSec</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getCompactionThroughputMbPerSec</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactionThroughputMbPerSec</name><parameter_list>(<param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setCompactionThroughputMbPerSec</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isIncrementalBackupsEnabled</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>isIncrementalBackupsEnabled</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setIncrementalBackupsEnabled</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setIncrementalBackupsEnabled</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setMode</name><parameter_list>(<param><decl><type><name>Mode</name></type> <name>m</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>log</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>null</expr></argument>, <argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setMode</name><parameter_list>(<param><decl><type><name>Mode</name></type> <name>m</name></decl></param>, <param><decl><type><name>String</name></type> <name>msg</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>log</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>operationMode</name> = <name>m</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>logMsg</name> <init>= <expr><name>msg</name> == null ? <call><name><name>m</name>.<name>toString</name></name><argument_list>()</argument_list></call> : <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s: %s"</expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>log</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr><name>logMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr><name>logMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>bootstrap</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>isBootstrapMode</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// DON'T use setToken, that makes us part of the ring locally which is incorrect until we are done bootstrapping</comment>
        <if>if <condition>(<expr>0 == <call><name><name>DatabaseDescriptor</name>.<name>getReplaceTokens</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// if not an existing token then bootstrap</comment>
            <comment type="line">// order is important here, the gossiper can fire in between adding these two states.  It's ok to send TOKENS without STATUS, but *not* vice versa.</comment>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>TOKENS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>tokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>,
                                                       <argument><expr><call><name><name>valueFactory</name>.<name>bootstrapping</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"sleeping " + <name>RING_DELAY</name> + " ms for pending range setup"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// Dont set any state for the node which is bootstrapping the existing token...</comment>
            <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name><name>Tracing</name>.<name>instance</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"Starting to bootstrap..."</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>new <call><name>BootStrapper</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>tokenMetadata</name></expr></argument>)</argument_list></call>.<call><name>bootstrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// handles token update</comment>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Bootstrap completed! for the tokens {}"</expr></argument>, <argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isBootstrapMode</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>isBootstrapMode</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>TokenMetadata</name></type> <name>getTokenMetadata</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>tokenMetadata</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Gossip about the known severity of the events in this node
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>boolean</name></type> <name>reportSeverity</name><parameter_list>(<param><decl><type><name>double</name></type> <name>incr</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>Gossiper</name>.<name>instance</name>.<name>isEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <decl_stmt><decl><type><name>double</name></type> <name>update</name> <init>= <expr><call><name>getSeverity</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> + <name>incr</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>VersionedValue</name></type> <name>updated</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>valueFactory</name>.<name>severity</name></name><argument_list>(<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>SEVERITY</name></name></expr></argument>, <argument><expr><name>updated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getSeverity</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>VersionedValue</name></type> <name>event</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>EndpointState</name></type> <name>state</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>state</name> != null &amp;&amp; (<name>event</name> = <call><name><name>state</name>.<name>getApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>SEVERITY</name></name></expr></argument>)</argument_list></call>) != null</expr>)</condition><then>
            <return>return <expr><call><name><name>Double</name>.<name>parseDouble</name></name><argument_list>(<argument><expr><name><name>event</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <return>return <expr>0.0</expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * for a keyspace, return the ranges and corresponding listen addresses.
     * @param keyspace
     * @return the endpoint map
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangeToEndpointMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* All the ranges for the tokens */</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>,<argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getRangeToAddressMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Return the rpc address associated with an endpoint as a string.
     * @param endpoint The endpoint to get rpc address for
     * @return the rpc address
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getRpcaddress</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcAddress</name></name><argument_list>()</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr>;</return></then>
        <else>else <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>getApplicationState</name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RPC_ADDRESS</name></name></expr></argument>)</argument_list></call> == null</expr>)</condition><then>
            <return>return <expr><call><name><name>endpoint</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr>;</return></then>
        <else>else
            <return>return <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>getApplicationState</name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RPC_ADDRESS</name></name></expr></argument>)</argument_list></call>.<name>value</name></expr>;</return></else></if></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * for a keyspace, return the ranges and corresponding RPC addresses for a given keyspace.
     * @param keyspace
     * @return the endpoint map
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangeToRpcaddressMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* All the ranges for the tokens */</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getRangeToAddressMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>rpcaddrs</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name><range>: <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>rpcaddrs</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getRpcaddress</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rpcaddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getPendingRangeToEndpointMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// some people just want to get a visual representation of things. Allow null and set it to the first</comment>
        <comment type="line">// non-system table.</comment>
        <if>if <condition>(<expr><name>keyspace</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>keyspace</name> = <call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>tokenMetadata</name>.<name>getPendingRanges</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>l</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>stringify</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangeToAddressMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// some people just want to get a visual representation of things. Allow null and set it to the first</comment>
        <comment type="line">// non-system table.</comment>
        <if>if <condition>(<expr><name>keyspace</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>keyspace</name> = <call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name>getAllRanges</name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>constructRangeToEndpointMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * The same as {@code describeRing(String)} but converts TokenRange to the String for JMX compatibility
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) converted to String for the given keyspace
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>describeRingJMX</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name></type> <name>tokenRanges</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>tokenRanges</name> = <call><name>describeRing</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InvalidRequestException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenRanges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>TokenRange</name></type> <name>tokenRange</name> <range>: <expr><name>tokenRanges</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>result</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>tokenRange</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * The TokenRange for a given keyspace.
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) for the given keyspace
     *
     * @throws InvalidRequestException if there is no ring information available about keyspace
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name></type> <name>describeRing</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>keyspace</name> == null || !<call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"There is no ring for the keyspace: " + <name>keyspace</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Token</name>.<name>TokenFactory</name></name></type> <name>tf</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getRangeToAddressMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Range</name></type> <name>range</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>addresses</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>addresses</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>rpc_endpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>addresses</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>EndpointDetails</name></argument>&gt;</argument_list></name></type> <name>epDetails</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>EndpointDetails</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>addresses</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>addresses</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>EndpointDetails</name></type> <name>details</name> <init>= <expr>new <call><name>EndpointDetails</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>details</name>.<name>host</name></name> = <call><name><name>endpoint</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>details</name>.<name>datacenter</name></name> = <call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenter</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>details</name>.<name>rack</name></name> = <call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getRack</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>endpoints</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>details</name>.<name>host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rpc_endpoints</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getRpcaddress</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>epDetails</name>.<name>add</name></name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <decl_stmt><decl><type><name>TokenRange</name></type> <name>tr</name> <init>= <expr>new <call><name>TokenRange</name><argument_list>(<argument><expr><call><name><name>tf</name>.<name>toString</name></name><argument_list>(<argument><expr><call><name><name>range</name>.<name>left</name>.<name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>tf</name>.<name>toString</name></name><argument_list>(<argument><expr><call><name><name>range</name>.<name>right</name>.<name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>)</argument_list></call>
                                    .<call><name>setEndpoint_details</name><argument_list>(<argument><expr><name>epDetails</name></expr></argument>)</argument_list></call>
                                    .<call><name>setRpc_endpoints</name><argument_list>(<argument><expr><name>rpc_endpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>ranges</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getTokenToEndpointMap</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>mapInetAddress</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getNormalAndBootstrappingTokenToEndpointMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// in order to preserve tokens in ascending order, we use LinkedHashMap here</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>mapString</name> <init>= <expr>new <call><name><name>LinkedHashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mapInetAddress</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mapInetAddress</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>mapString</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>token</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>mapInetAddress</name>.<name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>mapString</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getLocalHostId</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>getHostId</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getHostIdMap</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>mapOut</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>getEndpointToHostIdMapForReading</name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>mapOut</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>mapOut</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Construct the range to endpoint mapping based on the true view
     * of the world.
     * @param ranges
     * @return mapping of ranges to the replicas responsible for them.
    */</comment>
    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>constructRangeToEndpointMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangeToEndpointMap</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>rangeToEndpointMap</name>.<name>put</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>rangeToEndpointMap</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * Handle the reception of a new particular ApplicationState for a particular endpoint. Note that the value of the
     * ApplicationState has not necessarily "changed" since the last known value, if we already received the same update
     * from somewhere else.
     *
     * onChange only ever sees one ApplicationState piece change at a time (even if many ApplicationState updates were
     * received at the same time), so we perform a kind of state machine here. We are concerned with two events: knowing
     * the token associated with an endpoint, and knowing its operation mode. Nodes can start in either bootstrap or
     * normal mode, and from bootstrap mode can change mode to normal. A node in bootstrap mode needs to have
     * pendingranges set in TokenMetadata; a node in normal mode should instead be part of the token ring.
     *
     * Normal progression of ApplicationState.STATUS values for a node should be like this:
     * STATUS_BOOTSTRAPPING,token
     *   if bootstrapping. stays this way until all files are received.
     * STATUS_NORMAL,token
     *   ready to serve reads and writes.
     * STATUS_LEAVING,token
     *   get ready to leave the cluster as part of a decommission
     * STATUS_LEFT,token
     *   set after decommission is completed.
     *
     * Other STATUS values that may be seen (possibly anywhere in the normal progression):
     * STATUS_MOVING,newtoken
     *   set if node is currently moving to a new token in the ring
     * STATUS_RELOCATING,srcToken,srcToken,srcToken,...
     *   set if the endpoint is in the process of relocating a token to itself
     * REMOVING_TOKEN,deadtoken
     *   set if the node is dead and is being removed by its REMOVAL_COORDINATOR
     * REMOVED_TOKEN,deadtoken
     *   set if the node is dead and has been removed by its REMOVAL_COORDINATOR
     *
     * Note: Any time a node state changes from STATUS_NORMAL, it will not be visible to new nodes. So it follows that
     * you should never bootstrap a new node during a removetoken, decommission or move.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>onChange</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>ApplicationState</name></type> <name>state</name></decl></param>, <param><decl><type><name>VersionedValue</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <switch>switch <condition>(<expr><name>state</name></expr>)</condition>
        <block>{
            <case>case <expr><name>STATUS</name></expr>:
                <decl_stmt><decl><type><name>String</name></type> <name>apStateValue</name> <init>= <expr><name><name>value</name>.<name>value</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>pieces</name> <init>= <expr><call><name><name>apStateValue</name>.<name>split</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>DELIMITER_STR</name></name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <assert>assert <expr>(<name><name>pieces</name>.<name>length</name></name> &gt; 0)</expr>;</assert>

                <decl_stmt><decl><type><name>String</name></type> <name>moveName</name> <init>= <expr><name><name>pieces</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_BOOTSTRAPPING</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateBootstrap</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_NORMAL</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateNormal</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>REMOVING_TOKEN</name></name></expr></argument>)</argument_list></call> || <call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>REMOVED_TOKEN</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateRemoving</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_LEAVING</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateLeaving</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_LEFT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateLeft</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_MOVING</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateMoving</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_RELOCATING</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateRelocating</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if></else></if>
                <break>break;</break>
            </case><case>case <expr><name>RELEASE_VERSION</name></expr>:
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updatePeerInfo</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr>"release_version"</expr></argument>, <argument><expr><name><name>value</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>DC</name></expr>:
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updatePeerInfo</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr>"data_center"</expr></argument>, <argument><expr><name><name>value</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>RACK</name></expr>:
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updatePeerInfo</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr>"rack"</expr></argument>, <argument><expr><name><name>value</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>RPC_ADDRESS</name></expr>:
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updatePeerInfo</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr>"rpc_address"</expr></argument>, <argument><expr><name><name>value</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>SCHEMA</name></expr>:
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updatePeerInfo</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr>"schema_version"</expr></argument>, <argument><expr><name><name>value</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>HOST_ID</name></expr>:
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updatePeerInfo</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr>"host_id"</expr></argument>, <argument><expr><name><name>value</name>.<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </case>}</block></switch>
    }</block></function>

    <function><type><specifier>private</specifier> <name>byte</name><index>[]</index></type> <name>getApplicationStateValue</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>ApplicationState</name></type> <name>appstate</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>vvalue</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>getApplicationState</name><argument_list>(<argument><expr><name>appstate</name></expr></argument>)</argument_list></call>.<name>value</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>vvalue</name>.<name>getBytes</name></name><argument_list>(<argument><expr><name>ISO_8859_1</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getTokensFor</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>String</name></type> <name>piece</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>usesVnodes</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <try>try
            <block>{
                <return>return <expr><call><name><name>TokenSerializer</name>.<name>deserialize</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>new <call><name>DataInputStream</name><argument_list>(<argument><expr>new <call><name>ByteArrayInputStream</name><argument_list>(<argument><expr><call><name>getApplicationStateValue</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name><name>ApplicationState</name>.<name>TOKENS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then>
        <else>else
            <return>return <expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>piece</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node bootstrap
     *
     * @param endpoint bootstrapping node
     * @param pieces STATE_BOOTSTRAPPING,bootstrap token as string
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateBootstrap</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>

        <comment type="line">// Parse versioned values according to end-point version:</comment>
        <comment type="line">//   versions  &lt; 1.2 .....: STATUS,TOKEN</comment>
        <comment type="line">//   versions &gt;= 1.2 .....: use TOKENS app state</comment>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl>;</decl_stmt>
        <comment type="line">// explicitly check for TOKENS, because a bootstrapping node might be bootstrapping in legacy mode; that is, not using vnodes and no token specified</comment>
        <expr_stmt><expr><name>tokens</name> = <call><name>getTokensFor</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state bootstrapping, token " + <name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// if this node is present in token metadata, either we have missed intermediate states</comment>
        <comment type="line">// or the node had crashed. Print warning if needed, clear obsolete stuff and</comment>
        <comment type="line">// continue.</comment>
        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// If isLeaving is false, we have missed both LEAVING and LEFT. However, if</comment>
            <comment type="line">// isLeaving is true, we have only missed LEFT. Waiting time between completing</comment>
            <comment type="line">// leave operation and rebootstrapping is relatively short, so the latter is quite</comment>
            <comment type="line">// common (not enough time for gossip to spread). Therefore we report only the</comment>
            <comment type="line">// former in the log.</comment>
            <if>if <condition>(<expr>!<call><name><name>tokenMetadata</name>.<name>isLeaving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state jump to bootstrap"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>addBootstrapTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>usesHostId</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateHostId</name></name><argument_list>(<argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getHostId</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node move to normal state. That is, node is entering token ring and participating
     * in reads.
     *
     * @param endpoint node
     * @param pieces STATE_NORMAL,token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateNormal</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>

        <comment type="line">// Parse versioned values according to end-point version:</comment>
        <comment type="line">//   versions  &lt; 1.2 .....: STATUS,TOKEN</comment>
        <comment type="line">//   versions &gt;= 1.2 .....: uses HOST_ID/TOKENS app states</comment>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>tokens</name> = <call><name>getTokensFor</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state normal, token " + <name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state jump to normal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
            <block>{
                <for>for (<init><decl><type><name>IEndpointLifecycleSubscriber</name></type> <name>subscriber</name> <range>: <expr><name>lifecycleSubscribers</name></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>subscriber</name>.<name>onUp</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
        <block>{
            <for>for (<init><decl><type><name>IEndpointLifecycleSubscriber</name></type> <name>subscriber</name> <range>: <expr><name>lifecycleSubscribers</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>subscriber</name>.<name>onJoinCluster</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if></else></if>

        <comment type="line">// Order Matters, TM.updateHostID() should be called before TM.updateNormalToken(), (see CASSANDRA-4300).</comment>
        <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>usesHostId</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateHostId</name></name><argument_list>(<argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getHostId</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokensToUpdateInMetadata</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokensToUpdateInSystemTable</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>localTokensToRemove</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpointsToRemove</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>epToTokenCopy</name> <init>= <expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>getEndpointToTokenMapForReading</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><specifier>final</specifier> <name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)
        <block>{
            <comment type="line">// we don't want to update if this node is responsible for the token and it has a later startup time than endpoint.</comment>
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>currentOwner</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>currentOwner</name> == null</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"New node " + <name>endpoint</name> + " at token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>tokensToUpdateInMetadata</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>tokensToUpdateInSystemTable</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <comment type="line">// set state back to normal, since the node may have tried to leave, but failed and is now back up</comment>
                <comment type="line">// no need to persist, token/ip did not change</comment>
                <expr_stmt><expr><call><name><name>tokensToUpdateInMetadata</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isRelocating</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>tokenMetadata</name>.<name>getRelocatingRanges</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <comment type="line">// Token was relocating, this is the bookkeeping that makes it official.</comment>
                <expr_stmt><expr><call><name><name>tokensToUpdateInMetadata</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>tokensToUpdateInSystemTable</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><call><name><name>optionalTasks</name>.<name>schedule</name></name><argument_list>(<argument><expr>new <class><super><name>Runnable</name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Removing RELOCATION state for {} {}"</expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>removeFromRelocating</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></function>
                }</block></class></expr></argument>, <argument><expr><name>RING_DELAY</name></expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// We used to own this token; This token will need to be removed from system.local</comment>
                <if>if <condition>(<expr><call><name><name>currentOwner</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>localTokensToRemove</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Token {} relocated to {}"</expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isRelocating</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Token {} is relocating to {}, ignoring update from {}"</expr></argument>,
                        <argument><expr>new <name><name>Object</name><index>[]</index></name><block>{<expr><name>token</name></expr>, <expr><call><name><name>tokenMetadata</name>.<name>getRelocatingRanges</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>, <expr><name>endpoint</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>compareEndpointStartup</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>tokensToUpdateInMetadata</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>tokensToUpdateInSystemTable</name>.<name>add</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <comment type="line">// currentOwner is no longer current, endpoint is.  Keep track of these moves, because when</comment>
                <comment type="line">// a host no longer has any tokens, we'll want to remove it.</comment>
                <expr_stmt><expr><call><name><name>epToTokenCopy</name>.<name>get</name></name><argument_list>(<argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call>.<call><name>remove</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>epToTokenCopy</name>.<name>get</name></name><argument_list>(<argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &lt; 1</expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>endpointsToRemove</name>.<name>add</name></name><argument_list>(<argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Nodes %s and %s have the same token %s.  %s is the new owner"</expr></argument>,
                                          <argument><expr><name>endpoint</name></expr></argument>,
                                          <argument><expr><name>currentOwner</name></expr></argument>,
                                          <argument><expr><name>token</name></expr></argument>,
                                          <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Relocating ranges: {}"</expr></argument>, <argument><expr><call><name><name>tokenMetadata</name>.<name>printRelocatingRanges</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Nodes %s and %s have the same token %s.  Ignoring %s"</expr></argument>,
                                           <argument><expr><name>endpoint</name></expr></argument>,
                                           <argument><expr><name>currentOwner</name></expr></argument>,
                                           <argument><expr><name>token</name></expr></argument>,
                                           <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Relocating ranges: {}"</expr></argument>, <argument><expr><call><name><name>tokenMetadata</name>.<name>printRelocatingRanges</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></else></if></else></if></else></if></else></if></else></if>
        }</block></for>

        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>tokensToUpdateInMetadata</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>ep</name> <range>: <expr><name>endpointsToRemove</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name>removeEndpoint</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <if>if <condition>(<expr>!<call><name><name>tokensToUpdateInSystemTable</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateTokens</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>tokensToUpdateInSystemTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>!<call><name><name>localTokensToRemove</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateLocalTokens</name></name><argument_list>(<argument><expr><name><name>Collections</name>.</name>&lt;<name>Token</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>localTokensToRemove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isMoving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="line">// if endpoint was moving to a new token</comment>
        <block>{
            <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>removeFromMoving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
            <block>{
                <for>for (<init><decl><type><name>IEndpointLifecycleSubscriber</name></type> <name>subscriber</name> <range>: <expr><name>lifecycleSubscribers</name></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>subscriber</name>.<name>onMove</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            }</block></then></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node preparing to leave the ring
     *
     * @param endpoint node
     * @param pieces STATE_LEAVING,token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateLeaving</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>tokens</name> = <call><name>getTokensFor</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state leaving, tokens " + <name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// If the node is previously unknown or tokens do not match, update tokenmetadata to</comment>
        <comment type="line">// have this node as 'normal' (it must have been using this token before the</comment>
        <comment type="line">// leave). This way we'll get pending ranges right.</comment>
        <if>if <condition>(<expr>!<call><name><name>tokenMetadata</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state jump to leaving"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name><name>tokenMetadata</name>.<name>getTokens</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>containsAll</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " 'leaving' token mismatch. Long network partition?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <comment type="line">// at this point the endpoint is certainly a member with this token, so let's proceed</comment>
        <comment type="line">// normally</comment>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node leaving the ring. This will happen when a node is decommissioned
     *
     * @param endpoint If reason for leaving is decommission, endpoint is the leaving node.
     * @param pieces STATE_LEFT,token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateLeft</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Integer</name></type> <name>version</name> <init>= <expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>getVersion</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>tokens</name> = <call><name>getTokensFor</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state left, tokens " + <name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name>extractExpireTime</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node moving inside the ring.
     *
     * @param endpoint moving endpoint address
     * @param pieces STATE_MOVING, token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateMoving</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state moving, new token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>addMovingEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle one or more ranges (tokens) moving from their respective endpoints, to another.
     *
     * @param endpoint the destination of the move
     * @param pieces STATE_RELOCATING,token,token,...
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateRelocating</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>pieces</name>.<name>length</name></name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>tStr</name> <range>: <expr><call><name><name>Arrays</name>.<name>copyOfRange</name></name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>pieces</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>tStr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Tokens {} are relocating to {}"</expr></argument>, <argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>addRelocatingTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle notification that a node being actively removed from the ring via 'removetoken'
     *
     * @param endpoint node
     * @param pieces either REMOVED_TOKEN (node is gone) or REMOVING_TOKEN (replicas need to be restored)
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateRemoving</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr>(<name><name>pieces</name>.<name>length</name></name> &gt; 0)</expr>;</assert>

        <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Received removeToken gossip about myself. Is this node rejoining after an explicit removetoken?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name>drain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>state</name> <init>= <expr><name><name>pieces</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>removeTokens</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getTokens</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>VersionedValue</name>.<name>REMOVED_TOKEN</name>.<name>equals</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>removeTokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name>extractExpireTime</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>, <argument><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>getVersion</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>VersionedValue</name>.<name>REMOVING_TOKEN</name>.<name>equals</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Tokens " + <name>removeTokens</name> + " removed manually (endpoint was " + <name>endpoint</name> + ")"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <comment type="line">// Note that the endpoint is being removed</comment>
                <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// find the endpoint coordinating this removal that we need to notify when we're done</comment>
                <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>coordinator</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>getApplicationState</name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>REMOVAL_COORDINATOR</name></name></expr></argument>)</argument_list></call>.<call><name><name>value</name>.<name>split</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>DELIMITER_STR</name></name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>UUID</name></type> <name>hostId</name> <init>= <expr><call><name><name>UUID</name>.<name>fromString</name></name><argument_list>(<argument><expr><name><name>coordinator</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// grab any data we are now responsible for and notify responsible node</comment>
                <expr_stmt><expr><call><name>restoreReplicaCount</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name><name>tokenMetadata</name>.<name>getEndpointForHostId</name></name><argument_list>(<argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then>
        <else>else <comment type="line">// now that the gossiper has told us about this nonexistent member, notify the gossiper to remove it</comment>
            <expr_stmt><expr><call><name>removeEndpoint</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>excise</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Removing tokens " + <name>tokens</name> + " for " + <name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>deleteHintsForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>removeEndpoint</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>removeBootstrapTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
        <block>{
            <for>for (<init><decl><type><name>IEndpointLifecycleSubscriber</name></type> <name>subscriber</name> <range>: <expr><name>lifecycleSubscribers</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>subscriber</name>.<name>onLeaveCluster</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if>
        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>excise</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>long</name></type> <name>expireTime</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>addExpireTimeIfFound</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>expireTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/** unlike excise we just need this endpoint gone without going through any notifications **/</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>removeEndpoint</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>protected</specifier> <name>void</name></type> <name>addExpireTimeIfFound</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>long</name></type> <name>expireTime</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>expireTime</name> != 0L</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addExpireTimeForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>expireTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>protected</specifier> <name>long</name></type> <name>extractExpireTime</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>, <param><decl><type><name>int</name></type> <name>version</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>version</name> &lt; <name><name>MessagingService</name>.<name>VERSION_12</name></name></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name><name>pieces</name>.<name>length</name></name> &gt;= 3</expr>)</condition><then>
                <return>return <expr><call><name><name>Long</name>.<name>parseLong</name></name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then>
            <else>else
                <return>return <expr>0L</expr>;</return></else></if>
        }</block></then> <else>else
        <block>{
            <if>if <condition>(<expr><call><name><name>VersionedValue</name>.<name>STATUS_LEFT</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><call><name><name>Long</name>.<name>parseLong</name></name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then>
            <else>else
                <return>return <expr><call><name><name>Long</name>.<name>parseLong</name></name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></else></if>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Calculate pending ranges according to bootsrapping and leaving nodes. Reasoning is:
     *
     * (1) When in doubt, it is better to write too much to a node than too little. That is, if
     * there are multiple nodes moving, calculate the biggest ranges a node could have. Cleaning
     * up unneeded data afterwards is better than missing writes during movement.
     * (2) When a node leaves, ranges for other nodes can only grow (a node might get additional
     * ranges, but it will not lose any of its current ranges as a result of a leave). Therefore
     * we will first remove _all_ leaving tokens for the sake of calculation and then check what
     * ranges would go where if all nodes are to leave. This way we get the biggest possible
     * ranges with regard current leave operations, covering all subsets of possible final range
     * values.
     * (3) When a node bootstraps, ranges of other nodes can only get smaller. Without doing
     * complex calculations to see if multiple bootstraps overlap, we simply base calculations
     * on the same token ring used before (reflecting situation after all leave operations have
     * completed). Bootstrapping nodes will be added and removed one by one to that metadata and
     * checked what their ranges would be. This will give us the biggest possible ranges the
     * node could have. It might be that other bootstraps make our actual final ranges smaller,
     * but it does not matter as we can clean up the data afterwards.
     *
     * NOTE: This is heavy and ineffective operation. This will be done only once when a node
     * changes state in the cluster, so it should be manageable.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>calculatePendingRanges</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>(<argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <comment type="line">// public &amp; static for testing purposes</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>calculatePendingRanges</name><parameter_list>(<param><decl><type><name>AbstractReplicationStrategy</name></type> <name>strategy</name></decl></param>, <param><decl><type><name>String</name></type> <name>table</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>tm</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>pendingRanges</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>BiMultiValMap</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>bootstrapTokens</name> <init>= <expr><call><name><name>tm</name>.<name>getBootstrapTokens</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>leavingEndpoints</name> <init>= <expr><call><name><name>tm</name>.<name>getLeavingEndpoints</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>bootstrapTokens</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>leavingEndpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>tm</name>.<name>getMovingEndpoints</name></name><argument_list>()</argument_list></call>.<call><name>isEmpty</name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>tm</name>.<name>getRelocatingRanges</name></name><argument_list>()</argument_list></call>.<call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"No bootstrapping, leaving or moving nodes, and no relocating tokens -&gt; empty pending ranges for {}"</expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name><name>tm</name>.<name>setPendingRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>pendingRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>addressRanges</name> <init>= <expr><call><name><name>strategy</name>.<name>getAddressRanges</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Copy of metadata reflecting the situation after all leave operations are finished.</comment>
        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>allLeftMetadata</name> <init>= <expr><call><name><name>tm</name>.<name>cloneAfterAllLeft</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// get all ranges that will be affected by leaving nodes</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>affectedRanges</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>leavingEndpoints</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>affectedRanges</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>addressRanges</name>.<name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <comment type="line">// for each of those ranges, find what new nodes will be responsible for the range when</comment>
        <comment type="line">// all leaving nodes are gone.</comment>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>affectedRanges</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>currentEndpoints</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>strategy</name>.<name>calculateNaturalEndpoints</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>, <argument><expr><call><name><name>tm</name>.<name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>newEndpoints</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>strategy</name>.<name>calculateNaturalEndpoints</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>, <argument><expr><name>allLeftMetadata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>pendingRanges</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><name>newEndpoints</name></expr></argument>, <argument><expr><name>currentEndpoints</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// At this stage pendingRanges has been updated according to leave operations. We can</comment>
        <comment type="line">// now continue the calculation by checking bootstrapping nodes.</comment>

        <comment type="line">// For each of the bootstrapping nodes, simply add and remove them one by one to</comment>
        <comment type="line">// allLeftMetadata and check in between what their ranges would be.</comment>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><call><name><name>bootstrapTokens</name>.<name>inverse</name></name><argument_list>()</argument_list></call>.<call><name>keySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name><name>bootstrapTokens</name>.<name>inverse</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>allLeftMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name><name>strategy</name>.<name>getAddressRanges</name></name><argument_list>(<argument><expr><name>allLeftMetadata</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>pendingRanges</name>.<name>put</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <expr_stmt><expr><call><name><name>allLeftMetadata</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// At this stage pendingRanges has been updated according to leaving and bootstrapping nodes.</comment>
        <comment type="line">// We can now finish the calculation by checking moving and relocating nodes.</comment>

        <comment type="line">// For each of the moving nodes, we do the same thing we did for bootstrapping:</comment>
        <comment type="line">// simply add and remove them one by one to allLeftMetadata and check in between what their ranges would be.</comment>
        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>moving</name> <range>: <expr><call><name><name>tm</name>.<name>getMovingEndpoints</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>endpoint</name> <init>= <expr><name><name>moving</name>.<name>right</name></name></expr></init></decl>;</decl_stmt> <comment type="line">// address of the moving node</comment>

            <comment type="line">//  moving.left is a new token of the endpoint</comment>
            <expr_stmt><expr><call><name><name>allLeftMetadata</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name><name>moving</name>.<name>left</name></name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name><name>strategy</name>.<name>getAddressRanges</name></name><argument_list>(<argument><expr><name>allLeftMetadata</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>pendingRanges</name>.<name>put</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <expr_stmt><expr><call><name><name>allLeftMetadata</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// Ranges being relocated.</comment>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></type> <name>relocating</name> <range>: <expr><call><name><name>tm</name>.<name>getRelocatingRanges</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>endpoint</name> <init>= <expr><call><name><name>relocating</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// address of the moving node</comment>
            <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>relocating</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>allLeftMetadata</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name><name>strategy</name>.<name>getAddressRanges</name></name><argument_list>(<argument><expr><name>allLeftMetadata</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>pendingRanges</name>.<name>put</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

            <expr_stmt><expr><call><name><name>allLeftMetadata</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name><name>tm</name>.<name>setPendingRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>pendingRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Pending ranges:\n" + (<call><name><name>pendingRanges</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> ? "&lt;empty&gt;" : <call><name><name>tm</name>.<name>printPendingRanges</name></name><argument_list>()</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Finds living endpoints responsible for the given ranges
     *
     * @param table the table ranges belong to
     * @param ranges the ranges to find sources for
     * @return multimap of addresses to ranges the address is responsible for
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getNewSourceRanges</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>myAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangeAddresses</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getRangeAddresses</name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sourceRanges</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IFailureDetector</name></type> <name>failureDetector</name> <init>= <expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// find alive sources for our new ranges</comment>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>possibleRanges</name> <init>= <expr><call><name><name>rangeAddresses</name>.<name>get</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>snitch</name>.<name>getSortedListByProximity</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>, <argument><expr><name>possibleRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <assert>assert <expr>(!<call><name><name>sources</name>.<name>contains</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call>)</expr>;</assert>

            <for>for (<init><decl><type><name>InetAddress</name></type> <name>source</name> <range>: <expr><name>sources</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>failureDetector</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>sourceRanges</name>.<name>put</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block></for>
        <return>return <expr><name>sourceRanges</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sends a notification to a node indicating we have finished replicating data.
     *
     * @param remote node to send notification to
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendReplicationNotification</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>remote</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// notify the remote token</comment>
        <decl_stmt><decl><type><name>MessageOut</name></type> <name>msg</name> <init>= <expr>new <call><name>MessageOut</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>REPLICATION_FINISHED</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IFailureDetector</name></type> <name>failureDetector</name> <init>= <expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Notifying " + <call><name><name>remote</name>.<name>toString</name></name><argument_list>()</argument_list></call> + " of replication completion\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <while>while <condition>(<expr><call><name><name>failureDetector</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>IAsyncResult</name></type> <name>iar</name> <init>= <expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>iar</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcTimeout</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return> <comment type="line">// done</comment>
            }</block>
            <catch>catch<parameter_list>(<param><decl><type><name>TimeoutException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <comment type="line">// try again</comment>
            }</block></catch></try>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Called when an endpoint is removed from the ring. This function checks
     * whether this node becomes responsible for new ranges as a
     * consequence and streams data if needed.
     *
     * This is rather ineffective, but it does not matter so much
     * since this is called very seldom
     *
     * @param endpoint the node that left
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>restoreReplicaCount</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>notifyEndpoint</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>fetchSources</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>rangesToFetch</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>myAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>changedRanges</name> <init>= <expr><call><name>getChangedRangesForLeaving</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>myNewRanges</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>changedRanges</name>.<name>entries</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>myNewRanges</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sourceRanges</name> <init>= <expr><call><name>getNewSourceRanges</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>myNewRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>sourceRanges</name>.<name>asMap</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>fetchSources</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rangesToFetch</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>

        <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <range>: <expr><call><name><name>rangesToFetch</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>rangesToFetch</name>.<name>get</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>source</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>IStreamCallback</name></type> <name>callback</name> <init>= <expr>new <class><super><name>IStreamCallback</name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>()</parameter_list>
                    <block>{
                        <synchronized>synchronized (<expr><name>fetchSources</name></expr>)
                        <block>{
                            <expr_stmt><expr><call><name><name>fetchSources</name>.<name>remove</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr><call><name><name>fetchSources</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                                <expr_stmt><expr><call><name>sendReplicationNotification</name><argument_list>(<argument><expr><name>notifyEndpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                        }</block></synchronized>
                    }</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Streaming from " + <name>source</name> + " failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>onSuccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// calling onSuccess to send notification</comment>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Requesting from " + <name>source</name> + " ranges " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name><name>StreamIn</name>.<name>requestRanges</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>RESTORE_REPLICA_COUNT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
    }</block></function>

    <comment type="line">// needs to be modified to accept either a table or ARS.</comment>
    <function><type><specifier>private</specifier> <name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getChangedRangesForLeaving</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// First get all ranges the leaving endpoint is responsible for</comment>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name>getRangesForEndpoint</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " ranges [" + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call> + "]"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>currentReplicaEndpoints</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Find (for each range) all nodes that store replicas for these ranges as well</comment>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>currentReplicaEndpoints</name>.<name>put</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>calculateNaturalEndpoints</name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>, <argument><expr><call><name><name>tokenMetadata</name>.<name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>temp</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>cloneAfterAllLeft</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// endpoint might or might not be 'leaving'. If it was not leaving (that is, removetoken</comment>
        <comment type="line">// command was used), it is still present in temp and must be removed.</comment>
        <if>if <condition>(<expr><call><name><name>temp</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>temp</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>changedRanges</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Go through the ranges and for each range check who will be</comment>
        <comment type="line">// storing replicas for these ranges when the leaving endpoint</comment>
        <comment type="line">// is gone. Whoever is present in newReplicaEndpoints list, but</comment>
        <comment type="line">// not in the currentReplicaEndpoints list, will be needing the</comment>
        <comment type="line">// range.</comment>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>newReplicaEndpoints</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>calculateNaturalEndpoints</name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>newReplicaEndpoints</name>.<name>removeAll</name></name><argument_list>(<argument><expr><call><name><name>currentReplicaEndpoints</name>.<name>get</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <if>if <condition>(<expr><call><name><name>newReplicaEndpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Range " + <name>range</name> + " already in all replicas"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Range " + <name>range</name> + " will be responsibility of " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>newReplicaEndpoints</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></then></if>
            <expr_stmt><expr><call><name><name>changedRanges</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>newReplicaEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>changedRanges</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onJoin</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>epState</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>ApplicationState</name></argument>, <argument><name>VersionedValue</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>epState</name>.<name>getApplicationStateMap</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name>onChange</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onAlive</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>state</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<name>isClientMode</name> &amp;&amp; <call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>isMember</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>scheduleHintDelivery</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onRemove</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onDead</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>state</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>convict</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
        <block>{
            <for>for (<init><decl><type><name>IEndpointLifecycleSubscriber</name></type> <name>subscriber</name> <range>: <expr><name>lifecycleSubscribers</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>subscriber</name>.<name>onDown</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onRestart</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>state</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// If we have restarted before the node was even marked down, we need to reset the connection pool</comment>
        <if>if <condition>(<expr><call><name><name>state</name>.<name>isAlive</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>onDead</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/** raw load value */</comment>
    <function><type><specifier>public</specifier> <name>double</name></type> <name>getLoad</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>tableName</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><name>bytes</name> += <call><name><name>cfs</name>.<name>getLiveDiskSpaceUsed</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
        }</block></for>
        <return>return <expr><name>bytes</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getLoadString</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>FileUtils</name>.<name>stringifyFileSize</name></name><argument_list>(<argument><expr><call><name>getLoad</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLoadMap</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>,<argument><name>Double</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>LoadBroadcaster</name>.<name>instance</name>.<name>getLoadInfo</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FileUtils</name>.<name>stringifyFileSize</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <comment type="line">// gossiper doesn't see its own updates, so we need to special-case the local node</comment>
        <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLoadString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>deliverHints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>host</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnknownHostException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>scheduleHintDelivery</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getLocalTokens</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name><name>SystemTable</name>.<name>getSavedTokens</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>tokens</name> != null &amp;&amp; !<call><name><name>tokens</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert> <comment type="line">// should not be called before initServer sets this</comment>
        <return>return <expr><name>tokens</name></expr>;</return>
    }</block></function>

    <comment type="block">/* These methods belong to the MBean interface */</comment>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getTokens</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getTokens</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getTokens</name><parameter_list>(<param><decl><type><name>String</name></type> <name>endpoint</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnknownHostException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name>getTokens</name><argument_list>(<argument><expr><call><name><name>InetAddress</name>.<name>getByName</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getTokens</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>strTokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Token</name></type> <name>tok</name> <range>: <expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>getTokens</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>strTokens</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>tok</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>strTokens</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getReleaseVersion</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>FBUtilities</name>.<name>getReleaseVersionString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getSchemaVersion</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLeavingNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getLeavingEndpoints</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getMovingNodes</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>node</name> <range>: <expr><call><name><name>tokenMetadata</name>.<name>getMovingEndpoints</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>endpoints</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>node</name>.<name>right</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>endpoints</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getJoiningNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getBootstrapTokens</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLiveNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getUnreachableNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getUnreachableMembers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getAllDataFileLocations</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>locations</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getAllDataFileLocations</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>locations</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>locations</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name><name>FileUtils</name>.<name>getCanonicalPath</name></name><argument_list>(<argument><expr><name><name>locations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>locations</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getCommitLogLocation</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>FileUtils</name>.<name>getCanonicalPath</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getCommitLogLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getSavedCachesLocation</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>FileUtils</name>.<name>getCanonicalPath</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getSavedCachesLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>stringify</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>stringEndpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>ep</name> <range>: <expr><name>endpoints</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>stringEndpoints</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>ep</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>stringEndpoints</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCurrentGenerationNumber</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getCurrentGenerationNumber</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableCleanup</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>tableName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_KS</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Cleanup of the system table is neither necessary nor wise"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>CounterId</name>.<name>OneShotRenewer</name></name></type> <name>counterIdRenewer</name> <init>= <expr>new <call><name><name>CounterId</name>.<name>OneShotRenewer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>forceCleanup</name></name><argument_list>(<argument><expr><name>counterIdRenewer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>scrub</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>scrub</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>upgradeSSTables</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>sstablesRewrite</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableCompaction</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>forceMajorCompaction</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Takes the snapshot for the given tables. A snapshot name must be specified.
     *
     * @param tag the tag given to the snapshot; may not be null or empty
     * @param tableNames the name of the tables to snapshot; empty means "all."
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>takeSnapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>tableNames</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>tag</name> == null || <call><name><name>tag</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You must supply a snapshot name."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>tables</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>tableNames</name>.<name>length</name></name> == 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>tables</name> = <call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>t</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>tableNames</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tableNames</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>t</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <expr_stmt><expr><name>tables</name> = <name>t</name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="line">// Do a check to see if this snapshot exists before we actually snapshot</comment>
        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><name>tables</name></expr></range></decl></init>)
            <if>if <condition>(<expr><call><name><name>table</name>.<name>snapshotExists</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Snapshot " + <name>tag</name> + " already exists."</expr></argument>)</argument_list></call></expr>;</throw></then></if></for>


        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><name>tables</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>table</name>.<name>snapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Takes the snapshot of a specific column family. A snapshot name must be specified.
     *
     * @param tableName the keyspace which holds the specified column family
     * @param columnFamilyName the column family to snapshot
     * @param tag the tag given to the snapshot; may not be null or empty
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>takeColumnFamilySnapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamilyName</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>tableName</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You must supply a table name"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><name>columnFamilyName</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You mus supply a column family name"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><name>tag</name> == null || <call><name><name>tag</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You must supply a snapshot name."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>table</name>.<name>snapshotExists</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Snapshot " + <name>tag</name> + " already exists."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <expr_stmt><expr><call><name><name>table</name>.<name>snapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>columnFamilyName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Table</name></type> <name>getValidTable</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Table " + <name>tableName</name> + " does not exist"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Remove the snapshot with the given name from the given tables.
     * If no tag is specified we will remove all snapshots.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>clearSnapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>tableNames</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if<condition>(<expr><name>tag</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>tag</name> = ""</expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>tables</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>tableNames</name>.<name>length</name></name> == 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>tables</name> = <call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>tempTables</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>tableNames</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for(<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tableNames</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>tempTables</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <expr_stmt><expr><name>tables</name> = <name>tempTables</name></expr>;</expr_stmt>
        }</block></else></if>

        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><name>tables</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>table</name>.<name>clearSnapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Cleared out snapshot directories"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>getValidColumnFamilies</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>cfNames</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>cfNames</name>.<name>length</name></name> == 0</expr>)</condition><then>
            <comment type="line">// all stores are interesting</comment>
            <return>return <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <comment type="line">// filter out interesting stores</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>valid</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>cfName</name> <range>: <expr><name>cfNames</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <init>= <expr><call><name><name>table</name>.<name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cfStore</name> == null</expr>)</condition><then>
            <block>{
                <comment type="line">// this means there was a cf passed in that is not recognized in the keyspace. report it and continue.</comment>
                <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Invalid column family specified: %s. Proceeding with others."</expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>valid</name>.<name>add</name></name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>valid</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Flush all memtables for a table and column families.
     * @param tableName
     * @param columnFamilies
     * @throws IOException
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableFlush</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list>
                <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Forcing flush on keyspace " + <name>tableName</name> + ", CF " + <call><name><name>cfStore</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>forceBlockingFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sends JMX notification to subscribers.
     *
     * @param type Message type
     * @param message Message itself
     * @param userObject Arbitrary object to attach to notification
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>sendNotification</name><parameter_list>(<param><decl><type><name>String</name></type> <name>type</name></decl></param>, <param><decl><type><name>String</name></type> <name>message</name></decl></param>, <param><decl><type><name>Object</name></type> <name>userObject</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Notification</name></type> <name>jmxNotification</name> <init>= <expr>new <call><name>Notification</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>jmxObjectName</name></expr></argument>, <argument><expr><call><name><name>notificationSerialNumber</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>jmxNotification</name>.<name>setUserData</name></name><argument_list>(<argument><expr><name>userObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr><name>jmxNotification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>forceRepairAsync</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isLocal</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>primaryRange</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>Table</name>.<name>SYSTEM_KS</name>.<name>equals</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call> || <call><name><name>Tracing</name>.<name>TRACE_KS</name>.<name>equals</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call> || <call><name><name>Auth</name>.<name>AUTH_KS</name>.<name>equals</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>0</expr>;</return></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>cmd</name> <init>= <expr><call><name><name>nextRepairCommand</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><name>primaryRange</name> ? <call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> : <call><name>getLocalRanges</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr>new <call><name>Thread</name><argument_list>(<argument><expr><call><name>createRepairTask</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>isLocal</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<call><name>start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>cmd</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Trigger proactive repair for a table and column families.
     * @param tableName
     * @param columnFamilies
     * @throws IOException
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableRepair</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><name>boolean</name></type>  <name>isLocal</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>forceTableRepairRange</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><call><name>getLocalRanges</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>isLocal</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableRepairPrimaryRange</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><name>boolean</name></type>  <name>isLocal</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>forceTableRepairRange</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><call><name>getLocalPrimaryRanges</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>isLocal</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableRepairRange</name><parameter_list>(<param><decl><type><name>String</name></type> <name>beginToken</name></decl></param>, <param><decl><type><name>String</name></type> <name>endToken</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><name>boolean</name></type>  <name>isLocal</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>Token</name></type> <name>parsedBeginToken</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>beginToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>parsedEndToken</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>endToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"starting user-requested repair of range ({}, {}] for keyspace {} and column families {}"</expr></argument>,
                    <argument><expr><name>parsedBeginToken</name></expr></argument>, <argument><expr><name>parsedEndToken</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>forceTableRepairRange</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>parsedBeginToken</name></expr></argument>, <argument><expr><name>parsedEndToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>isLocal</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableRepairRange</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><name>boolean</name></type>  <name>isLocal</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>Table</name>.<name>SYSTEM_KS</name>.<name>equals</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call> || <call><name><name>Tracing</name>.<name>TRACE_KS</name>.<name>equals</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call> || <call><name><name>Auth</name>.<name>AUTH_KS</name>.<name>equals</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>
        <expr_stmt><expr><call><name>createRepairTask</name><argument_list>(<argument><expr><call><name><name>nextRepairCommand</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>isLocal</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call>.<call><name>run</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>FutureTask</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>createRepairTask</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>int</name></type> <name>cmd</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isLocal</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>FutureTask</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name></type> <name>task</name> <init>= <expr>new <call><name><name>FutureTask</name><argument_list>&lt;<argument><name>Object</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>new <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>
            <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>message</name> <init>= <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Starting repair command #%d, repairing %d ranges for keyspace %s"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>STARTED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name> <init>= <expr><call><name>forceTableRepair</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>isLocal</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>future</name> == null</expr>)</condition><then>
                        <continue>continue;</continue></then></if>
                    <expr_stmt><expr><call><name><name>futures</name>.<name>add</name></name><argument_list>(<argument><expr><name>future</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// wait for a session to be done with its differencing before starting the next one</comment>
                    <try>try
                    <block>{
                        <expr_stmt><expr><call><name><name>future</name>.<name>session</name>.<name>differencingDone</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                    <block>{
                        <expr_stmt><expr><name>message</name> = "Interrupted while waiting for the differencing of repair session " + <name><name>future</name>.<name>session</name></name> + " to be done. Repair may be imprecise."</expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_FAILED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></catch></try>
                }</block></for>
                <for>for (<init><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name> <range>: <expr><name>futures</name></expr></range></decl></init>)
                <block>{
                    <try>try
                    <block>{
                        <expr_stmt><expr><call><name><name>future</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>message</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair session %s for range %s finished"</expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getRange</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_SUCCESS</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>e</name></decl></param>)</parameter_list>
                    <block>{
                        <expr_stmt><expr><name>message</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair session %s for range %s failed with error %s"</expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getRange</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getCause</name></name><argument_list>()</argument_list></call>.<call><name>getMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_FAILED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></catch>
                    <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
                    <block>{
                        <expr_stmt><expr><name>message</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair session %s for range %s failed with error %s"</expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getRange</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_FAILED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></catch></try>
                }</block></for>
                <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair command #%d finished"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>FINISHED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></class></expr></argument>, <argument><expr>null</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>task</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>forceTableRepair</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><name>boolean</name></type>  <name>isLocal</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>names</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>names</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>cfStore</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>names</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"No column family to repair for keyspace " + <name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>null</expr>;</return>
        }</block></then></if>

        <return>return <expr><call><name><name>AntiEntropyService</name>.<name>instance</name>.<name>submitRepairSession</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>isLocal</name></expr></argument>, <argument><expr><call><name><name>names</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>String</name><index>[<expr><call><name><name>names</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTerminateAllRepairSessions</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>AntiEntropyService</name>.<name>instance</name>.<name>terminateSessions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/* End of MBean interface methods */</comment>

    <comment type="block" format="javadoc">/**
     * This method returns the predecessor of the endpoint ep on the identifier
     * space.
     */</comment>
    <function><type><name>InetAddress</name></type> <name>getPredecessor</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>token</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getPredecessor</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * This method returns the successor of the endpoint ep on the identifier
     * space.
     */</comment>
    <function><type><specifier>public</specifier> <name>InetAddress</name></type> <name>getSuccessor</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>token</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getSuccessor</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the primary ranges for the specified endpoint.
     * @param ep endpoint we are interested in.
     * @return collection of ranges for the specified endpoint.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getPrimaryRangesForEndpoint</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>tokenMetadata</name>.<name>getPrimaryRangesFor</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getTokens</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the primary range for the specified endpoint.
     * @param ep endpoint we are interested in.
     * @return range for the specified endpoint.
     */</comment>
    <function><type><annotation>@<name>Deprecated</name></annotation>
    <specifier>public</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getPrimaryRangeForEndpoint</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>tokenMetadata</name>.<name>getPrimaryRangeFor</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get all ranges an endpoint is responsible for (by table)
     * @param ep endpoint we are interested in.
     * @return ranges for the specified endpoint.
     */</comment>
    <function><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangesForEndpoint</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getAddressRanges</name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get all ranges that span the ring given a set
     * of tokens. All ranges are in sorted order of
     * ranges.
     * @return ranges in sorted order
    */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getAllRanges</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"computing ranges for " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>sortedTokens</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>sortedTokens</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>Collections</name>.<name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>sortedTokens</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <block>{
            <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name> - 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>size</name> - 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>ranges</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param table keyspace name also known as table
     * @param cf Column family name
     * @param key key for which we need to find the endpoint
     * @return the endpoint responsible for this key
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>String</name></type> <name>cf</name></decl></param>, <param><decl><type><name>String</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>CFMetaData</name></type> <name>cfMetaData</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTableDefinition</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>cfMetaData</name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getToken</name><argument_list>(<argument><expr><call><name><name>cfMetaData</name>.<name>getKeyValidator</name></name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getToken</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param table keyspace name also known as table
     * @param pos position for which we need to find the endpoint
     * @return the endpoint responsible for this token
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>RingPosition</name></type> <name>pos</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This method attempts to return N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param table keyspace name also known as table
     * @param key key for which we need to find the endpoint
     * @return the endpoint responsible for this key
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getLiveNaturalEndpoints</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getLiveNaturalEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>decorateKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getLiveNaturalEndpoints</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>, <param><decl><type><name>RingPosition</name></type> <name>pos</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name><name>table</name>.<name>getReplicationStrategy</name></name><argument_list>()</argument_list></call>.<call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>liveEps</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>endpoints</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>endpoints</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>FailureDetector</name>.<name>instance</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>liveEps</name>.<name>add</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <return>return <expr><name>liveEps</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLog4jLevel</name><parameter_list>(<param><decl><type><name>String</name></type> <name>classQualifier</name></decl></param>, <param><decl><type><name>String</name></type> <name>rawLevel</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Level</name></type> <name>level</name> <init>= <expr><call><name><name>Level</name>.<name>toLevel</name></name><argument_list>(<argument><expr><name>rawLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>org</name>.<name>apache</name>.<name>log4j</name>.<name>Logger</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name>classQualifier</name></expr></argument>)</argument_list></call>.<call><name>setLevel</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"set log level to " + <name>level</name> + " for classes under '" + <name>classQualifier</name> + "' (if the level doesn't look like '" + <name>rawLevel</name> + "' then log4j couldn't parse '" + <name>rawLevel</name> + "')"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return list of Token ranges (_not_ keys!) together with estimated key count,
     *      breaking up the data this node is responsible for into pieces of roughly keysPerSplit
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getSplits</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>, <param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name>int</name></type> <name>keysPerSplit</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Table</name></type> <name>t</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <init>= <expr><call><name><name>t</name>.<name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr><call><name>keySamples</name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>totalRowCountEstimate</name> <init>= <expr>(<call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> + 1) * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// splitCount should be much smaller than number of key samples, to avoid huge sampling error</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>minSamplesPerSplit</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxSplitCount</name> <init>= <expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> / <name>minSamplesPerSplit</name> + 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>splitCount</name> <init>= <expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>maxSplitCount</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>totalRowCountEstimate</name> / <name>keysPerSplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name>keysToTokens</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>getSplits</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>splitCount</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getSplits</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></param>, <param><decl><type><name>int</name></type> <name>splitCount</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>step</name> <init>= <expr><call>(<name>double</name>) <argument_list>(<argument><expr><call><name><name>tokens</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call> / <name>splitCount</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>prevIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>prevToken</name> <init>= <expr><call><name><name>tokens</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>splits</name> <init>= <expr><call><name><name>Lists</name>.<name>newArrayListWithExpectedSize</name></name><argument_list>(<argument><expr><name>splitCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>splitCount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>(<name>int</name>) <call><name><name>Math</name>.<name>round</name></name><argument_list>(<argument><expr><name>i</name> * <name>step</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>tokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>rowCountEstimate</name> <init>= <expr>(<name>index</name> - <name>prevIndex</name>) * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>splits</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>Pair</name>.<name>create</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>prevToken</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rowCountEstimate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>prevIndex</name> = <name>index</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prevToken</name> = <name>token</name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>splits</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>keysToTokens</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name><name>Lists</name>.<name>newArrayListWithExpectedSize</name></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> + 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>DecoratedKey</name></type> <name>key</name> <range>: <expr><name>keys</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>key</name>.<name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tokens</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keySamples</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfses</name></decl></param>, <param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>cfses</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>Iterables</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><call><name><name>cfs</name>.<name>keySamples</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>sortSampledKeys</name></name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>keys</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/** return a token to which if a node bootstraps it will get about 1/2 of this node's range */</comment>
    <function><type><specifier>public</specifier> <name>Token</name></type> <name>getBootstrapToken</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr><call><name>keySamples</name><argument_list>(<argument><expr><call><name><name>ColumnFamilyStore</name>.<name>allUserDefined</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Token</name></type> <name>token</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; 3</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>token</name> = <call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>midpoint</name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Used midpoint to assign token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name>token</name> = <call><name><name>keys</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> / 2</expr></argument>)</argument_list></call>.<name>token</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Used key sample of size " + <call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> + " to assign token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call> != null &amp;&amp; <call><name><name>tokenMetadata</name>.<name>isMember</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Chose token " + <name>token</name> + " which is already in use by " + <call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call> + " -- specify one manually with initial_token"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <comment type="line">// Hack to prevent giving nodes tokens with DELIMITER_STR in them (which is fine in a row key/token)</comment>
        <if>if <condition>(<expr><name>token</name> instanceof <name>StringToken</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>token</name> = new <call><name>StringToken</name><argument_list>(<argument><expr>((<name>String</name>)<name><name>token</name>.<name>token</name></name>).<call><name>replaceAll</name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>DELIMITER_STR</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>getNormalAndBootstrappingTokenToEndpointMap</name></name><argument_list>()</argument_list></call>.<call><name>containsKey</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Unable to compute unique token for new node -- specify one manually with initial_token"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        }</block></then></if>
        <return>return <expr><name>token</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Broadcast leaving status and update local tokenMetadata accordingly
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>startLeaving</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>leaving</name></name><argument_list>(<argument><expr><call><name>getLocalTokens</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>decommission</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>tokenMetadata</name>.<name>isMember</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"local node is not a member of the token ring yet"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>cloneAfterAllLeft</name></name><argument_list>()</argument_list></call>.<call><name>sortedTokens</name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &lt; 2</expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"no other normal nodes in the ring; decommission would be pointless"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>getPendingRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"data is currently moving to this node; unable to leave the ring"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"DECOMMISSIONING"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>startLeaving</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>LEAVING</name></name></expr></argument>, <argument><expr>"sleeping " + <name>RING_DELAY</name> + " ms for pending range setup"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Runnable</name></type> <name>finishLeaving</name> <init>= <expr>new <class><super><name>Runnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
            <block>{
                <expr_stmt><expr><call><name>stopRPCServer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>StageManager</name>.<name>shutdownNow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DECOMMISSIONED</name></name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// let op be responsible for killing the process</comment>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>unbootstrap</name><argument_list>(<argument><expr><name>finishLeaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>leaveRing</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>NEEDS_BOOTSTRAP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>left</name></name><argument_list>(<argument><expr><call><name>getLocalTokens</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><call><name><name>Gossiper</name>.<name>computeExpireTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>delay</name> <init>= <expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>, <argument><expr><name><name>Gossiper</name>.<name>intervalInMillis</name></name> * 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Announcing that I have left the ring for " + <name>delay</name> + "ms"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>unbootstrap</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Runnable</name></type> <name>onFinish</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToStream</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangesMM</name> <init>= <expr><call><name>getChangedRangesForLeaving</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Ranges needing transfer are [" + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><call><name><name>rangesMM</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call> + "]"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><call><name><name>rangesToStream</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>rangesMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>LEAVING</name></name></expr></argument>, <argument><expr>"streaming data to other nodes"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>latch</name> <init>= <expr><call><name>streamRanges</name><argument_list>(<argument><expr><name>rangesToStream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>hintsLatch</name> <init>= <expr><call><name>streamHints</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// wait for the transfer runnables to signal the latch.</comment>
        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"waiting for stream aks."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>latch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>hintsLatch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"stream acks all received."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leaveRing</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>onFinish</name>.<name>run</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>CountDownLatch</name></type> <name>streamHints</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>listEndpointsPendingHints</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>

        <comment type="line">// gather all live nodes in the cluster that aren't also leaving</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>candidates</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call>.<call><name>cloneAfterAllLeft</name><argument_list>()</argument_list></call>.<call><name>getAllEndpoints</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>candidates</name>.<name>remove</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>candidates</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr/>)
        <block>{
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>address</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>FailureDetector</name>.<name>instance</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>address</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>iter</name>.<name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>candidates</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Unable to stream hints since no live endpoints seen"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// stream to the closest peer as chosen by the snitch</comment>
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>sortByProximity</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>hintsDestinationHost</name> <init>= <expr><call><name><name>candidates</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// stream all hints -- range list will be a singleton of "the entire ring"</comment>
            <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>getMinimumToken</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>latch</name> <init>= <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>StreamOut</name>.<name>transferRanges</name></name><argument_list>(<argument><expr><name>hintsDestinationHost</name></expr></argument>,
                                     <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_KS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_KS</name></name></expr></argument>)</argument_list></call>.<call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>HINTS_CF</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>ranges</name></expr></argument>,
                                     <argument><expr>new <call><name>CountingDownStreamCallback</name><argument_list>(<argument><expr><name>latch</name></expr></argument>, <argument><expr><name>hintsDestinationHost</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>OperationType</name>.<name>UNBOOTSTRAP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>latch</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>move</name><parameter_list>(<param><decl><type><name>String</name></type> <name>newToken</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <try>try
        <block>{
            <expr_stmt><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>validate</name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <expr_stmt><expr><call><name>move</name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * move the node to new token or find a new token to boot to according to load
     *
     * @param newToken new token to boot to, or if null, find balanced token to boot to
     *
     * @throws IOException on any I/O operation error
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>move</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>newToken</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>newToken</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Can't move to the undefined (null) token."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"target token " + <name>newToken</name> + " is already owned by another node."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// address of the current node</comment>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>localAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// This doesn't make any sense in a vnodes environment.</comment>
        <if>if <condition>(<expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>getTokens</name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr>"Invalid request to move(Token); This node has more than one token and cannot be moved thusly."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"This node has more than one token and cannot be moved thusly."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tablesToProcess</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// checking if data is moving to this node</comment>
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tablesToProcess</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>getPendingRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>localAddress</name></expr></argument>)</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"data is currently moving to this node; unable to leave the ring"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        }</block></for>

        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>moving</name></name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>MOVING</name></name></expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Moving %s from %s to %s."</expr></argument>, <argument><expr><name>localAddress</name></expr></argument>, <argument><expr><call><name>getLocalTokens</name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>MOVING</name></name></expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Sleeping %s ms before start streaming/fetching ranges"</expr></argument>, <argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Sleep interrupted " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <decl_stmt><decl><type><name>RangeRelocator</name></type> <name>relocator</name> <init>= <expr>new <call><name>RangeRelocator</name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tablesToProcess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>relocator</name>.<name>streamsNeeded</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>MOVING</name></name></expr></argument>, <argument><expr>"fetching new ranges and streaming old ranges"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>relocator</name>.<name>logStreamsMap</name></name><argument_list>(<argument><expr>"[Move-&gt;STREAMING]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>streamLatch</name> <init>= <expr><call><name><name>relocator</name>.<name>streams</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>relocator</name>.<name>logRequestsMap</name></name><argument_list>(<argument><expr>"[Move-&gt;FETCHING]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>fetchLatch</name> <init>= <expr><call><name><name>relocator</name>.<name>requests</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>streamLatch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>fetchLatch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Interrupted latch while waiting for stream/fetch ranges to finish: " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then>
        <else>else
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>MOVING</name></name></expr></argument>, <argument><expr>"No ranges to fetch/stream"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <expr_stmt><expr><call><name>setTokens</name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// setting new token as we have everything settled</comment>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Successfully moved to new token {}"</expr></argument>, <argument><expr><call><name>getLocalTokens</name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <class><specifier>private</specifier> class <name>RangeRelocator</name>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToFetch</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToStreamByTable</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>RangeRelocator</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tables</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>calculateToFromStreams</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>calculateToFromStreams</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>newTokens</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tables</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>localAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>tokenMetaCloneAllSettled</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>cloneAfterAllSettled</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// clone to avoid concurrent modification in calculateNaturalEndpoints</comment>
            <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>tokenMetaClone</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tables</name></expr></range></decl></init>)
            <block>{
                <for>for (<init><decl><type><name>Token</name></type> <name>newToken</name> <range>: <expr><name>newTokens</name></expr></range></decl></init>)
                <block>{
                    <comment type="line">// replication strategy of the current keyspace (aka table)</comment>
                    <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>strategy</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// getting collection of the currently used ranges by this keyspace</comment>
                    <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>currentRanges</name> <init>= <expr><call><name>getRangesForEndpoint</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <comment type="line">// collection of ranges which this node will serve after move to the new token</comment>
                    <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>updatedRanges</name> <init>= <expr><call><name><name>strategy</name>.<name>getPendingAddressRanges</name></name><argument_list>(<argument><expr><name>tokenMetadata</name></expr></argument>, <argument><expr><name>newToken</name></expr></argument>, <argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// ring ranges and endpoints associated with them</comment>
                    <comment type="line">// this used to determine what nodes should we ping about range data</comment>
                    <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangeAddresses</name> <init>= <expr><call><name><name>strategy</name>.<name>getRangeAddresses</name></name><argument_list>(<argument><expr><name>tokenMetaClone</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// calculated parts of the ranges to request/stream from/to nodes in the ring</comment>
                    <decl_stmt><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesPerTable</name> <init>= <expr><call><name>calculateStreamAndFetchRanges</name><argument_list>(<argument><expr><name>currentRanges</name></expr></argument>, <argument><expr><name>updatedRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="block" format="javadoc">/**
                     * In this loop we are going through all ranges "to fetch" and determining
                     * nodes in the ring responsible for data we are interested in
                     */</comment>
                    <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangesToFetchWithPreferredEndpoints</name> <init>= <expr><call><name><name>ArrayListMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>toFetch</name> <range>: <expr><name><name>rangesPerTable</name>.<name>right</name></name></expr></range></decl></init>)
                    <block>{
                        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name><name>rangeAddresses</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                        <block>{
                            <if>if <condition>(<expr><call><name><name>range</name>.<name>contains</name></name><argument_list>(<argument><expr><name>toFetch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <block>{
                                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name><name>snitch</name>.<name>getSortedListByProximity</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>, <argument><expr><call><name><name>rangeAddresses</name>.<name>get</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <comment type="line">// storing range and preferred endpoint set</comment>
                                <expr_stmt><expr><call><name><name>rangesToFetchWithPreferredEndpoints</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>toFetch</name></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></for>
                    }</block></for>

                    <comment type="line">// calculating endpoints to stream current ranges to if needed</comment>
                    <comment type="line">// in some situations node will handle current ranges as part of the new ranges</comment>
                    <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangeWithEndpoints</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>toStream</name> <range>: <expr><name><name>rangesPerTable</name>.<name>left</name></name></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>currentEndpoints</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>strategy</name>.<name>calculateNaturalEndpoints</name></name><argument_list>(<argument><expr><name><name>toStream</name>.<name>right</name></name></expr></argument>, <argument><expr><name>tokenMetaClone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>newEndpoints</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>strategy</name>.<name>calculateNaturalEndpoints</name></name><argument_list>(<argument><expr><name><name>toStream</name>.<name>right</name></name></expr></argument>, <argument><expr><name>tokenMetaCloneAllSettled</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Range:" + <name>toStream</name> + "Current endpoints: " + <name>currentEndpoints</name> + " New endpoints: " + <name>newEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>rangeWithEndpoints</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>toStream</name></expr></argument>, <argument><expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><name>newEndpoints</name></expr></argument>, <argument><expr><name>currentEndpoints</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>

                    <comment type="line">// associating table with range-to-endpoints map</comment>
                    <expr_stmt><expr><call><name><name>rangesToStreamByTable</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>rangeWithEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>workMap</name> <init>= <expr><call><name><name>RangeStreamer</name>.<name>getWorkMap</name></name><argument_list>(<argument><expr><name>rangesToFetchWithPreferredEndpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>rangesToFetch</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>workMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Table {}: work map {}."</expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>workMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></for>
            }</block></for>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>logStreamsMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"{} Work map: {}"</expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>rangesToStreamByTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>private</specifier> <name>void</name></type> <name>logRequestsMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>prefix</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"{} Work map: {}"</expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>rangesToFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>private</specifier> <name>boolean</name></type> <name>streamsNeeded</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr>!<call><name><name>rangesToStreamByTable</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> || !<call><name><name>rangesToFetch</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name>CountDownLatch</name></type> <name>streams</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name>streamRanges</name><argument_list>(<argument><expr><name>rangesToStreamByTable</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name>CountDownLatch</name></type> <name>requests</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name>requestRanges</name><argument_list>(<argument><expr><name>rangesToFetch</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>relocate</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>srcTokens</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>srcTokens</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <for>for (<init><decl><type><name>String</name></type> <name>srcT</name> <range>: <expr><name>srcTokens</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>validate</name><argument_list>(<argument><expr><name>srcT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>srcT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <expr_stmt><expr><call><name>relocateTokens</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>relocateTokens</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>srcTokens</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name>srcTokens</name> != null</expr>;</assert>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>localAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>localTokens</name> <init>= <expr><call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>getTokens</name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>srcTokens</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>it</name> <init>= <expr><call><name><name>tokens</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>it</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>Token</name></type> <name>srcT</name> <init>= <expr><call><name><name>it</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>localTokens</name>.<name>contains</name></name><argument_list>(<argument><expr><name>srcT</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>it</name>.<name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"cannot move {}; source and destination match"</expr></argument>, <argument><expr><name>srcT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>

        <if>if <condition>(<expr><call><name><name>tokens</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; 1</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"no valid token arguments specified; nothing to relocate"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>relocating</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>RELOCATING</name></name></expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"relocating %s to %s"</expr></argument>, <argument><expr><name>tokens</name></expr></argument>, <argument><expr><call><name><name>localAddress</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tables</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>RELOCATING</name></name></expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Sleeping %s ms before start streaming/fetching ranges"</expr></argument>, <argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Sleep interrupted " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <decl_stmt><decl><type><name>RangeRelocator</name></type> <name>relocator</name> <init>= <expr>new <call><name>RangeRelocator</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>relocator</name>.<name>streamsNeeded</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>RELOCATING</name></name></expr></argument>, <argument><expr>"fetching new ranges and streaming old ranges"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>relocator</name>.<name>logStreamsMap</name></name><argument_list>(<argument><expr>"[Relocate-&gt;STREAMING]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>streamLatch</name> <init>= <expr><call><name><name>relocator</name>.<name>streams</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>relocator</name>.<name>logRequestsMap</name></name><argument_list>(<argument><expr>"[Relocate-&gt;FETCHING]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>fetchLatch</name> <init>= <expr><call><name><name>relocator</name>.<name>requests</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>streamLatch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>fetchLatch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Interrupted latch while waiting for stream/fetch ranges to finish: " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then>
        <else>else
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>RELOCATING</name></name></expr></argument>, <argument><expr>"no new ranges to stream/fetch"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>currentTokens</name> <init>= <expr><call><name><name>SystemTable</name>.<name>updateLocalTokens</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>Token</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>updateNormalTokens</name></name><argument_list>(<argument><expr><name>currentTokens</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>TOKENS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>tokens</name></name><argument_list>(<argument><expr><name>currentTokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>normal</name></name><argument_list>(<argument><expr><name>currentTokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>NORMAL</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the status of a token removal.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getRemovalStatus</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>removingNode</name> == null</expr>)</condition><then> <block>{
            <return>return <expr>"No token removals in process."</expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Removing token (%s). Waiting for replication confirmation from [%s]."</expr></argument>,
                             <argument><expr><call><name><name>tokenMetadata</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>removingNode</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>replicatingNodes</name></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Force a remove operation to complete. This may be necessary if a remove operation
     * blocks forever due to node/stream failure. removeToken() must be called
     * first, this is a last resort measure.  No further attempt will be made to restore replicas.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceRemoveCompletion</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call>  || !<call><name><name>tokenMetadata</name>.<name>getLeavingEndpoints</name></name><argument_list>()</argument_list></call>.<call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Removal not confirmed for for " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>replicatingNodes</name></name></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><call><name><name>tokenMetadata</name>.<name>getLeavingEndpoints</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>UUID</name></type> <name>hostId</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getHostId</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>advertiseTokenRemoved</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>getTokens</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>removingNode</name> = null</expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"No tokens to force removal on, call 'removetoken' first"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Remove a node that has died, attempting to restore the replica count.
     * If the node is alive, decommission should be attempted.  If decommission
     * fails, then removeToken should be called.  If we fail while trying to
     * restore the replica count, finally forceRemoveCompleteion should be
     * called to forcibly remove the node without regard to replica count.
     *
     * @param hostIdString token for the node
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>removeNode</name><parameter_list>(<param><decl><type><name>String</name></type> <name>hostIdString</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>myAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>UUID</name></type> <name>localHostId</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getHostId</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>UUID</name></type> <name>hostId</name> <init>= <expr><call><name><name>UUID</name>.<name>fromString</name></name><argument_list>(<argument><expr><name>hostIdString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>endpoint</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getEndpointForHostId</name></name><argument_list>(<argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>endpoint</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Host ID not found."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getTokens</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr>)</condition><then>
             <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Cannot remove self"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " is alive and owns this ID. Use decommission command to remove it from the ring"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// A leaving endpoint that is dead is already being removed.</comment>
        <if>if <condition>(<expr><call><name><name>tokenMetadata</name>.<name>isLeaving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " is already being removed, continuing removal anyway"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"This node is already processing a removal. Wait for it to complete, or use 'removetoken force' if this has failed."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// Find the endpoints that are going to become responsible for data</comment>
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <comment type="line">// if the replication factor is 1 the data is lost so we shouldn't wait for confirmation</comment>
            <if>if <condition>(<expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getReplicationFactor</name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <comment type="line">// get all ranges that change ownership (that is, a node needs</comment>
            <comment type="line">// to take responsibility for new range)</comment>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>changedRanges</name> <init>= <expr><call><name>getChangedRangesForLeaving</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IFailureDetector</name></type> <name>failureDetector</name> <init>= <expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>ep</name> <range>: <expr><call><name><name>changedRanges</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>failureDetector</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>add</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Endpoint " + <name>ep</name> + " is down and will not receive data for re-replication of " + <name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></for>
        }</block></for>
        <expr_stmt><expr><name>removingNode</name> = <name>endpoint</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>tokenMetadata</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculatePendingRanges</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// the gossiper will handle spoofing this node's state to REMOVING_TOKEN for us</comment>
        <comment type="line">// we add our own token so other nodes to let us know when they're done</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>advertiseRemoving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>hostId</name></expr></argument>, <argument><expr><name>localHostId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// kick off streaming commands</comment>
        <expr_stmt><expr><call><name>restoreReplicaCount</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// wait for ReplicationFinishedVerbHandler to signal we're done</comment>
        <while>while <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></while>

        <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// gossiper will indicate the token has left</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>advertiseTokenRemoved</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>removingNode</name> = null</expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>confirmReplication</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>node</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// replicatingNodes can be empty in the case where this node used to be a removal coordinator,</comment>
        <comment type="line">// but restarted before all 'replication finished' messages arrived. In that case, we'll</comment>
        <comment type="line">// still go ahead and acknowledge it.</comment>
        <if>if <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>remove</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Received unexpected REPLICATION_FINISHED message from " + <name>node</name>
                         + ". Was this node recently a removal coordinator?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isClientMode</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>isClientMode</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>requestGC</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name>hasUnreclaimedSpace</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"requesting GC to free disk space"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>gc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hasUnreclaimedSpace</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>ColumnFamilyStore</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>cfs</name>.<name>hasUnreclaimedSpace</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getOperationMode</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>operationMode</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getDrainProgress</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Drained %s/%s ColumnFamilies"</expr></argument>, <argument><expr><name>remainingCFs</name></expr></argument>, <argument><expr><name>totalCFs</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Shuts node off to writes, empties memtables and the commit log.
     * There are two differences between drain and the normal shutdown hook:
     * - Drain waits for in-progress streaming to complete
     * - Drain flushes *all* columnfamilies (shutdown hook only flushes non-durable CFs)
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>drain</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>ExecutorService</name></type> <name>mutationStage</name> <init>= <expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>mutationStage</name>.<name>isTerminated</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Cannot drain node (did it already happen?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"starting drain process"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>stopRPCServer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>optionalTasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"shutting down MessageService"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"waiting for streaming"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>waitForStreaming</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"clearing mutation stage"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mutationStage</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mutationStage</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>3600</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>SECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>instance</name>.<name>verifyNoHintsInProgress</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"flushing column families"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// count CFs first, since forceFlush could block for the flushWriter to get a queue slot empty</comment>
        <expr_stmt><expr><name>totalCFs</name> = 0</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><call><name><name>Table</name>.<name>nonSystem</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><name>totalCFs</name> += <call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><name>remainingCFs</name> = <name>totalCFs</name></expr>;</expr_stmt>
        <comment type="line">// flush</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>flushes</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><call><name><name>Table</name>.<name>nonSystem</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>flushes</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>cfs</name>.<name>forceFlush</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></for>
        <comment type="line">// wait for the flushes.</comment>
        <comment type="line">// TODO this is a godawful way to track progress, since they flush in parallel.  a long one could</comment>
        <comment type="line">// thus make several short ones "instant" if we wait for them later.</comment>
        <for>for (<init><decl><type><name>Future</name></type> <name>f</name> <range>: <expr><name>flushes</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>waitOnFuture</name></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remainingCFs</name>--</expr>;</expr_stmt>
        }</block></for>
        <comment type="line">// flush the system ones after all the rest are done, just in case flushing modifies any system state</comment>
        <comment type="line">// like CASSANDRA-5151. don't bother with progress tracking since system data is tiny.</comment>
        <expr_stmt><expr><call><name><name>flushes</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><call><name><name>Table</name>.<name>system</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>flushes</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>cfs</name>.<name>forceFlush</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></for>
        <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>waitOnFutures</name></name><argument_list>(<argument><expr><name>flushes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>postFlushExecutor</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>postFlushExecutor</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>60</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>SECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>shutdownBlocking</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// wait for miscellaneous tasks like sstable and commitlog segment deletion</comment>
        <expr_stmt><expr><call><name><name>tasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>tasks</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MINUTES</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Miscellaneous task executor still busy after one minute; proceeding with shutdown"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINED</name></name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// Never ever do this at home. Used by tests.</comment>
    <function><type><name>IPartitioner</name></type> <name>setPartitionerUnsafe</name><parameter_list>(<param><decl><type><name>IPartitioner</name></type> <name>newPartitioner</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>IPartitioner</name></type> <name>oldPartitioner</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setPartitioner</name></name><argument_list>(<argument><expr><name>newPartitioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>valueFactory</name> = new <call><name><name>VersionedValue</name>.<name>VersionedValueFactory</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>oldPartitioner</name></expr>;</return>
    }</block></function>

    <function><type><name>TokenMetadata</name></type> <name>setTokenMetadataUnsafe</name><parameter_list>(<param><decl><type><name>TokenMetadata</name></type> <name>tmd</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>old</name> <init>= <expr><name>tokenMetadata</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>tokenMetadata</name> = <name>tmd</name></expr>;</expr_stmt>
        <return>return <expr><name>old</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>truncate</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>TimeoutException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>truncateBlocking</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>UnavailableException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>getOwnership</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// describeOwnership returns tokens in an unspecified order, let's re-order them</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>tokenMap</name> <init>= <expr>new <call><name><name>TreeMap</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>describeOwnership</name><argument_list>(<argument><expr><name>sortedTokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>nodeMap</name> <init>= <expr>new <call><name><name>LinkedHashMap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>tokenMap</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>endpoint</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Float</name></type> <name>tokenOwnership</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>nodeMap</name>.<name>containsKey</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>nodeMap</name>.<name>put</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name><name>nodeMap</name>.<name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call> + <name>tokenOwnership</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name><name>nodeMap</name>.<name>put</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>tokenOwnership</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></for>
        <return>return <expr><name>nodeMap</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Calculates ownership. If there are multiple DC's and the replication strategy is DC aware then ownership will be
     * calculated per dc, i.e. each DC will have total ring ownership divided amongst its nodes. Without replication
     * total ownership will be a multiple of the number of DC's and this value will then go up within each DC depending
     * on the number of replicas within itself. For DC unaware replication strategies, ownership without replication
     * will be 100%.
     *
     * @throws IllegalStateException when node is not configured properly.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>LinkedHashMap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>effectiveOwnership</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IllegalStateException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Couldn't find any Non System Keyspaces to infer replication topology"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <if>if <condition>(<expr><name>keyspace</name> == null &amp;&amp; !<call><name>hasSameReplication</name><argument_list>(<argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"Non System keyspaces doesnt have the same topology"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>metadata</name> <init>= <expr><call><name><name>tokenMetadata</name>.<name>cloneOnlyTokenMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>keyspace</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>keyspace</name> = <call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>endpointsGroupedByDc</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// mapping of dc's to nodes, use sorted map so that we get dcs sorted</comment>
        <decl_stmt><decl><type><name><name>SortedMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sortedDcsToEndpoints</name> <init>= <expr>new <call><name><name>TreeMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>sortedDcsToEndpoints</name>.<name>putAll</name></name><argument_list>(<argument><expr><call><name><name>metadata</name>.<name>getTopology</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenterEndpoints</name><argument_list>()</argument_list></call>.<call><name>asMap</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <range>: <expr><call><name><name>sortedDcsToEndpoints</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>endpointsGroupedByDc</name>.<name>add</name></name><argument_list>(<argument><expr><name>endpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>tokenOwnership</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>describeOwnership</name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>LinkedHashMap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>finalOwnership</name> <init>= <expr><call><name><name>Maps</name>.<name>newLinkedHashMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// calculate ownership per dc</comment>
        <for>for (<init><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <range>: <expr><name>endpointsGroupedByDc</name></expr></range></decl></init>)
        <block>{
            <comment type="line">// calculate the ownership with replication and add the endpoint to the final ownership map</comment>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>endpoints</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>float</name></type> <name>ownership</name> <init>= <expr>0.0f</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name>getRangesForEndpoint</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>tokenOwnership</name>.<name>containsKey</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><name>ownership</name> += <call><name><name>tokenOwnership</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></for>
                <expr_stmt><expr><call><name><name>finalOwnership</name>.<name>put</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>ownership</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>finalOwnership</name></expr>;</return>
    }</block></function>


    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hasSameReplication</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>list</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>list</name>.<name>size</name></name><argument_list>()</argument_list></call> -1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <decl_stmt><decl><type><name>KSMetaData</name></type> <name>ksm1</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getKSMetaData</name></name><argument_list>(<argument><expr><call><name><name>list</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>KSMetaData</name></type> <name>ksm2</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getKSMetaData</name></name><argument_list>(<argument><expr><call><name><name>list</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>ksm1</name>.<name>strategyClass</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>ksm2</name>.<name>strategyClass</name></name></expr></argument>)</argument_list></call> ||
                    !<call><name><name>Iterators</name>.<name>elementsEqual</name></name><argument_list>(<argument><expr><call><name><name>ksm1</name>.<name>strategyOptions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></argument>,
                                             <argument><expr><call><name><name>ksm2</name>.<name>strategyOptions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getKeyspaces</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tableslist</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>Collections</name>.<name>unmodifiableList</name></name><argument_list>(<argument><expr><name>tableslist</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateSnitch</name><parameter_list>(<param><decl><type><name>String</name></type> <name>epSnitchClassName</name></decl></param>, <param><decl><type><name>Boolean</name></type> <name>dynamic</name></decl></param>, <param><decl><type><name>Integer</name></type> <name>dynamicUpdateInterval</name></decl></param>, <param><decl><type><name>Integer</name></type> <name>dynamicResetInterval</name></decl></param>, <param><decl><type><name>Double</name></type> <name>dynamicBadnessThreshold</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ClassNotFoundException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>oldSnitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// new snitch registers mbean during construction</comment>
        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>newSnitch</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>newSnitch</name> = <call><name><name>FBUtilities</name>.<name>construct</name></name><argument_list>(<argument><expr><name>epSnitchClassName</name></expr></argument>, <argument><expr>"snitch"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>ClassNotFoundException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <if>if <condition>(<expr><name>dynamic</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setDynamicUpdateInterval</name></name><argument_list>(<argument><expr><name>dynamicUpdateInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setDynamicResetInterval</name></name><argument_list>(<argument><expr><name>dynamicResetInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setDynamicBadnessThreshold</name></name><argument_list>(<argument><expr><name>dynamicBadnessThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newSnitch</name> = new <call><name>DynamicEndpointSnitch</name><argument_list>(<argument><expr><name>newSnitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// point snitch references to the new instance</comment>
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setEndpointSnitch</name></name><argument_list>(<argument><expr><name>newSnitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>ks</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>ks</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<name>snitch</name> = <name>newSnitch</name></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><name>oldSnitch</name> instanceof <name>DynamicEndpointSnitch</name></expr>)</condition><then>
            <expr_stmt><expr>((<name>DynamicEndpointSnitch</name>)<name>oldSnitch</name>).<call><name>unregisterMBean</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Flushes the two largest memtables by ops and by throughput
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>flushLargestMemtables</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>largest</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>ColumnFamilyStore</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>total</name> <init>= <expr><call><name><name>cfs</name>.<name>getTotalMemtableLiveSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>total</name> &gt; 0 &amp;&amp; (<name>largest</name> == null || <name>total</name> &gt; <call><name><name>largest</name>.<name>getTotalMemtableLiveSize</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr><name>total</name> + " estimated memtable size for " + <name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>largest</name> = <name>cfs</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>largest</name> == null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Unable to reduce heap usage since there are no dirty column families"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Flushing " + <name>largest</name> + " to relieve memory pressure"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>largest</name>.<name>forceFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Seed data to the endpoints that will be responsible for it at the future
     *
     * @param rangesToStreamByTable tables and data ranges with endpoints included for each
     * @return latch to count down
     */</comment>
    <function><type><specifier>private</specifier> <name>CountDownLatch</name></type> <name>streamRanges</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToStreamByTable</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// First, we build a list of ranges to stream to each host, per table</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sessionsToStreamByTable</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// The number of stream out sessions we need to start, to be built up as we build sessionsToStreamByTable</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>sessionCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>rangesToStreamByTable</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangesWithEndpoints</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>rangesWithEndpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesPerEndpoint</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><specifier>final</specifier> <name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></type> <name>endPointEntry</name> <range>: <expr><call><name><name>rangesWithEndpoints</name>.<name>entries</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name><name>endPointEntry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>endpoint</name> <init>= <expr><call><name><name>endPointEntry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>curRanges</name> <init>= <expr><call><name><name>rangesPerEndpoint</name>.<name>get</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>curRanges</name> == null</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>curRanges</name> = new <call><name><name>LinkedList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>rangesPerEndpoint</name>.<name>put</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>curRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name><name>curRanges</name>.<name>add</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <expr_stmt><expr><name>sessionCount</name> += <call><name><name>rangesPerEndpoint</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sessionsToStreamByTable</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>rangesPerEndpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <decl_stmt><decl><type><specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name> <init>= <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr><name>sessionCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>sessionsToStreamByTable</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesPerEndpoint</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><specifier>final</specifier> <name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>rangesEntry</name> <range>: <expr><call><name><name>rangesPerEndpoint</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name><name>rangesEntry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>newEndpoint</name> <init>= <expr><call><name><name>rangesEntry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// TODO each call to transferRanges re-flushes, this is potentially a lot of waste</comment>
                <expr_stmt><expr><call><name><name>StreamOut</name>.<name>transferRanges</name></name><argument_list>(<argument><expr><name>newEndpoint</name></expr></argument>,
                                         <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>ranges</name></expr></argument>,
                                         <argument><expr>new <call><name>CountingDownStreamCallback</name><argument_list>(<argument><expr><name>latch</name></expr></argument>, <argument><expr><name>newEndpoint</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>OperationType</name>.<name>UNBOOTSTRAP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>latch</name></expr>;</return>
    }</block></function>

    <class>class <name>CountingDownStreamCallback</name> <super><implements>implements <name>IStreamCallback</name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>InetAddress</name></type> <name>targetAddr</name></decl>;</decl_stmt>

        <constructor><name>CountingDownStreamCallback</name><parameter_list>(<param><decl><type><name>CountDownLatch</name></type> <name>latch</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>targetAddr</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>latch</name></name> = <name>latch</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>targetAddr</name></name> = <name>targetAddr</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>()</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Streaming to " + <name>targetAddr</name> + " failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>onSuccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// calling onSuccess for latch countdown</comment>
        }</block></function>
    }</block></class><empty_stmt>;</empty_stmt>

    <comment type="block" format="javadoc">/**
     * Used to request ranges from endpoints in the ring (will block until all data is fetched and ready)
     * @param ranges ranges to fetch as map of the preferred address and range collection
     * @return latch to count down
     */</comment>
    <function><type><specifier>private</specifier> <name>CountDownLatch</name></type> <name>requestRanges</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name> <init>= <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>keySet</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>ranges</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>endpointWithRanges</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>endpointWithRanges</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>pending</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>endpointWithRanges</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Send messages to respective folks to stream data over to me</comment>
            <for>for (<init><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>source</name><range>: <expr><call><name><name>endpointWithRanges</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>toFetch</name> <init>= <expr><call><name><name>endpointWithRanges</name>.<name>get</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>IStreamCallback</name></type> <name>callback</name> <init>= <expr>new <class><super><name>IStreamCallback</name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>pending</name>.<name>remove</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if>if <condition>(<expr><call><name><name>pending</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                    }</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Streaming from " + <name>source</name> + " failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>onSuccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// calling onSuccess for latch countdown</comment>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Requesting from " + <name>source</name> + " ranges " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>toFetch</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <comment type="line">// sending actual request</comment>
                <expr_stmt><expr><call><name><name>StreamIn</name>.<name>requestRanges</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>toFetch</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>BOOTSTRAP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>latch</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Calculate pair of ranges to stream/fetch for given two range collections
     * (current ranges for table and ranges after move to new token)
     *
     * @param current collection of the ranges by current token
     * @param updated collection of the ranges after token is changed
     * @return pair of ranges to stream/fetch for given current and updated range collections
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>calculateStreamAndFetchRanges</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>current</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>updated</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>toStream</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>toFetch</name>  <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


        <for>for (<init><decl><type><name>Range</name></type> <name>r1</name> <range>: <expr><name>current</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>intersect</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>Range</name></type> <name>r2</name> <range>: <expr><name>updated</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>r1</name>.<name>intersects</name></name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// adding difference ranges to fetch from a ring</comment>
                    <expr_stmt><expr><call><name><name>toStream</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>r1</name>.<name>subtract</name></name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intersect</name> = true</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr>!<name>intersect</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>toStream</name>.<name>add</name></name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// should seed whole old range</comment>
            }</block></then></if>
        }</block></for>

        <for>for (<init><decl><type><name>Range</name></type> <name>r2</name> <range>: <expr><name>updated</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>intersect</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>Range</name></type> <name>r1</name> <range>: <expr><name>current</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>r2</name>.<name>intersects</name></name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// adding difference ranges to fetch from a ring</comment>
                    <expr_stmt><expr><call><name><name>toFetch</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>r2</name>.<name>subtract</name></name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intersect</name> = true</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr>!<name>intersect</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>toFetch</name>.<name>add</name></name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// should fetch whole old range</comment>
            }</block></then></if>
        }</block></for>

        <return>return <expr><call><name><name>Pair</name>.<name>create</name></name><argument_list>(<argument><expr><name>toStream</name></expr></argument>, <argument><expr><name>toFetch</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>bulkLoad</name><parameter_list>(<param><decl><type><name>String</name></type> <name>directory</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>File</name></type> <name>dir</name> <init>= <expr>new <call><name>File</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name><name>dir</name>.<name>exists</name></name><argument_list>()</argument_list></call> || !<call><name><name>dir</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Invalid directory " + <name>directory</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>SSTableLoader</name>.<name>Client</name></name></type> <name>client</name> <init>= <expr>new <class><super><name><name>SSTableLoader</name>.<name>Client</name></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
            <block>{
                <try>try
                <block>{
                    <expr_stmt><expr><call><name>setPartitioner</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getRangeToAddressMap</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                            <expr_stmt><expr><call><name>addRangeForEndpoint</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                    }</block></for>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></function>

            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>boolean</name></type> <name>validateColumnFamily</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>)</parameter_list>
            <block>{
                <return>return <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getCFMetaData</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call> != null</expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>SSTableLoader</name></type> <name>loader</name> <init>= <expr>new <call><name>SSTableLoader</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr>new <call><name><name>OutputHandler</name>.<name>LogOutput</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>loader</name>.<name>stream</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getExceptionCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>CassandraDaemon</name>.<name>exceptions</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>rescheduleFailedDeletions</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>SSTableDeletingTask</name>.<name>rescheduleFailedTasks</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * #{@inheritDoc}
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>loadNewSSTables</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ksName</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>loadNewSSTables</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * #{@inheritDoc}
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>sampleKeyRange</name><parameter_list>()</parameter_list> <comment type="line">// do not rename to getter - see CASSANDRA-4452 for details</comment>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name>getLocalPrimaryRanges</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>keys</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name>keySamples</name><argument_list>(<argument><expr><call><name><name>ColumnFamilyStore</name>.<name>allUserDefined</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>sampledKeys</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>DecoratedKey</name></type> <name>key</name> <range>: <expr><name>keys</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>sampledKeys</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>key</name>.<name>getToken</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>sampledKeys</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>rebuildSecondaryIndex</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ksName</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>idxNames</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>rebuildSecondaryIndex</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>, <argument><expr><name>idxNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>resetLocalSchema</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>MigrationManager</name>.<name>resetLocalSchema</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTraceProbability</name><parameter_list>(<param><decl><type><name>double</name></type> <name>probability</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name><name>this</name>.<name>tracingProbability</name></name> = <name>probability</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getTracingProbability</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>tracingProbability</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>enableScheduledRangeXfers</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>rangeXferExecutor</name>.<name>setup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>disableScheduledRangeXfers</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>rangeXferExecutor</name>.<name>tearDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
