<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.2.1\src\java\org\apache\cassandra\service\StorageProxy.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>DataOutputStream</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>management</name>.<name>ManagementFactory</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>InetAddress</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicLong</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>MBeanServer</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>ObjectName</name></name>;</import>

<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>base</name>.<name>Function</name></name>;</import>
<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>collect</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>lang</name>.<name>StringUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>Stage</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>StageManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>Schema</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>Table</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>ColumnSlice</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>IDiskAtomFilter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>QueryPath</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>SliceQueryFilter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>UUIDType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>AbstractBounds</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>Bounds</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>RingPosition</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>Token</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>exceptions</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>gms</name>.<name>FailureDetector</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>gms</name>.<name>Gossiper</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>util</name>.<name>FastByteArrayOutputStream</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name>.<name>AbstractReplicationStrategy</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name>.<name>IEndpointSnitch</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name>.<name>TokenMetadata</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>metrics</name>.<name>ClientRequestMetrics</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>tracing</name>.<name>Tracing</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>ByteBufferUtil</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>Pair</name></name>;</import>

<class><specifier>public</specifier> class <name>StorageProxy</name> <super><implements>implements <name>StorageProxyMBean</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>MBEAN_NAME</name> <init>= <expr>"org.apache.cassandra.db:type=StorageProxy"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>StorageProxy</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>OPTIMIZE_LOCAL_REQUESTS</name> <init>= <expr>true</expr></init></decl>;</decl_stmt> <comment type="line">// set to false to test messagingservice path on single node</comment>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>UNREACHABLE</name> <init>= <expr>"UNREACHABLE"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>WritePerformer</name></type> <name>standardWritePerformer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>WritePerformer</name></type> <name>counterWritePerformer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>WritePerformer</name></type> <name>counterWriteOnCoordinatorPerformer</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>StorageProxy</name></type> <name>instance</name> <init>= <expr>new <call><name>StorageProxy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>maxHintsInProgress</name> <init>= <expr>1024 * <call><name><name>FBUtilities</name>.<name>getAvailableProcessors</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>totalHintsInProgress</name> <init>= <expr>new <call><name>AtomicInteger</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>AtomicInteger</name></argument>&gt;</argument_list></name></type> <name>hintsInProgress</name> <init>= <expr>new <call><name>MapMaker</name><argument_list>()</argument_list></call>.<call><name>concurrencyLevel</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call>.<call><name>makeComputingMap</name><argument_list>(<argument><expr>new <class><super><name><name>Function</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>AtomicInteger</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
    <block>{
        <function><type><specifier>public</specifier> <name>AtomicInteger</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>inetAddress</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr>new <call><name>AtomicInteger</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>AtomicLong</name></type> <name>totalHints</name> <init>= <expr>new <call><name>AtomicLong</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ClientRequestMetrics</name></type> <name>readMetrics</name> <init>= <expr>new <call><name>ClientRequestMetrics</name><argument_list>(<argument><expr>"Read"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ClientRequestMetrics</name></type> <name>rangeMetrics</name> <init>= <expr>new <call><name>ClientRequestMetrics</name><argument_list>(<argument><expr>"RangeSlice"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ClientRequestMetrics</name></type> <name>writeMetrics</name> <init>= <expr>new <call><name>ClientRequestMetrics</name><argument_list>(<argument><expr>"Write"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <constructor><specifier>private</specifier> <name>StorageProxy</name><parameter_list>()</parameter_list> <block>{}</block></constructor>

    <expr_stmt><expr>static
    <block>{
        <expr><name>MBeanServer</name> <name>mbs</name> = <call><name><name>ManagementFactory</name>.<name>getPlatformMBeanServer</name></name><argument_list>()</argument_list></call></expr>;
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>mbs</name>.<name>registerMBean</name></name><argument_list>(<argument><expr>new <call><name>StorageProxy</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>new <call><name>ObjectName</name><argument_list>(<argument><expr><name>MBEAN_NAME</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt/></block></try>}</block></expr></expr_stmt>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>

        <expr_stmt><expr><name>standardWritePerformer</name> = new <class><super><name>WritePerformer</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>IMutation</name></type> <name>mutation</name></decl></param>,
                              <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>,
                              <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>,
                              <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>,
                              <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument></throws>
            <block>{
                <assert>assert <expr><name>mutation</name> instanceof <name>RowMutation</name></expr>;</assert>
                <expr_stmt><expr><call><name>sendToHintedEndpoints</name><argument_list>(<argument><expr>(<name>RowMutation</name>) <name>mutation</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></class></expr>;</expr_stmt>

        <comment type="block">/*
         * We execute counter writes in 2 places: either directly in the coordinator node if it is a replica, or
         * in CounterMutationVerbHandler on a replica othewise. The write must be executed on the MUTATION stage
         * but on the latter case, the verb handler already run on the MUTATION stage, so we must not execute the
         * underlying on the stage otherwise we risk a deadlock. Hence two different performer.
         */</comment>
        <expr_stmt><expr><name>counterWritePerformer</name> = new <class><super><name>WritePerformer</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>IMutation</name></type> <name>mutation</name></decl></param>,
                              <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>,
                              <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>,
                              <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>,
                              <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{
                <if>if <condition>(<expr><call><name><name>logger</name>.<name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"insert writing local &amp; replicate " + <call><name><name>mutation</name>.<name>toString</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr><call><name>counterWriteTask</name><argument_list>(<argument><expr><name>mutation</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>runnable</name>.<name>run</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></class></expr>;</expr_stmt>

        <expr_stmt><expr><name>counterWriteOnCoordinatorPerformer</name> = new <class><super><name>WritePerformer</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>IMutation</name></type> <name>mutation</name></decl></param>,
                              <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>,
                              <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>,
                              <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>,
                              <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
            <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{
                <if>if <condition>(<expr><call><name><name>logger</name>.<name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"insert writing local &amp; replicate " + <call><name><name>mutation</name>.<name>toString</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr><call><name>counterWriteTask</name><argument_list>(<argument><expr><name>mutation</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr><name>runnable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></class></expr>;</expr_stmt>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Use this method to have these Mutations applied
     * across all replicas. This method will take care
     * of the possibility of a replica being down and hint
     * the data across to some other replica.
     *
     * @param mutations the mutations to be applied across the replicas
     * @param consistency_level the consistency level for the operation
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>mutate</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>?</name> <extends>extends <name>IMutation</name></extends></argument>&gt;</argument_list></name></type> <name>mutations</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument>, <argument><expr><name>WriteTimeoutException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Determining replicas for mutation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Mutations/ConsistencyLevel are {}/{}"</expr></argument>, <argument><expr><name>mutations</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>localDataCenter</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenter</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name></type> <name>startTime</name> <init>= <expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>AbstractWriteResponseHandler</name></argument>&gt;</argument_list></name></type> <name>responseHandlers</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>AbstractWriteResponseHandler</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mutations</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>IMutation</name></type> <name>mostRecentMutation</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <for>for (<init><decl><type><name>IMutation</name></type> <name>mutation</name> <range>: <expr><name>mutations</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><name>mostRecentMutation</name> = <name>mutation</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>mutation</name> instanceof <name>CounterMutation</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>responseHandlers</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>mutateCounter</name><argument_list>(<argument><expr>(<name>CounterMutation</name>)<name>mutation</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <decl_stmt><decl><type><name>WriteType</name></type> <name>wt</name> <init>= <expr><call><name><name>mutations</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt;= 1 ? <name><name>WriteType</name>.<name>SIMPLE</name></name> : <name><name>WriteType</name>.<name>UNLOGGED_BATCH</name></name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>responseHandlers</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>performWrite</name><argument_list>(<argument><expr><name>mutation</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>standardWritePerformer</name></expr></argument>, <argument><expr>null</expr></argument>, <argument><expr><name>wt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>

            <comment type="line">// wait for writes.  throws TimeoutException if necessary</comment>
            <for>for (<init><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name> <range>: <expr><name>responseHandlers</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>responseHandler</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>

        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>WriteTimeoutException</name></type> <name>ex</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>writeMetrics</name>.<name>timeouts</name>.<name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>writeTimeouts</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>mstrings</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mutations</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>IMutation</name></type> <name>mutation</name> <range>: <expr><name>mutations</name></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>mstrings</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>mutation</name>.<name>toString</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Write timeout {} for one (or more) of: {}"</expr></argument>, <argument><expr><call><name><name>ex</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mstrings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Write timeout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>ex</name></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>UnavailableException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>writeMetrics</name>.<name>unavailables</name>.<name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>writeUnavailables</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Unavailable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>OverloadedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>writeUnavailables</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Overloaded"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <assert>assert <expr><name>mostRecentMutation</name> != null</expr>;</assert>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"error writing key " + <call><name><name>ByteBufferUtil</name>.<name>bytesToHex</name></name><argument_list>(<argument><expr><call><name><name>mostRecentMutation</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>writeMetrics</name>.<name>addNano</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call> - <name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * See mutate. Adds additional steps before and after writing a batch.
     * Before writing the batch (but after doing availability check against the FD for the row replicas):
     *      write the entire batch to a batchlog elsewhere in the cluster.
     * After: remove the batchlog entry (after writing hints for the batch rows, if necessary).
     *
     * @param mutations the RowMutations to be applied across the replicas
     * @param consistency_level the consistency level for the operation
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>mutateAtomically</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>RowMutation</name></argument>&gt;</argument_list></name></type> <name>mutations</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument>, <argument><expr><name>WriteTimeoutException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Determining replicas for atomic batch"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>startTime</name> <init>= <expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Mutations/ConsistencyLevel are {}/{}"</expr></argument>, <argument><expr><name>mutations</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>WriteResponseHandlerWrapper</name></argument>&gt;</argument_list></name></type> <name>wrappers</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>WriteResponseHandlerWrapper</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mutations</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>localDataCenter</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenter</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{
            <comment type="line">// add a handler for each mutation - includes checking availability, but doesn't initiate any writes, yet</comment>
            <for>for (<init><decl><type><name>RowMutation</name></type> <name>mutation</name> <range>: <expr><name>mutations</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>WriteResponseHandlerWrapper</name></type> <name>wrapper</name> <init>= <expr><call><name>wrapResponseHandler</name><argument_list>(<argument><expr><name>mutation</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>, <argument><expr><name><name>WriteType</name>.<name>BATCH</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// exit early if we can't fulfill the CL at this time.</comment>
                <expr_stmt><expr><call><name><name>wrapper</name>.<name>handler</name>.<name>assureSufficientLiveNodes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>wrappers</name>.<name>add</name></name><argument_list>(<argument><expr><name>wrapper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// write to the batchlog</comment>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>batchlogEndpoints</name> <init>= <expr><call><name>getBatchlogEndpoints</name><argument_list>(<argument><expr><name>localDataCenter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>UUID</name></type> <name>batchUUID</name> <init>= <expr><call><name><name>UUID</name>.<name>randomUUID</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>syncWriteToBatchlog</name><argument_list>(<argument><expr><name>mutations</name></expr></argument>, <argument><expr><name>batchlogEndpoints</name></expr></argument>, <argument><expr><name>batchUUID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// now actually perform the writes and wait for them to complete</comment>
            <expr_stmt><expr><call><name>syncWriteBatchedMutations</name><argument_list>(<argument><expr><name>wrappers</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// remove the batchlog entries asynchronously</comment>
            <expr_stmt><expr><call><name>asyncRemoveFromBatchlog</name><argument_list>(<argument><expr><name>batchlogEndpoints</name></expr></argument>, <argument><expr><name>batchUUID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>UnavailableException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>writeMetrics</name>.<name>unavailables</name>.<name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>writeUnavailables</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Unavailable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>WriteTimeoutException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>writeMetrics</name>.<name>timeouts</name>.<name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>writeTimeouts</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Write timeout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        }</block></catch>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>writeMetrics</name>.<name>addNano</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call> - <name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>syncWriteToBatchlog</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>RowMutation</name></argument>&gt;</argument_list></name></type> <name>mutations</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name></decl></param>, <param><decl><type><name>UUID</name></type> <name>uuid</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>WriteTimeoutException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>RowMutation</name></type> <name>rm</name> <init>= <expr><call><name><name>BatchlogManager</name>.<name>getBatchlogMutationFor</name></name><argument_list>(<argument><expr><name>mutations</name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AbstractWriteResponseHandler</name></type> <name>handler</name> <init>= <expr>new <call><name>WriteResponseHandler</name><argument_list>(<argument><expr><name>endpoints</name></expr></argument>,
                                                                        <argument><expr><name><name>Collections</name>.</name>&lt;<name>InetAddress</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>,
                                                                        <argument><expr><name><name>ConsistencyLevel</name>.<name>ONE</name></name></expr></argument>,
                                                                        <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_KS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                                        <argument><expr>null</expr></argument>,
                                                                        <argument><expr><name><name>WriteType</name>.<name>BATCH_LOG</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>updateBatchlog</name><argument_list>(<argument><expr><name>rm</name></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>handler</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>asyncRemoveFromBatchlog</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name></decl></param>, <param><decl><type><name>UUID</name></type> <name>uuid</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>RowMutation</name></type> <name>rm</name> <init>= <expr>new <call><name>RowMutation</name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_KS</name></name></expr></argument>, <argument><expr><call><name><name>UUIDType</name>.<name>instance</name>.<name>decompose</name></name><argument_list>(<argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>rm</name>.<name>delete</name></name><argument_list>(<argument><expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BATCHLOG_CF</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>timestampMicros</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>AbstractWriteResponseHandler</name></type> <name>handler</name> <init>= <expr>new <call><name>WriteResponseHandler</name><argument_list>(<argument><expr><name>endpoints</name></expr></argument>,
                                                                        <argument><expr><name><name>Collections</name>.</name>&lt;<name>InetAddress</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>,
                                                                        <argument><expr><name><name>ConsistencyLevel</name>.<name>ANY</name></name></expr></argument>,
                                                                        <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_KS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                                        <argument><expr>null</expr></argument>,
                                                                        <argument><expr><name><name>WriteType</name>.<name>SIMPLE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>updateBatchlog</name><argument_list>(<argument><expr><name>rm</name></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>updateBatchlog</name><parameter_list>(<param><decl><type><name>RowMutation</name></type> <name>rm</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name></decl></param>, <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>handler</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>endpoints</name>.<name>contains</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <assert>assert <expr><call><name><name>endpoints</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>;</assert>
            <expr_stmt><expr><call><name>insertLocal</name><argument_list>(<argument><expr><name>rm</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name>sendMessagesToOneDC</name><argument_list>(<argument><expr><call><name><name>rm</name>.<name>createMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>syncWriteBatchedMutations</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>WriteResponseHandlerWrapper</name></argument>&gt;</argument_list></name></type> <name>wrappers</name></decl></param>,
                                                  <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>,
                                                  <param><decl><type><name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>WriteTimeoutException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>WriteResponseHandlerWrapper</name></type> <name>wrapper</name> <range>: <expr><name>wrappers</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><name><name>wrapper</name>.<name>handler</name>.<name>naturalEndpoints</name></name></expr></argument>, <argument><expr><name><name>wrapper</name>.<name>handler</name>.<name>pendingEndpoints</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>sendToHintedEndpoints</name><argument_list>(<argument><expr><name><name>wrapper</name>.<name>mutation</name></name></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>, <argument><expr><name><name>wrapper</name>.<name>handler</name></name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistencyLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name>WriteResponseHandlerWrapper</name></type> <name>wrapper</name> <range>: <expr><name>wrappers</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>wrapper</name>.<name>handler</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Perform the write of a mutation given a WritePerformer.
     * Gather the list of write endpoints, apply locally and/or forward the mutation to
     * said write endpoint (deletaged to the actual WritePerformer) and wait for the
     * responses based on consistency level.
     *
     * @param mutation the mutation to be applied
     * @param consistency_level the consistency level for the write operation
     * @param performer the WritePerformer in charge of appliying the mutation
     * given the list of write endpoints (either standardWritePerformer for
     * standard writes or counterWritePerformer for counter writes).
     * @param callback an optional callback to be run if and when the write is
     * successful.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>AbstractWriteResponseHandler</name></type> <name>performWrite</name><parameter_list>(<param><decl><type><name>IMutation</name></type> <name>mutation</name></decl></param>,
                                                            <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>,
                                                            <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>,
                                                            <param><decl><type><name>WritePerformer</name></type> <name>performer</name></decl></param>,
                                                            <param><decl><type><name>Runnable</name></type> <name>callback</name></decl></param>,
                                                            <param><decl><type><name>WriteType</name></type> <name>writeType</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>table</name> <init>= <expr><call><name><name>mutation</name>.<name>getTable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>rs</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Token</name></type> <name>tk</name> <init>= <expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>getToken</name><argument_list>(<argument><expr><call><name><name>mutation</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>naturalEndpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getNaturalEndpoints</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>tk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>pendingEndpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call>.<call><name>pendingEndpointsFor</name><argument_list>(<argument><expr><name>tk</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name> <init>= <expr><call><name><name>rs</name>.<name>getWriteResponseHandler</name></name><argument_list>(<argument><expr><name>naturalEndpoints</name></expr></argument>, <argument><expr><name>pendingEndpoints</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>writeType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// exit early if we can't fulfill the CL at this time</comment>
        <expr_stmt><expr><call><name><name>responseHandler</name>.<name>assureSufficientLiveNodes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>performer</name>.<name>apply</name></name><argument_list>(<argument><expr><name>mutation</name></expr></argument>, <argument><expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><name>naturalEndpoints</name></expr></argument>, <argument><expr><name>pendingEndpoints</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>responseHandler</name></expr>;</return>
    }</block></function>

    <comment type="line">// same as above except does not initiate writes (but does perfrom availability checks).</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>WriteResponseHandlerWrapper</name></type> <name>wrapResponseHandler</name><parameter_list>(<param><decl><type><name>RowMutation</name></type> <name>mutation</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>, <param><decl><type><name>WriteType</name></type> <name>writeType</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>rs</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><call><name><name>mutation</name>.<name>getTable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>table</name> <init>= <expr><call><name><name>mutation</name>.<name>getTable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>tk</name> <init>= <expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>getToken</name><argument_list>(<argument><expr><call><name><name>mutation</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>naturalEndpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getNaturalEndpoints</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>tk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>pendingEndpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call>.<call><name>pendingEndpointsFor</name><argument_list>(<argument><expr><name>tk</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name> <init>= <expr><call><name><name>rs</name>.<name>getWriteResponseHandler</name></name><argument_list>(<argument><expr><name>naturalEndpoints</name></expr></argument>, <argument><expr><name>pendingEndpoints</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>, <argument><expr>null</expr></argument>, <argument><expr><name>writeType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr>new <call><name>WriteResponseHandlerWrapper</name><argument_list>(<argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>mutation</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// used by atomic_batch_mutate to decouple availability check from the write itself, caches consistency level and endpoints.</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>WriteResponseHandlerWrapper</name>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>AbstractWriteResponseHandler</name></type> <name>handler</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>RowMutation</name></type> <name>mutation</name></decl>;</decl_stmt>

        <constructor><name>WriteResponseHandlerWrapper</name><parameter_list>(<param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>handler</name></decl></param>, <param><decl><type><name>RowMutation</name></type> <name>mutation</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>handler</name></name> = <name>handler</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>mutation</name></name> = <name>mutation</name></expr>;</expr_stmt>
        }</block></constructor>
    }</block></class>

    <comment type="block">/*
     * Replicas are picked manually:
     * - replicas should be alive according to the failure detector
     * - replicas should be in the local datacenter
     * - choose min(2, number of qualifying candiates above)
     * - allow the local node to be the only replica only if it's a single-node cluster
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getBatchlogEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{
        <comment type="line">// will include every known node in the DC, including localhost.</comment>
        <decl_stmt><decl><type><name><name>TokenMetadata</name>.<name>Topology</name></name></type> <name>topology</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call>.<call><name>cloneOnlyTokenMap</name><argument_list>()</argument_list></call>.<call><name>getTopology</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>localMembers</name> <init>= <expr><call><name><name>topology</name>.<name>getDatacenterEndpoints</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>localDataCenter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// special case for single-node datacenters</comment>
        <if>if <condition>(<expr><call><name><name>localMembers</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
            <return>return <expr><name>localMembers</name></expr>;</return></then></if>

        <comment type="line">// not a single-node cluster - don't count the local node.</comment>
        <expr_stmt><expr><call><name><name>localMembers</name>.<name>remove</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// include only alive nodes</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>candidates</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>localMembers</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>member</name> <range>: <expr><name>localMembers</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>FailureDetector</name>.<name>instance</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>member</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>candidates</name>.<name>add</name></name><argument_list>(<argument><expr><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>candidates</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnavailableException</name><argument_list>(<argument><expr><name><name>ConsistencyLevel</name>.<name>ONE</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><call><name><name>candidates</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 2</expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>snitch</name>.<name>sortByProximity</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>candidates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>candidates</name> = <call><name><name>candidates</name>.<name>subList</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><name>candidates</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Send the mutations to the right targets, write it locally if it corresponds or writes a hint when the node
     * is not available.
     *
     * Note about hints:
     *
     * | Hinted Handoff | Consist. Level |
     * | on             |       &gt;=1      | --&gt; wait for hints. We DO NOT notify the handler with handler.response() for hints;
     * | on             |       ANY      | --&gt; wait for hints. Responses count towards consistency.
     * | off            |       &gt;=1      | --&gt; DO NOT fire hints. And DO NOT wait for them to complete.
     * | off            |       ANY      | --&gt; DO NOT fire hints. And DO NOT wait for them to complete.
     *
     * @throws TimeoutException if the hints cannot be written/enqueued
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>sendToHintedEndpoints</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>RowMutation</name></type> <name>rm</name></decl></param>,
                                             <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>,
                                             <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>,
                                             <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>,
                                             <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>OverloadedException</name></expr></argument></throws>
    <block>{
        <comment type="line">// Multimap that holds onto all the messages and addresses meant for a specific datacenter</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>MessageOut</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>dcMessages</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>MessageOut</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>InetAddress</name></type> <name>destination</name> <range>: <expr><name>targets</name></expr></range></decl></init>)
        <block>{
            <comment type="line">// avoid OOMing due to excess hints.  we need to do this check even for "live" nodes, since we can</comment>
            <comment type="line">// still generate hints for those if it's overloaded or simply dead but not yet known-to-be-dead.</comment>
            <comment type="line">// The idea is that if we have over maxHintsInProgress hints in flight, this is probably due to</comment>
            <comment type="line">// a small number of nodes causing problems, so we should avoid shutting down writes completely to</comment>
            <comment type="line">// healthy nodes.  Any node with no hintsInProgress is considered healthy.</comment>
            <if>if <condition>(<expr><call><name><name>totalHintsInProgress</name>.<name>get</name></name><argument_list>()</argument_list></call> &gt; <name>maxHintsInProgress</name>
                &amp;&amp; (<call><name><name>hintsInProgress</name>.<name>get</name></name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp; <call><name>shouldHint</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <block>{
                <throw>throw <expr>new <call><name>OverloadedException</name><argument_list>(<argument><expr>"Too many in flight hints: " + <call><name><name>totalHintsInProgress</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></then></if>

            <if>if <condition>(<expr><call><name><name>FailureDetector</name>.<name>instance</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>destination</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; <name>OPTIMIZE_LOCAL_REQUESTS</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name>insertLocal</name><argument_list>(<argument><expr><name>rm</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <comment type="line">// belongs on a different server</comment>
                    <if>if <condition>(<expr><call><name><name>logger</name>.<name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"insert writing key " + <call><name><name>ByteBufferUtil</name>.<name>bytesToHex</name></name><argument_list>(<argument><expr><call><name><name>rm</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> + " to " + <name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                    <decl_stmt><decl><type><name>String</name></type> <name>dc</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenter</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>MessageOut</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>messages</name> <init>= <expr><call><name><name>dcMessages</name>.<name>get</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>messages</name> == null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>messages</name> = <call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>dcMessages</name>.<name>put</name></name><argument_list>(<argument><expr><name>dc</name></expr></argument>, <argument><expr><name>messages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <expr_stmt><expr><call><name><name>messages</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>rm</name>.<name>createMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
            <else>else
            <block>{
                <if>if <condition>(<expr>!<call><name>shouldHint</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <continue>continue;</continue></then></if>

                <comment type="line">// Schedule a local hint</comment>
                <expr_stmt><expr><call><name>submitHint</name><argument_list>(<argument><expr><name>rm</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <expr_stmt><expr><call><name>sendMessages</name><argument_list>(<argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>dcMessages</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Future</name><argument_list>&lt;<argument><name>Void</name></argument>&gt;</argument_list></name></type> <name>submitHint</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>RowMutation</name></type> <name>mutation</name></decl></param>,
                                          <param><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>target</name></decl></param>,
                                          <param><decl><type><specifier>final</specifier> <name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>,
                                          <param><decl><type><specifier>final</specifier> <name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// local write that time out should be handled by LocalMutationRunnable</comment>
        <assert>assert <expr>!<call><name><name>target</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> : <name>target</name></expr>;</assert>

        <decl_stmt><decl><type><name>HintRunnable</name></type> <name>runnable</name> <init>= <expr>new <class><super><name>HintRunnable</name></super><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Adding hint for {}"</expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>writeHintForMutation</name><argument_list>(<argument><expr><name>mutation</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Notify the handler only for CL == ANY</comment>
                <if>if <condition>(<expr><name>responseHandler</name> != null &amp;&amp; <name>consistencyLevel</name> == <name><name>ConsistencyLevel</name>.<name>ANY</name></name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>responseHandler</name>.<name>response</name></name><argument_list>(<argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <return>return <expr><call><name>submitHint</name><argument_list>(<argument><expr><name>runnable</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>Future</name><argument_list>&lt;<argument><name>Void</name></argument>&gt;</argument_list></name></type> <name>submitHint</name><parameter_list>(<param><decl><type><name>HintRunnable</name></type> <name>runnable</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>totalHintsInProgress</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>hintsInProgress</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>runnable</name>.<name>target</name></name></expr></argument>)</argument_list></call>.<call><name>incrementAndGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name><name>Future</name><argument_list>&lt;<argument><name>Void</name></argument>&gt;</argument_list></name>) <call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call>.<call><name>submit</name><argument_list>(<argument><expr><name>runnable</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>writeHintForMutation</name><parameter_list>(<param><decl><type><name>RowMutation</name></type> <name>mutation</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>target</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>UUID</name></type> <name>hostId</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call>.<call><name>getHostId</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>hostId</name> == null) &amp;&amp; (<call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>getVersion</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> &lt; <name><name>MessagingService</name>.<name>VERSION_12</name></name>)</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Unable to store hint for host with missing ID, {} (old node?)"</expr></argument>, <argument><expr><call><name><name>target</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <assert>assert <expr><name>hostId</name> != null : "Missing host ID for " + <call><name><name>target</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <decl_stmt><decl><type><name>RowMutation</name></type> <name>hintedMutation</name> <init>= <expr><call><name><name>RowMutation</name>.<name>hintFor</name></name><argument_list>(<argument><expr><name>mutation</name></expr></argument>, <argument><expr><name>hostId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>hintedMutation</name>.<name>apply</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>totalHints</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * for each datacenter, send a message to one node to relay the write to other replicas
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>sendMessages</name><parameter_list>(<param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>, <param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>MessageOut</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>dcMessages</name></decl></param>, <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>handler</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>MessageOut</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name><range>: <expr><call><name><name>dcMessages</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>isLocalDC</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>localDataCenter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>MessageOut</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>messages</name><range>: <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>asMap</name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>MessageOut</name></type> <name>message</name> <init>= <expr><call><name><name>messages</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name> <init>= <expr><call><name><name>messages</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// a single message object is used for unhinted writes, so clean out any forwards</comment>
                <comment type="line">// from previous loop iterations</comment>
                <expr_stmt><expr><name>message</name> = <call><name><name>message</name>.<name>withHeaderRemoved</name></name><argument_list>(<argument><expr><name><name>RowMutation</name>.<name>FORWARD_TO</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sendMessagesToOneDC</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>isLocalDC</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>sendMessagesToOneDC</name><parameter_list>(<param><decl><type><name>MessageOut</name></type> <name>message</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>localDC</name></decl></param>, <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>handler</name></decl></param>)</parameter_list>
    <block>{
        <try>try
        <block>{
            <expr_stmt><expr><call><name>sendMessagesToOneDCInternal</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>localDC</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>sendMessagesToOneDCInternal</name><parameter_list>(<param><decl><type><name>MessageOut</name></type> <name>message</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>localDC</name></decl></param>, <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>targets</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>target</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// direct writes to local DC or old Cassandra versions</comment>
        <if>if <condition>(<expr><name>localDC</name> || <call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>getVersion</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> &lt; <name><name>MessagingService</name>.<name>VERSION_11</name></name></expr>)</condition><then>
        <block>{
            <comment type="line">// yes, the loop and non-loop code here are the same; this is clunky but we want to avoid</comment>
            <comment type="line">// creating a second iterator since we already have a perfectly good one</comment>
            <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <expr_stmt><expr><name>target</name> = <call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <return>return;</return>
        }</block></then></if>

        <comment type="line">// Add all the other destinations of the same message as a FORWARD_HEADER entry</comment>
        <decl_stmt><decl><type><name>FastByteArrayOutputStream</name></type> <name>bos</name> <init>= <expr>new <call><name>FastByteArrayOutputStream</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DataOutputStream</name></type> <name>dos</name> <init>= <expr>new <call><name>DataOutputStream</name><argument_list>(<argument><expr><name>bos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>dos</name>.<name>writeInt</name></name><argument_list>(<argument><expr><call><name><name>targets</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>InetAddress</name></type> <name>destination</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>CompactEndpointSerializationHelper</name>.<name>serialize</name></name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>dos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>id</name> <init>= <expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>addCallback</name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><call><name><name>message</name>.<name>getTimeout</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>dos</name>.<name>writeUTF</name></name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Adding FWD message to {}@{}"</expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>message</name> = <call><name><name>message</name>.<name>withParameter</name></name><argument_list>(<argument><expr><name><name>RowMutation</name>.<name>FORWARD_TO</name></name></expr></argument>, <argument><expr><call><name><name>bos</name>.<name>toByteArray</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// send the combined message + forward headers</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>id</name> <init>= <expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Sending message to {}@{}"</expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>insertLocal</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>RowMutation</name></type> <name>rm</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"insert writing local " + <call><name><name>rm</name>.<name>toString</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr>new <class><super><name>DroppableRunnable</name></super><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>MUTATION</name></name></expr></argument>)</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{
                <expr_stmt><expr><call><name><name>rm</name>.<name>apply</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>responseHandler</name>.<name>response</name></name><argument_list>(<argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr><name>runnable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle counter mutation on the coordinator host.
     *
     * A counter mutation needs to first be applied to a replica (that we'll call the leader for the mutation) before being
     * replicated to the other endpoint. To achieve so, there is two case:
     *   1) the coordinator host is a replica: we proceed to applying the update locally and replicate throug
     *   applyCounterMutationOnCoordinator
     *   2) the coordinator is not a replica: we forward the (counter)mutation to a chosen replica (that will proceed through
     *   applyCounterMutationOnLeader upon receive) and wait for its acknowledgment.
     *
     * Implementation note: We check if we can fulfill the CL on the coordinator host even if he is not a replica to allow
     * quicker response and because the WriteResponseHandlers don't make it easy to send back an error. We also always gather
     * the write latencies at the coordinator node to make gathering point similar to the case of standard writes.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>AbstractWriteResponseHandler</name></type> <name>mutateCounter</name><parameter_list>(<param><decl><type><name>CounterMutation</name></type> <name>cm</name></decl></param>, <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>endpoint</name> <init>= <expr><call><name>findSuitableEndpoint</name><argument_list>(<argument><expr><call><name><name>cm</name>.<name>getTable</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cm</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><call><name><name>cm</name>.<name>consistency</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <return>return <expr><call><name>applyCounterMutationOnCoordinator</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// Exit now if we can't fulfill the CL here instead of forwarding to the leader replica</comment>
            <decl_stmt><decl><type><name>String</name></type> <name>table</name> <init>= <expr><call><name><name>cm</name>.<name>getTable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>rs</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Token</name></type> <name>tk</name> <init>= <expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>getToken</name><argument_list>(<argument><expr><call><name><name>cm</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>naturalEndpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getNaturalEndpoints</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>tk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>pendingEndpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call>.<call><name>pendingEndpointsFor</name><argument_list>(<argument><expr><name>tk</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>rs</name>.<name>getWriteResponseHandler</name></name><argument_list>(<argument><expr><name>naturalEndpoints</name></expr></argument>, <argument><expr><name>pendingEndpoints</name></expr></argument>, <argument><expr><call><name><name>cm</name>.<name>consistency</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>null</expr></argument>, <argument><expr><name><name>WriteType</name>.<name>COUNTER</name></name></expr></argument>)</argument_list></call>.<call><name>assureSufficientLiveNodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// Forward the actual update to the chosen leader replica</comment>
            <decl_stmt><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name> <init>= <expr>new <call><name>WriteResponseHandler</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name><name>WriteType</name>.<name>COUNTER</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"forwarding counter update of key " + <call><name><name>ByteBufferUtil</name>.<name>bytesToHex</name></name><argument_list>(<argument><expr><call><name><name>cm</name>.<name>key</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> + " to " + <name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><call><name><name>cm</name>.<name>makeMutationMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>responseHandler</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Find a suitable replica as leader for counter update.
     * For now, we pick a random replica in the local DC (or ask the snitch if
     * there is no replica alive in the local DC).
     * TODO: if we track the latency of the counter writes (which makes sense
     * contrarily to standard writes since there is a read involved), we could
     * trust the dynamic snitch entirely, which may be a better solution. It
     * is unclear we want to mix those latencies with read latencies, so this
     * may be a bit involved.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>InetAddress</name></type> <name>findSuitableEndpoint</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>, <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>cl</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getLiveNaturalEndpoints</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>endpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <comment type="line">// TODO have a way to compute the consistency level</comment>
            <throw>throw <expr>new <call><name>UnavailableException</name><argument_list>(<argument><expr><name>cl</name></expr></argument>, <argument><expr><call><name><name>cl</name>.<name>blockFor</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>localEndpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>endpoints</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>snitch</name>.<name>getDatacenter</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>localDataCenter</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>localEndpoints</name>.<name>add</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
        <if>if <condition>(<expr><call><name><name>localEndpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// No endpoint in local DC, pick the closest endpoint according to the snitch</comment>
            <expr_stmt><expr><call><name><name>snitch</name>.<name>sortByProximity</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>endpoints</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <return>return <expr><call><name><name>localEndpoints</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>threadLocalRandom</name></name><argument_list>()</argument_list></call>.<call><name>nextInt</name><argument_list>(<argument><expr><call><name><name>localEndpoints</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="line">// Must be called on a replica of the mutation. This replica becomes the</comment>
    <comment type="line">// leader of this mutation.</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>AbstractWriteResponseHandler</name></type> <name>applyCounterMutationOnLeader</name><parameter_list>(<param><decl><type><name>CounterMutation</name></type> <name>cm</name></decl></param>, <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>, <param><decl><type><name>Runnable</name></type> <name>callback</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name>performWrite</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><call><name><name>cm</name>.<name>consistency</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>counterWritePerformer</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name><name>WriteType</name>.<name>COUNTER</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// Same as applyCounterMutationOnLeader but must with the difference that it use the MUTATION stage to execute the write (while</comment>
    <comment type="line">// applyCounterMutationOnLeader assumes it is on the MUTATION stage already)</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>AbstractWriteResponseHandler</name></type> <name>applyCounterMutationOnCoordinator</name><parameter_list>(<param><decl><type><name>CounterMutation</name></type> <name>cm</name></decl></param>, <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name>performWrite</name><argument_list>(<argument><expr><name>cm</name></expr></argument>, <argument><expr><call><name><name>cm</name>.<name>consistency</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>counterWriteOnCoordinatorPerformer</name></expr></argument>, <argument><expr>null</expr></argument>, <argument><expr><name><name>WriteType</name>.<name>COUNTER</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Runnable</name></type> <name>counterWriteTask</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>IMutation</name></type> <name>mutation</name></decl></param>,
                                             <param><decl><type><specifier>final</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>,
                                             <param><decl><type><specifier>final</specifier> <name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>,
                                             <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>localDataCenter</name></decl></param>,
                                             <param><decl><type><specifier>final</specifier> <name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr>new <class><super><name>LocalMutationRunnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{
                <assert>assert <expr><name>mutation</name> instanceof <name>CounterMutation</name></expr>;</assert>
                <decl_stmt><decl><type><specifier>final</specifier> <name>CounterMutation</name></type> <name>cm</name> <init>= <expr>(<name>CounterMutation</name>) <name>mutation</name></expr></init></decl>;</decl_stmt>

                <comment type="line">// apply mutation</comment>
                <expr_stmt><expr><call><name><name>cm</name>.<name>apply</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>responseHandler</name>.<name>response</name></name><argument_list>(<argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// then send to replicas, if any</comment>
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>remotes</name> <init>= <expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><name>targets</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>ImmutableSet</name>.<name>of</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>cm</name>.<name>shouldReplicateOnWrite</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>remotes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// We do the replication on another stage because it involves a read (see CM.makeReplicationMutation)</comment>
                    <comment type="line">// and we want to avoid blocking too much the MUTATION stage</comment>
                    <expr_stmt><expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>REPLICATE_ON_WRITE</name></name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr>new <class><super><name>DroppableRunnable</name></super><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>READ</name></name></expr></argument>)</argument_list>
                    <block>{
                        <function><type><specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument></throws>
                        <block>{
                            <comment type="line">// send mutation to other replica</comment>
                            <expr_stmt><expr><call><name>sendToHintedEndpoints</name><argument_list>(<argument><expr><call><name><name>cm</name>.<name>makeReplicationMutation</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>remotes</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></function>
                    }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>systemTableQuery</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>cmds</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>ReadCommand</name></type> <name>cmd</name> <range>: <expr><name>cmds</name></expr></range></decl></init>)
            <if>if <condition>(<expr>!<call><name><name>cmd</name>.<name>table</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_KS</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Performs the actual reading of a row out of the StorageService, fetching
     * a specific set of column names from a given column family.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>read</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>commands</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>IsBootstrappingException</name></expr></argument>, <argument><expr><name>ReadTimeoutException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>StorageService</name>.<name>instance</name>.<name>isBootstrapMode</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name>systemTableQuery</name><argument_list>(<argument><expr><name>commands</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>readMetrics</name>.<name>unavailables</name>.<name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>readUnavailables</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>IsBootstrappingException</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></then></if>
        <decl_stmt><decl><type><name>long</name></type> <name>startTime</name> <init>= <expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>rows</name> = <call><name>fetchRows</name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>UnavailableException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>readMetrics</name>.<name>unavailables</name>.<name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>readUnavailables</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>ReadTimeoutException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>readMetrics</name>.<name>timeouts</name>.<name>mark</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>ClientRequestMetrics</name>.<name>readTimeouts</name>.<name>inc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        }</block></catch>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>readMetrics</name>.<name>addNano</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call> - <name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
        <return>return <expr><name>rows</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This function executes local and remote reads, and blocks for the results:
     *
     * 1. Get the replica locations, sorted by response time according to the snitch
     * 2. Send a data request to the closest replica, and digest requests to either
     *    a) all the replicas, if read repair is enabled
     *    b) the closest R-1 replicas, where R is the number required to satisfy the ConsistencyLevel
     * 3. Wait for a response from R replicas
     * 4. If the digests (if any) match the data return the data
     * 5. else carry out read repair by getting data from all the nodes.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>fetchRows</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>initialCommands</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>ReadTimeoutException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>initialCommands</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>commandsToRetry</name> <init>= <expr><call><name><name>Collections</name>.<name>emptyList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <do>do
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>commands</name> <init>= <expr><call><name><name>commandsToRetry</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> ? <name>initialCommands</name> : <name>commandsToRetry</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name><index>[]</index></type> <name>readCallbacks</name> <init>= <expr>new <name><name>ReadCallback</name><index>[<expr><call><name><name>commands</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<call><name><name>commandsToRetry</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Retrying {} commands"</expr></argument>, <argument><expr><call><name><name>commandsToRetry</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <comment type="line">// send out read requests</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>commands</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name>ReadCommand</name></type> <name>command</name> <init>= <expr><call><name><name>commands</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><call><name><name>command</name>.<name>getKeyspace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <assert>assert <expr>!<call><name><name>command</name>.<name>isDigestQuery</name></name><argument_list>()</argument_list></call></expr>;</assert>
                <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Command/ConsistencyLevel is {}/{}"</expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name>getLiveSortedEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>command</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CFMetaData</name></type> <name>cfm</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getCFMetaData</name></name><argument_list>(<argument><expr><call><name><name>command</name>.<name>getKeyspace</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>command</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>endpoints</name> = <call><name><name>consistency_level</name>.<name>filterForQuery</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>, <argument><expr><call><name><name>cfm</name>.<name>newReadRepairDecision</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name>RowDigestResolver</name></type> <name>resolver</name> <init>= <expr>new <call><name>RowDigestResolver</name><argument_list>(<argument><expr><name><name>command</name>.<name>table</name></name></expr></argument>, <argument><expr><name><name>command</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>handler</name> <init>= <expr>new <call><name>ReadCallback</name><argument_list>(<argument><expr><name>resolver</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>, <argument><expr><name>command</name></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>handler</name>.<name>assureSufficientLiveNodes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <assert>assert <expr>!<call><name><name>endpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert>
                <expr_stmt><expr><name><name>readCallbacks</name><index>[<expr><name>i</name></expr>]</index></name> = <name>handler</name></expr>;</expr_stmt>

                <comment type="line">// The data-request message is sent to dataPoint, the node that will actually get the data for us</comment>
                <decl_stmt><decl><type><name>InetAddress</name></type> <name>dataPoint</name> <init>= <expr><call><name><name>endpoints</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>dataPoint</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; <name>OPTIMIZE_LOCAL_REQUESTS</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"reading data locally"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>READ</name></name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr>new <call><name>LocalReadRunnable</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"reading data from {}"</expr></argument>, <argument><expr><name>dataPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><call><name><name>command</name>.<name>createMessage</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>dataPoint</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

                <if>if <condition>(<expr><call><name><name>endpoints</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
                    <continue>continue;</continue></then></if>

                <comment type="line">// send the other endpoints a digest request</comment>
                <decl_stmt><decl><type><name>ReadCommand</name></type> <name>digestCommand</name> <init>= <expr><call><name><name>command</name>.<name>copy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>digestCommand</name>.<name>setDigestQuery</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>MessageOut</name></type> <name>message</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>InetAddress</name></type> <name>digestPoint</name> <range>: <expr><call><name><name>endpoints</name>.<name>subList</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name><name>endpoints</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>digestPoint</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; <name>OPTIMIZE_LOCAL_REQUESTS</name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"reading digest locally"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>READ</name></name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr>new <call><name>LocalReadRunnable</name><argument_list>(<argument><expr><name>digestCommand</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"reading digest from {}"</expr></argument>, <argument><expr><name>digestPoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">// (We lazy-construct the digest Message object since it may not be necessary if we</comment>
                        <comment type="line">// are doing a local digest read, or no digest reads at all.)</comment>
                        <if>if <condition>(<expr><name>message</name> == null</expr>)</condition><then>
                            <expr_stmt><expr><name>message</name> = <call><name><name>digestCommand</name>.<name>createMessage</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>digestPoint</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></for>
            }</block></for>

            <comment type="line">// read results and make a second pass for any digest mismatches</comment>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>repairCommands</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>repairResponseHandlers</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>commands</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>handler</name> <init>= <expr><name><name>readCallbacks</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ReadCommand</name></type> <name>command</name> <init>= <expr><call><name><name>commands</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <try>try
                <block>{
                    <decl_stmt><decl><type><name>Row</name></type> <name>row</name> <init>= <expr><call><name><name>handler</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>row</name> != null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>command</name>.<name>maybeTrim</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>rows</name>.<name>add</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>ReadTimeoutException</name></type> <name>ex</name></decl></param>)</parameter_list>
                <block>{
                    <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Read timeout: {}"</expr></argument>, <argument><expr><call><name><name>ex</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <throw>throw <expr><name>ex</name></expr>;</throw>
                }</block></catch>
                <catch>catch <parameter_list>(<param><decl><type><name>DigestMismatchException</name></type> <name>ex</name></decl></param>)</parameter_list>
                <block>{
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Digest mismatch: {}"</expr></argument>, <argument><expr><call><name><name>ex</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// Do a full data read to resolve the correct response (and repair node that need be)</comment>
                    <decl_stmt><decl><type><name>RowDataResolver</name></type> <name>resolver</name> <init>= <expr>new <call><name>RowDataResolver</name><argument_list>(<argument><expr><name><name>command</name>.<name>table</name></name></expr></argument>, <argument><expr><name><name>command</name>.<name>key</name></name></expr></argument>, <argument><expr><call><name><name>command</name>.<name>filter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>repairHandler</name> <init>= <expr><call><name><name>handler</name>.<name>withNewResolver</name></name><argument_list>(<argument><expr><name>resolver</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><name>repairCommands</name> == null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>repairCommands</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>repairResponseHandlers</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>repairCommands</name>.<name>add</name></name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>repairResponseHandlers</name>.<name>add</name></name><argument_list>(<argument><expr><name>repairHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name><name>handler</name>.<name>endpoints</name></name></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>MessageOut</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>message</name> <init>= <expr><call><name><name>command</name>.<name>createMessage</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>repairHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                }</block></catch></try>
            }</block></for>

            <if>if <condition>(<expr><name>commandsToRetry</name> != <name><name>Collections</name>.<name>EMPTY_LIST</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>commandsToRetry</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

            <comment type="line">// read the results for the digest mismatch retries</comment>
            <if>if <condition>(<expr><name>repairResponseHandlers</name> != null</expr>)</condition><then>
            <block>{
                <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>repairCommands</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <block>{
                    <decl_stmt><decl><type><name>ReadCommand</name></type> <name>command</name> <init>= <expr><call><name><name>repairCommands</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>handler</name> <init>= <expr><call><name><name>repairResponseHandlers</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>Row</name></type> <name>row</name></decl>;</decl_stmt>
                    <try>try
                    <block>{
                        <expr_stmt><expr><name>row</name> = <call><name><name>handler</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>DigestMismatchException</name></type> <name>e</name></decl></param>)</parameter_list>
                    <block>{
                        <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// full data requested from each node here, no digests should be sent</comment>
                    }</block></catch></try>

                    <decl_stmt><decl><type><name>RowDataResolver</name></type> <name>resolver</name> <init>= <expr>(<name>RowDataResolver</name>)<name><name>handler</name>.<name>resolver</name></name></expr></init></decl>;</decl_stmt>
                    <try>try
                    <block>{
                        <comment type="line">// wait for the repair writes to be acknowledged, to minimize impact on any replica that's</comment>
                        <comment type="line">// behind on writes in case the out-of-sync row is read multiple times in quick succession</comment>
                        <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>waitOnFutures</name></name><argument_list>(<argument><expr><name><name>resolver</name>.<name>repairResults</name></name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getWriteRpcTimeout</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>TimeoutException</name></type> <name>e</name></decl></param>)</parameter_list>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>blockFor</name> <init>= <expr><call><name><name>consistency_level</name>.<name>blockFor</name></name><argument_list>(<argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><call><name><name>command</name>.<name>getKeyspace</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <throw>throw <expr>new <call><name>ReadTimeoutException</name><argument_list>(<argument><expr><name>consistency_level</name></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>

                    <comment type="line">// retry any potential short reads</comment>
                    <decl_stmt><decl><type><name>ReadCommand</name></type> <name>retryCommand</name> <init>= <expr><call><name><name>command</name>.<name>maybeGenerateRetryCommand</name></name><argument_list>(<argument><expr><name>resolver</name></expr></argument>, <argument><expr><name>row</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>retryCommand</name> != null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Issuing retry for read command"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>commandsToRetry</name> == <name><name>Collections</name>.<name>EMPTY_LIST</name></name></expr>)</condition><then>
                            <expr_stmt><expr><name>commandsToRetry</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                        <expr_stmt><expr><call><name><name>commandsToRetry</name>.<name>add</name></name><argument_list>(<argument><expr><name>retryCommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>row</name> != null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>command</name>.<name>maybeTrim</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>rows</name>.<name>add</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>
        }</block> while <condition>(<expr>!<call><name><name>commandsToRetry</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>;</do>

        <return>return <expr><name>rows</name></expr>;</return>
    }</block></function>

    <class><specifier>static</specifier> class <name>LocalReadRunnable</name> <super><extends>extends <name>DroppableRunnable</name></extends></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ReadCommand</name></type> <name>command</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>handler</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><name>LocalReadRunnable</name><parameter_list>(<param><decl><type><name>ReadCommand</name></type> <name>command</name></decl></param>, <param><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>ReadResponse</name></argument>, <argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>handler</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>READ</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>command</name></name> = <name>command</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>handler</name></name> = <name>handler</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"LocalReadRunnable reading {}"</expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name><name>command</name>.<name>table</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Row</name></type> <name>r</name> <init>= <expr><call><name><name>command</name>.<name>getRow</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ReadResponse</name></type> <name>result</name> <init>= <expr><call><name><name>ReadVerbHandler</name>.<name>getResponse</name></name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>addLatency</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>handler</name>.<name>response</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <class><specifier>static</specifier> class <name>LocalRangeSliceRunnable</name> <super><extends>extends <name>DroppableRunnable</name></extends></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>RangeSliceCommand</name></type> <name>command</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>ReadCallback</name><argument_list>&lt;<argument><name>RangeSliceReply</name></argument>, <argument><name><name>Iterable</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>handler</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <constructor><name>LocalRangeSliceRunnable</name><parameter_list>(<param><decl><type><name>RangeSliceCommand</name></type> <name>command</name></decl></param>, <param><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>RangeSliceReply</name></argument>, <argument><name><name>Iterable</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>handler</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>READ</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>command</name></name> = <name>command</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>handler</name></name> = <name>handler</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"LocalReadRunnable reading {}"</expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>RangeSliceReply</name></type> <name>result</name> <init>= <expr>new <call><name>RangeSliceReply</name><argument_list>(<argument><expr><call><name><name>RangeSliceVerbHandler</name>.<name>executeLocally</name></name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>addLatency</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>handler</name>.<name>response</name></name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getLiveSortedEndpoints</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getLiveSortedEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>decorateKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getLiveSortedEndpoints</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>, <param><decl><type><name>RingPosition</name></type> <name>pos</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>liveEndpoints</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getLiveNaturalEndpoints</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>sortByProximity</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>liveEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>liveEndpoints</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>intersection</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>l1</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>l2</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// Note: we don't use Guava Sets.intersection() for 3 reasons:</comment>
        <comment type="line">//   1) retainAll would be inefficient if l1 and l2 are large but in practice both are the replicas for a range and</comment>
        <comment type="line">//   so will be very small (&lt; RF). In that case, retainAll is in fact more efficient.</comment>
        <comment type="line">//   2) we do ultimately need a list so converting everything to sets don't make sense</comment>
        <comment type="line">//   3) l1 and l2 are sorted by proximity. The use of retainAll  maintain that sorting in the result, while using sets wouldn't.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>inter</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>l1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>inter</name>.<name>retainAll</name></name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>inter</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>getRangeSlice</name><parameter_list>(<param><decl><type><name>RangeSliceCommand</name></type> <name>command</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>ReadTimeoutException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>Tracing</name>.<name>trace</name></name><argument_list>(<argument><expr>"Determining replicas to query"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Command/ConsistencyLevel is {}/{}"</expr></argument>, <argument><expr><call><name><name>command</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>startTime</name> <init>= <expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name><name>command</name>.<name>keyspace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl>;</decl_stmt>
        <comment type="line">// now scan until we have enough results</comment>
        <try>try
        <block>{
            <decl_stmt><decl><type><name>IDiskAtomFilter</name></type> <name>commandPredicate</name> <init>= <expr><name><name>command</name>.<name>predicate</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>cql3RowCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>rows</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name>getRestrictedRanges</name><argument_list>(<argument><expr><name><name>command</name>.<name>range</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>nextRange</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>nextEndpoints</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>nextFilteredEndpoints</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>i</name> &lt; <call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><name>nextRange</name> == null
                                                  ? <call><name><name>ranges</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>
                                                  : <name>nextRange</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>liveEndpoints</name> <init>= <expr><name>nextEndpoints</name> == null
                                                ? <call><name>getLiveSortedEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call>
                                                : <name>nextEndpoints</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>filteredEndpoints</name> <init>= <expr><name>nextFilteredEndpoints</name> == null
                                                    ? <call><name><name>consistency_level</name>.<name>filterForQuery</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>liveEndpoints</name></expr></argument>)</argument_list></call>
                                                    : <name>nextFilteredEndpoints</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>

                <comment type="line">// getRestrictedRange has broken the queried range into per-[vnode] token ranges, but this doesn't take</comment>
                <comment type="line">// the replication factor into account. If the intersection of live endpoints for 2 consecutive ranges</comment>
                <comment type="line">// still meets the CL requirements, then we can merge both ranges into the same RangeSliceCommand.</comment>
                <while>while <condition>(<expr><name>i</name> &lt; <call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{
                    <expr_stmt><expr><name>nextRange</name> = <call><name><name>ranges</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nextEndpoints</name> = <call><name>getLiveSortedEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>nextRange</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nextFilteredEndpoints</name> = <call><name><name>consistency_level</name>.<name>filterForQuery</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>nextEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/*
                     * If the current range right is the min token, we should stop merging because CFS.getRangeSlice
                     * don't know how to deal with a wrapping range.
                     * Note: it would be slightly more efficient to have CFS.getRangeSlice on the destination nodes unwraps
                     * the range if necessary and deal with it. However, we can't start sending wrapped range without breaking
                     * wire compatibility, so It's likely easier not to bother;
                     */</comment>
                    <if>if <condition>(<expr><call><name><name>range</name>.<name>right</name>.<name>isMinimum</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <break>break;</break></then></if>

                    <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>merged</name> <init>= <expr><call><name>intersection</name><argument_list>(<argument><expr><name>liveEndpoints</name></expr></argument>, <argument><expr><name>nextEndpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Check if there is enough endpoint for the merge to be possible.</comment>
                    <if>if <condition>(<expr>!<call><name><name>consistency_level</name>.<name>isSufficientLiveNodes</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>merged</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <break>break;</break></then></if>

                    <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>filteredMerged</name> <init>= <expr><call><name><name>consistency_level</name>.<name>filterForQuery</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>merged</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// Estimate whether merging will be a win or not</comment>
                    <if>if <condition>(<expr>!<call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>isWorthMergingForRangeQuery</name><argument_list>(<argument><expr><name>filteredMerged</name></expr></argument>, <argument><expr><name>filteredEndpoints</name></expr></argument>, <argument><expr><name>nextFilteredEndpoints</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <break>break;</break></then></if>

                    <comment type="line">// If we get there, merge this range and the next one</comment>
                    <expr_stmt><expr><name>range</name> = <call><name><name>range</name>.<name>withNewRight</name></name><argument_list>(<argument><expr><name><name>nextRange</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>liveEndpoints</name> = <name>merged</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>filteredEndpoints</name> = <name>filteredMerged</name></expr>;</expr_stmt>
                    <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
                }</block></while>

                <decl_stmt><decl><type><name>RangeSliceCommand</name></type> <name>nodeCmd</name> <init>= <expr>new <call><name>RangeSliceCommand</name><argument_list>(<argument><expr><name><name>command</name>.<name>keyspace</name></name></expr></argument>,
                                                                  <argument><expr><name><name>command</name>.<name>column_family</name></name></expr></argument>,
                                                                  <argument><expr><name><name>command</name>.<name>super_column</name></name></expr></argument>,
                                                                  <argument><expr><name>commandPredicate</name></expr></argument>,
                                                                  <argument><expr><name>range</name></expr></argument>,
                                                                  <argument><expr><name><name>command</name>.<name>row_filter</name></name></expr></argument>,
                                                                  <argument><expr><name><name>command</name>.<name>maxResults</name></name></expr></argument>,
                                                                  <argument><expr><name><name>command</name>.<name>countCQL3Rows</name></name></expr></argument>,
                                                                  <argument><expr><name><name>command</name>.<name>isPaging</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// collect replies and resolve according to consistency level</comment>
                <decl_stmt><decl><type><name>RangeSliceResponseResolver</name></type> <name>resolver</name> <init>= <expr>new <call><name>RangeSliceResponseResolver</name><argument_list>(<argument><expr><name><name>nodeCmd</name>.<name>keyspace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>ReadCallback</name><argument_list>&lt;<argument><name>RangeSliceReply</name></argument>, <argument><name><name>Iterable</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>handler</name> <init>= <expr>new <call><name>ReadCallback</name><argument_list>(<argument><expr><name>resolver</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>, <argument><expr><name>nodeCmd</name></expr></argument>, <argument><expr><name>filteredEndpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>handler</name>.<name>assureSufficientLiveNodes</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>resolver</name>.<name>setSources</name></name><argument_list>(<argument><expr><name>filteredEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>filteredEndpoints</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1
                    &amp;&amp; <call><name><name>filteredEndpoints</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                    &amp;&amp; <name>OPTIMIZE_LOCAL_REQUESTS</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"reading data locally"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>READ</name></name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr>new <call><name>LocalRangeSliceRunnable</name><argument_list>(<argument><expr><name>nodeCmd</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <decl_stmt><decl><type><name><name>MessageOut</name><argument_list>&lt;<argument><name>RangeSliceCommand</name></argument>&gt;</argument_list></name></type> <name>message</name> <init>= <expr><call><name><name>nodeCmd</name>.<name>createMessage</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>filteredEndpoints</name></expr></range></decl></init>)
                    <block>{
                        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"reading {} from {}"</expr></argument>, <argument><expr><name>nodeCmd</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                }</block></else></if>

                <try>try
                <block>{
                    <for>for (<init><decl><type><name>Row</name></type> <name>row</name> <range>: <expr><call><name><name>handler</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <block>{
                        <expr_stmt><expr><call><name><name>rows</name>.<name>add</name></name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name><name>nodeCmd</name>.<name>countCQL3Rows</name></name></expr>)</condition><then>
                            <expr_stmt><expr><name>cql3RowCount</name> += <call><name><name>row</name>.<name>getLiveCount</name></name><argument_list>(<argument><expr><name>commandPredicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"range slices read {}"</expr></argument>, <argument><expr><name><name>row</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                    <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>waitOnFutures</name></name><argument_list>(<argument><expr><name><name>resolver</name>.<name>repairResults</name></name></expr></argument>, <argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getWriteRpcTimeout</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>TimeoutException</name></type> <name>ex</name></decl></param>)</parameter_list>
                <block>{
                    <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Range slice timeout: {}"</expr></argument>, <argument><expr><call><name><name>ex</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="line">// We actually got all response at that point</comment>
                    <decl_stmt><decl><type><name>int</name></type> <name>blockFor</name> <init>= <expr><call><name><name>consistency_level</name>.<name>blockFor</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <throw>throw <expr>new <call><name>ReadTimeoutException</name><argument_list>(<argument><expr><name>consistency_level</name></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr><name>blockFor</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch>
                <catch>catch <parameter_list>(<param><decl><type><name>DigestMismatchException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw> <comment type="line">// no digests in range slices yet</comment>
                }</block></catch></try>

                <comment type="line">// if we're done, great, otherwise, move to the next range</comment>
                <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name><name>nodeCmd</name>.<name>countCQL3Rows</name></name> ? <name>cql3RowCount</name> : <call><name><name>rows</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>count</name> &gt;= <name><name>nodeCmd</name>.<name>maxResults</name></name></expr>)</condition><then>
                    <break>break;</break></then></if>

                <comment type="line">// if we are paging and already got some rows, reset the column filter predicate,</comment>
                <comment type="line">// so we start iterating the next row from the first column</comment>
                <if>if <condition>(<expr>!<call><name><name>rows</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>command</name>.<name>isPaging</name></name></expr>)</condition><then>
                <block>{
                    <comment type="line">// We only allow paging with a slice filter (doesn't make sense otherwise anyway)</comment>
                    <assert>assert <expr><name>commandPredicate</name> instanceof <name>SliceQueryFilter</name></expr>;</assert>
                    <expr_stmt><expr><name>commandPredicate</name> = ((<name>SliceQueryFilter</name>)<name>commandPredicate</name>).<call><name>withUpdatedSlices</name><argument_list>(<argument><expr><name><name>ColumnSlice</name>.<name>ALL_COLUMNS_ARRAY</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></while>
        }</block>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>rangeMetrics</name>.<name>addNano</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call> - <name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
        <return>return <expr><call><name>trim</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>trim</name><parameter_list>(<param><decl><type><name>RangeSliceCommand</name></type> <name>command</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// When countCQL3Rows, we let the caller trim the result.</comment>
        <if>if <condition>(<expr><name><name>command</name>.<name>countCQL3Rows</name></name></expr>)</condition><then>
            <return>return <expr><name>rows</name></expr>;</return></then>
        <else>else
            <return>return <expr><call><name><name>rows</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; <name><name>command</name>.<name>maxResults</name></name> ? <call><name><name>rows</name>.<name>subList</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>command</name>.<name>maxResults</name></name></expr></argument>)</argument_list></call> : <name>rows</name></expr>;</return></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * initiate a request/response session with each live node to check whether or not everybody is using the same
     * migration id. This is useful for determining if a schema change has propagated through the cluster. Disagreement
     * is assumed if any node fails to respond.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>describeSchemaVersions</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>myVersion</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>versions</name> <init>= <expr>new <call><name><name>ConcurrentHashMap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>UUID</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>liveHosts</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name> <init>= <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr><call><name><name>liveHosts</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>IAsyncCallback</name><argument_list>&lt;<argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>cb</name> <init>= <expr>new <class><super><name><name>IAsyncCallback</name><argument_list>&lt;<argument><name>UUID</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>response</name><parameter_list>(<param><decl><type><name><name>MessageIn</name><argument_list>&lt;<argument><name>UUID</name></argument>&gt;</argument_list></name></type> <name>message</name></decl></param>)</parameter_list>
            <block>{
                <comment type="line">// record the response from the remote node.</comment>
                <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Received schema check response from {}"</expr></argument>, <argument><expr><call><name><name>message</name>.<name>from</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>versions</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>message</name>.<name>from</name></name></expr></argument>, <argument><expr><name><name>message</name>.<name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></function>

            <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isLatencyForSnitch</name><parameter_list>()</parameter_list>
            <block>{
                <return>return <expr>false</expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>
        <comment type="line">// an empty message acts as a request to the SchemaCheckVerbHandler.</comment>
        <decl_stmt><decl><type><name>MessageOut</name></type> <name>message</name> <init>= <expr>new <call><name>MessageOut</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>SCHEMA_CHECK</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>liveHosts</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <try>try
        <block>{
            <comment type="line">// wait for as long as possible. timeout-1s if possible.</comment>
            <expr_stmt><expr><call><name><name>latch</name>.<name>await</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcTimeout</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>ex</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr>"This latch shouldn't have been interrupted."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"My version is {}"</expr></argument>, <argument><expr><name>myVersion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// maps versions to hosts that are on that version.</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>results</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>allHosts</name> <init>= <expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getUnreachableMembers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>host</name> <range>: <expr><name>allHosts</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>UUID</name></type> <name>version</name> <init>= <expr><call><name><name>versions</name>.<name>get</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>stringVersion</name> <init>= <expr><name>version</name> == null ? <name>UNREACHABLE</name> : <call><name><name>version</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>hosts</name> <init>= <expr><call><name><name>results</name>.<name>get</name></name><argument_list>(<argument><expr><name>stringVersion</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>hosts</name> == null</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>hosts</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>results</name>.<name>put</name></name><argument_list>(<argument><expr><name>stringVersion</name></expr></argument>, <argument><expr><name>hosts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>hosts</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>host</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="line">// we're done: the results map is ready to return to the client.  the rest is just debug logging:</comment>
        <if>if <condition>(<expr><call><name><name>results</name>.<name>get</name></name><argument_list>(<argument><expr><name>UNREACHABLE</name></expr></argument>)</argument_list></call> != null</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Hosts not in agreement. Didn't get a response from everybody: {}"</expr></argument>, <argument><expr><call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><call><name><name>results</name>.<name>get</name></name><argument_list>(<argument><expr><name>UNREACHABLE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>results</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <comment type="line">// check for version disagreement. log the hosts that don't agree.</comment>
            <if>if <condition>(<expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>UNREACHABLE</name></expr></argument>)</argument_list></call> || <call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>myVersion</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <for>for (<init><decl><type><name>String</name></type> <name>host</name> <range>: <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"{} disagrees ({})"</expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></for>
        <if>if <condition>(<expr><call><name><name>results</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Schemas are in agreement."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <return>return <expr><name>results</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Compute all ranges we're going to query, in sorted order. Nodes can be replica destinations for many ranges,
     * so we need to restrict each scan to the specific range we want, or else we'd get duplicate results.
     */</comment>
    <function><type><specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name><name>List</name><argument_list>&lt;<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRestrictedRanges</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>queryRange</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// special case for bounds containing exactly 1 (non-minimum) token</comment>
        <if>if <condition>(<expr><name>queryRange</name> instanceof <name>Bounds</name> &amp;&amp; <call><name><name>queryRange</name>.<name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>queryRange</name>.<name>right</name></name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>queryRange</name>.<name>left</name>.<name>isMinimum</name></name><argument_list>(<argument><expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"restricted single token match for query {}"</expr></argument>, <argument><expr><name>queryRange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><name>queryRange</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>tokenMetadata</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getTokenMetadata</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// divide the queryRange into pieces delimited by the ring and minimum tokens</comment>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>ringIter</name> <init>= <expr><call><name><name>TokenMetadata</name>.<name>ringIterator</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>queryRange</name>.<name>left</name>.<name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>remainder</name> <init>= <expr><name>queryRange</name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>ringIter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <comment type="block">/*
             * remainder can be a range/bounds of token _or_ keys and we want to split it with a token:
             *   - if remainder is tokens, then we'll just split using the provided token.
             *   - if remainder is keys, we want to split using token.upperBoundKey. For instance, if remainder
             *     is [DK(10, 'foo'), DK(20, 'bar')], and we have 3 nodes with tokens 0, 15, 30. We want to
             *     split remainder to A=[DK(10, 'foo'), 15] and B=(15, DK(20, 'bar')]. But since we can't mix
             *     tokens and keys at the same time in a range, we uses 15.upperBoundKey() to have A include all
             *     keys having 15 as token and B include none of those (since that is what our node owns).
             * asSplitValue() abstracts that choice.
             */</comment>
            <decl_stmt><decl><type><name>Token</name></type> <name>upperBoundToken</name> <init>= <expr><call><name><name>ringIter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>T</name></type> <name>upperBound</name> <init>= <expr>(<name>T</name>)<call><name><name>upperBoundToken</name>.<name>upperBound</name></name><argument_list>(<argument><expr><call><name><name>queryRange</name>.<name>left</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>remainder</name>.<name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name>upperBound</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name><name>remainder</name>.<name>contains</name></name><argument_list>(<argument><expr><name>upperBound</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <comment type="line">// no more splits</comment>
                <break>break;</break></then></if>
            <decl_stmt><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>,<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>splits</name> <init>= <expr><call><name><name>remainder</name>.<name>split</name></name><argument_list>(<argument><expr><name>upperBound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>splits</name> == null</expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>splits</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remainder</name> = <name><name>splits</name>.<name>right</name></name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"restricted ranges for query {} are {}"</expr></argument>, <argument><expr><name>queryRange</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <return>return <expr><name>ranges</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getReadOperations</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readMetrics</name>.<name>latency</name>.<name>count</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalReadLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readMetrics</name>.<name>totalLatency</name>.<name>count</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getRecentReadLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readMetrics</name>.<name>getRecentLatency</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getTotalReadLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readMetrics</name>.<name>totalLatencyHistogram</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getRecentReadLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readMetrics</name>.<name>recentLatencyHistogram</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getRangeOperations</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>rangeMetrics</name>.<name>latency</name>.<name>count</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalRangeLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>rangeMetrics</name>.<name>totalLatency</name>.<name>count</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getRecentRangeLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>rangeMetrics</name>.<name>getRecentLatency</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getTotalRangeLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>rangeMetrics</name>.<name>totalLatencyHistogram</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getRecentRangeLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>rangeMetrics</name>.<name>recentLatencyHistogram</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getWriteOperations</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeMetrics</name>.<name>latency</name>.<name>count</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalWriteLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeMetrics</name>.<name>totalLatency</name>.<name>count</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getRecentWriteLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeMetrics</name>.<name>getRecentLatency</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getTotalWriteLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeMetrics</name>.<name>totalLatencyHistogram</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getRecentWriteLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeMetrics</name>.<name>recentLatencyHistogram</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>getHintedHandoffEnabled</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>hintedHandoffEnabled</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setHintedHandoffEnabled</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>b</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setHintedHandoffEnabled</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaxHintWindow</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getMaxHintWindow</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaxHintWindow</name><parameter_list>(<param><decl><type><name>int</name></type> <name>ms</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setMaxHintWindow</name></name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>shouldHint</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>DatabaseDescriptor</name>.<name>hintedHandoffEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <decl_stmt><decl><type><name>boolean</name></type> <name>hintWindowExpired</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointDowntime</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call> &gt; <call><name><name>DatabaseDescriptor</name>.<name>getMaxHintWindow</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>hintWindowExpired</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"not hinting {} which has been down {}ms"</expr></argument>, <argument><expr><name>ep</name></expr></argument>, <argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointDowntime</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>!<name>hintWindowExpired</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Performs the truncate operatoin, which effectively deletes all data from
     * the column family cfname
     * @param keyspace
     * @param cfname
     * @throws UnavailableException If some of the hosts in the ring are down.
     * @throws TimeoutException
     * @throws IOException
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>truncateBlocking</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfname</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>TimeoutException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Starting a blocking truncate operation on keyspace {}, CF "</expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>cfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>isAnyHostDown</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Cannot perform truncate, some hosts are down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// Since the truncate operation is so aggressive and is typically only</comment>
            <comment type="line">// invoked by an admin, for simplicity we require that all nodes are up</comment>
            <comment type="line">// to perform the operation.</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>liveMembers</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <throw>throw <expr>new <call><name>UnavailableException</name><argument_list>(<argument><expr><name><name>ConsistencyLevel</name>.<name>ALL</name></name></expr></argument>, <argument><expr><name>liveMembers</name> + <call><name><name>Gossiper</name>.<name>instance</name>.<name>getUnreachableMembers</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>liveMembers</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>allEndpoints</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>blockFor</name> <init>= <expr><call><name><name>allEndpoints</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>TruncateResponseHandler</name></type> <name>responseHandler</name> <init>= <expr>new <call><name>TruncateResponseHandler</name><argument_list>(<argument><expr><name>blockFor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Send out the truncate calls and track the responses with the callbacks.</comment>
        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Starting to send truncate messages to hosts {}"</expr></argument>, <argument><expr><name>allEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>Truncation</name></type> <name>truncation</name> <init>= <expr>new <call><name>Truncation</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>cfname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>MessageOut</name><argument_list>&lt;<argument><name>Truncation</name></argument>&gt;</argument_list></name></type> <name>message</name> <init>= <expr><call><name><name>truncation</name>.<name>createMessage</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>allEndpoints</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <comment type="line">// Wait for all</comment>
        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Sent all truncate messages, now waiting for {} responses"</expr></argument>, <argument><expr><name>blockFor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>responseHandler</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Asks the gossiper if there are any nodes that are currently down.
     * @return true if the gossiper thinks all nodes are up.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isAnyHostDown</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>!<call><name><name>Gossiper</name>.<name>instance</name>.<name>getUnreachableMembers</name></name><argument_list>()</argument_list></call>.<call><name>isEmpty</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <class type="interface"><specifier>public</specifier> interface <name>WritePerformer</name>
    <block>{
        <function_decl><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>IMutation</name></type> <name>mutation</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>, <param><decl><type><name>AbstractWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>, <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>OverloadedException</name></expr></argument></throws>;</function_decl>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * A Runnable that aborts if it doesn't start running before it times out
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>abstract</specifier> class <name>DroppableRunnable</name> <super><implements>implements <name>Runnable</name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>long</name></type> <name>constructionTime</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>MessagingService</name>.<name>Verb</name></name></type> <name>verb</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>DroppableRunnable</name><parameter_list>(<param><decl><type><name><name>MessagingService</name>.<name>Verb</name></name></type> <name>verb</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>verb</name></name> = <name>verb</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> &gt; <name>constructionTime</name> + <call><name><name>DatabaseDescriptor</name>.<name>getTimeout</name></name><argument_list>(<argument><expr><name>verb</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>incrementDroppedMessages</name><argument_list>(<argument><expr><name>verb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <try>try
            <block>{
                <expr_stmt><expr><call><name>runMayThrow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></function>

        <function_decl><type><specifier>abstract</specifier> <specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>;</function_decl>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Like DroppableRunnable, but if it aborts, it will rerun (on the mutation stage) after
     * marking itself as a hint in progress so that the hint backpressure mechanism can function.
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> <specifier>abstract</specifier> class <name>LocalMutationRunnable</name> <super><implements>implements <name>Runnable</name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>long</name></type> <name>constructionTime</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> &gt; <name>constructionTime</name> + <call><name><name>DatabaseDescriptor</name>.<name>getTimeout</name></name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>incrementDroppedMessages</name><argument_list>(<argument><expr><name><name>MessagingService</name>.<name>Verb</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <decl_stmt><decl><type><name>HintRunnable</name></type> <name>runnable</name> <init>= <expr>new <class><super><name>HintRunnable</name></super><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list>
                <block>{
                    <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>
                    <block>{
                        <expr_stmt><expr><call><name><name>LocalMutationRunnable</name>.<name>this</name>.<name>runMayThrow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>submitHint</name><argument_list>(<argument><expr><name>runnable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <try>try
            <block>{
                <expr_stmt><expr><call><name>runMayThrow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></function>

        <function_decl><type><specifier>abstract</specifier> <specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>;</function_decl>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * HintRunnable will decrease totalHintsInProgress and targetHints when finished.
     * It is the caller's responsibility to increment them initially.
     */</comment>
    <class><specifier>private</specifier> <specifier>abstract</specifier> <specifier>static</specifier> class <name>HintRunnable</name> <super><implements>implements <name>Runnable</name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>InetAddress</name></type> <name>target</name></decl>;</decl_stmt>

        <constructor><specifier>protected</specifier> <name>HintRunnable</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>target</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>target</name></name> = <name>target</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><call><name>runMayThrow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch>
            <finally>finally
            <block>{
                <expr_stmt><expr><call><name><name>totalHintsInProgress</name>.<name>decrementAndGet</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>hintsInProgress</name>.<name>get</name></name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>.<call><name>decrementAndGet</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></function>

        <function_decl><type><specifier>abstract</specifier> <specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>;</function_decl>
    }</block></class>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalHints</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>totalHints</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaxHintsInProgress</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>maxHintsInProgress</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaxHintsInProgress</name><parameter_list>(<param><decl><type><name>int</name></type> <name>qs</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>maxHintsInProgress</name> = <name>qs</name></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getHintsInProgress</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>totalHintsInProgress</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>verifyNoHintsInProgress</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name>getHintsInProgress</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Some hints were not written before shutdown.  This is not supposed to happen.  You should (a) run repair, and (b) file a bug report"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>Long</name></type> <name>getRpcTimeout</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcTimeout</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRpcTimeout</name><parameter_list>(<param><decl><type><name>Long</name></type> <name>timeoutInMillis</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setRpcTimeout</name></name><argument_list>(<argument><expr><name>timeoutInMillis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <function><type><specifier>public</specifier> <name>Long</name></type> <name>getReadRpcTimeout</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getReadRpcTimeout</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setReadRpcTimeout</name><parameter_list>(<param><decl><type><name>Long</name></type> <name>timeoutInMillis</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setReadRpcTimeout</name></name><argument_list>(<argument><expr><name>timeoutInMillis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <function><type><specifier>public</specifier> <name>Long</name></type> <name>getWriteRpcTimeout</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getWriteRpcTimeout</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setWriteRpcTimeout</name><parameter_list>(<param><decl><type><name>Long</name></type> <name>timeoutInMillis</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setWriteRpcTimeout</name></name><argument_list>(<argument><expr><name>timeoutInMillis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <function><type><specifier>public</specifier> <name>Long</name></type> <name>getRangeRpcTimeout</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getRangeRpcTimeout</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setRangeRpcTimeout</name><parameter_list>(<param><decl><type><name>Long</name></type> <name>timeoutInMillis</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setRangeRpcTimeout</name></name><argument_list>(<argument><expr><name>timeoutInMillis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

    <function><type><specifier>public</specifier> <name>Long</name></type> <name>getTruncateRpcTimeout</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getTruncateRpcTimeout</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTruncateRpcTimeout</name><parameter_list>(<param><decl><type><name>Long</name></type> <name>timeoutInMillis</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setTruncateRpcTimeout</name></name><argument_list>(<argument><expr><name>timeoutInMillis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
}
</unit>
