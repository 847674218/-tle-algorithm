<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.2.1\src\java\org\apache\cassandra\cql3\statements\SelectStatement.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cql3</name>.<name>statements</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>ExecutionException</name></name>;</import>

<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>collect</name>.<name>AbstractIterator</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>auth</name>.<name>Permission</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cql3</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>transport</name>.<name>messages</name>.<name>ResultMessage</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>ColumnDefinition</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>exceptions</name>.<name>ConfigurationException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>context</name>.<name>CounterContext</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>index</name>.<name>SecondaryIndex</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>index</name>.<name>SecondaryIndexManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>exceptions</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>ClientState</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>QueryState</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>RangeSliceVerbHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageProxy</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>ConsistencyLevel</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>IndexExpression</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>IndexOperator</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>ThriftValidation</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>ByteBufferUtil</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>Pair</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>UUIDGen</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Encapsulates a completely parsed SELECT query, including the target
 * column family, expression, result count, and ordering clause.
 *
 */</comment>
<class><specifier>public</specifier> class <name>SelectStatement</name> <super><implements>implements <name>CQLStatement</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>SelectStatement</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>boundTerms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>CFDefinition</name></type> <name>cfDef</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Parameters</name></type> <name>parameters</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selectedNames</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// empty =&gt; wildcard</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Restriction</name><index>[]</index></type> <name>keyRestrictions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Restriction</name><index>[]</index></type> <name>columnRestrictions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name></type> <name>metadataRestrictions</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Restriction</name></type> <name>sliceRestriction</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isReversed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>onToken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isKeyRange</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>keyIsInRelation</name></decl>;</decl_stmt>

    <enum><specifier>private</specifier> <specifier>static</specifier> enum <name>Bound</name>
    <block>{
        <decl><name>START</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></decl>, <decl><name>END</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></decl>;

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>idx</name></decl>;</decl_stmt>

        <constructor><name>Bound</name><parameter_list>(<param><decl><type><name>int</name></type> <name>idx</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>idx</name></name> = <name>idx</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Bound</name></type> <name>reverse</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><name>b</name> == <name>START</name> ? <name>END</name> : <name>START</name></expr>;</return>
        }</block></function>
    }</block></enum><empty_stmt>;</empty_stmt>

    <constructor><specifier>public</specifier> <name>SelectStatement</name><parameter_list>(<param><decl><type><name>CFDefinition</name></type> <name>cfDef</name></decl></param>, <param><decl><type><name>int</name></type> <name>boundTerms</name></decl></param>, <param><decl><type><name>Parameters</name></type> <name>parameters</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name><name>this</name>.<name>cfDef</name></name> = <name>cfDef</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>boundTerms</name></name> = <name>boundTerms</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>keyRestrictions</name></name> = new <name><name>Restriction</name><index>[<expr><call><name><name>cfDef</name>.<name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>columnRestrictions</name></name> = new <name><name>Restriction</name><index>[<expr><call><name><name>cfDef</name>.<name>columns</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>parameters</name></name> = <name>parameters</name></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getBoundsTerms</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>boundTerms</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>checkAccess</name><parameter_list>(<param><decl><type><name>ClientState</name></type> <name>state</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument>, <argument><expr><name>UnauthorizedException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>state</name>.<name>hasColumnFamilyAccess</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Permission</name>.<name>SELECT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>validate</name><parameter_list>(<param><decl><type><name>ClientState</name></type> <name>state</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <comment type="line">// Nothing to do, all validation has been done by RawStatement.prepare()</comment>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>ResultMessage</name>.<name>Rows</name></name></type> <name>execute</name><parameter_list>(<param><decl><type><name>ConsistencyLevel</name></type> <name>cl</name></decl></param>, <param><decl><type><name>QueryState</name></type> <name>state</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>RequestExecutionException</name></expr></argument>, <argument><expr><name>RequestValidationException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>cl</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Invalid empty consistency level"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <expr_stmt><expr><call><name><name>cl</name>.<name>validateForRead</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <try>try
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name> <init>= <expr><name>isKeyRange</name>
                           ? <call><name><name>StorageProxy</name>.<name>getRangeSlice</name></name><argument_list>(<argument><expr><call><name>getRangeCommand</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call>
                           : <call><name><name>StorageProxy</name>.<name>read</name></name><argument_list>(<argument><expr><call><name>getSliceCommands</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><call><name>processResults</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>ResultMessage</name>.<name>Rows</name></name></type> <name>processResults</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>RequestValidationException</name></expr></argument></throws>
    <block>{
        <comment type="line">// Even for count, we need to process the result as it'll group some column together in sparse column families</comment>
        <decl_stmt><decl><type><name>ResultSet</name></type> <name>rset</name> <init>= <expr><call><name>process</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rset</name> = <name><name>parameters</name>.<name>isCount</name></name> ? <call><name><name>rset</name>.<name>makeCountResult</name></name><argument_list>()</argument_list></call> : <name>rset</name></expr>;</expr_stmt>
        <return>return <expr>new <call><name><name>ResultMessage</name>.<name>Rows</name></name><argument_list>(<argument><expr><name>rset</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>readLocally</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>cmds</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name> <init>= <expr>new <call><name>ArrayList</name><argument_list>(<argument><expr><call><name><name>cmds</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ReadCommand</name></type> <name>cmd</name> <range>: <expr><name>cmds</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>rows</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>cmd</name>.<name>getRow</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>rows</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>ResultMessage</name>.<name>Rows</name></name></type> <name>executeInternal</name><parameter_list>(<param><decl><type><name>QueryState</name></type> <name>state</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>RequestExecutionException</name></expr></argument>, <argument><expr><name>RequestValidationException</name></expr></argument></throws>
    <block>{
        <try>try
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name> <init>= <expr><name>isKeyRange</name>
                           ? <call><name><name>RangeSliceVerbHandler</name>.<name>executeLocally</name></name><argument_list>(<argument><expr><call><name>getRangeCommand</name><argument_list>(<argument><expr><name><name>Collections</name>.</name>&lt;<name>ByteBuffer</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                           : <call><name>readLocally</name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSliceCommands</name><argument_list>(<argument><expr><name><name>Collections</name>.</name>&lt;<name>ByteBuffer</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><call><name>processResults</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>ByteBuffer</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name>ResultSet</name></type> <name>process</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr>!<name><name>parameters</name>.<name>isCount</name></name></expr>;</assert> <comment type="line">// not yet needed</comment>
        <return>return <expr><call><name>process</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>ByteBuffer</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>keyspace</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>cfDef</name>.<name>cfm</name>.<name>ksName</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>columnFamily</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>cfDef</name>.<name>cfm</name>.<name>cfName</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>getSliceCommands</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>RequestValidationException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>QueryPath</name></type> <name>queryPath</name> <init>= <expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr><call><name>getKeys</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>commands</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// ...a range (slice) of column names</comment>
        <if>if <condition>(<expr><call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// Note that we use the total limit for every key. This is</comment>
            <comment type="line">// potentially inefficient, but then again, IN + LIMIT is not a</comment>
            <comment type="line">// very sensible choice</comment>
            <for>for (<init><decl><type><name>ByteBuffer</name></type> <name>key</name> <range>: <expr><name>keys</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Note that we should not share the slice filter amongst the command, due to SliceQueryFilter not</comment>
                <comment type="line">// being immutable due to its columnCounter used by the lastCounted() method</comment>
                <comment type="line">// (this is fairly ugly and we should change that but that's probably not a tiny refactor to do that cleanly)</comment>
                <expr_stmt><expr><call><name><name>commands</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>SliceFromReadCommand</name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>queryPath</name></expr></argument>, <argument><expr>(<name>SliceQueryFilter</name>)<call><name>makeFilter</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then>
        <comment type="line">// ...of a list of column names</comment>
        <else>else
        <block>{
            <comment type="line">// ByNames commands can share the filter</comment>
            <decl_stmt><decl><type><name>IDiskAtomFilter</name></type> <name>filter</name> <init>= <expr><call><name>makeFilter</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>ByteBuffer</name></type> <name>key</name><range>: <expr><name>keys</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>commands</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>SliceByNamesReadCommand</name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>queryPath</name></expr></argument>, <argument><expr>(<name>NamesQueryFilter</name>)<name>filter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <return>return <expr><name>commands</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>RangeSliceCommand</name></type> <name>getRangeCommand</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>RequestValidationException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>IDiskAtomFilter</name></type> <name>filter</name> <init>= <expr><call><name>makeFilter</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>expressions</name> <init>= <expr><call><name>getIndexExpressions</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// The LIMIT provided by the user is the number of CQL row he wants returned.</comment>
        <comment type="line">// We want to have getRangeSlice to count the number of columns, not the number of keys.</comment>
        <return>return <expr>new <call><name>RangeSliceCommand</name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr>null</expr></argument>,
                                     <argument><expr><name>filter</name></expr></argument>,
                                     <argument><expr><call><name>getKeyBounds</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>expressions</name></expr></argument>,
                                     <argument><expr><call><name>getLimit</name><argument_list>()</argument_list></call></expr></argument>,
                                     <argument><expr>true</expr></argument>,
                                     <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>getKeyBounds</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>IPartitioner</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>p</name> <init>= <expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>bounds</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>onToken</name></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>Token</name></type> <name>startToken</name> <init>= <expr><call><name>getTokenBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Token</name></type> <name>endToken</name> <init>= <expr><call><name>getTokenBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>RowPosition</name></type> <name>start</name> <init>= <expr><call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> ? <call><name><name>startToken</name>.<name>minKeyBound</name></name><argument_list>()</argument_list></call> : <call><name><name>startToken</name>.<name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RowPosition</name></type> <name>end</name> <init>= <expr><call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call> ? <call><name><name>endToken</name>.<name>maxKeyBound</name></name><argument_list>()</argument_list></call> : <call><name><name>endToken</name>.<name>minKeyBound</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>bounds</name> = new <call><name><name>Range</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>startKeyBytes</name> <init>= <expr><call><name>getKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>finishKeyBytes</name> <init>= <expr><call><name>getKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>RowPosition</name></type> <name>startKey</name> <init>= <expr><call><name><name>RowPosition</name>.<name>forKey</name></name><argument_list>(<argument><expr><name>startKeyBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RowPosition</name></type> <name>finishKey</name> <init>= <expr><call><name><name>RowPosition</name>.<name>forKey</name></name><argument_list>(<argument><expr><name>finishKeyBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>startKey</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>finishKey</name></expr></argument>)</argument_list></call> &gt; 0 &amp;&amp; !<call><name><name>finishKey</name>.<name>isMinimum</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>p</name>.<name>preservesOrder</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Start key must sort before (or equal to) finish key in your partitioner!"</expr></argument>)</argument_list></call></expr>;</throw></then>
                <else>else
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Start key sorts after end key. This is not allowed; you probably should not specify end key at all under random partitioner"</expr></argument>)</argument_list></call></expr>;</throw></else></if>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>bounds</name> = <call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>
                    ? new <call><name><name>Bounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call>
                    : new <call><name><name>IncludingExcludingBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>bounds</name> = <call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>
                    ? new <call><name><name>Range</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call>
                    : new <call><name><name>ExcludingBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <return>return <expr><name>bounds</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>IDiskAtomFilter</name></type> <name>makeFilter</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// For sparse, we used to ask for 'defined columns' * 'asked limit' (where defined columns includes the row marker)</comment>
            <comment type="line">// to account for the grouping of columns.</comment>
            <comment type="line">// Since that doesn't work for maps/sets/lists, we now use the compositesToGroup option of SliceQueryFilter.</comment>
            <comment type="line">// But we must preserve backward compatibility too (for mixed version cluster that is).</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>multiplier</name> <init>= <expr><name><name>cfDef</name>.<name>isCompact</name></name> ? 1 : (<call><name><name>cfDef</name>.<name>metadata</name>.<name>size</name></name><argument_list>()</argument_list></call> + 1)</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>toGroup</name> <init>= <expr><name><name>cfDef</name>.<name>isCompact</name></name> ? -1 : <call><name><name>cfDef</name>.<name>columns</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnSlice</name></type> <name>slice</name> <init>= <expr>new <call><name>ColumnSlice</name><argument_list>(<argument><expr><call><name>getRequestedBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>getRequestedBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SliceQueryFilter</name></type> <name>filter</name> <init>= <expr>new <call><name>SliceQueryFilter</name><argument_list>(<argument><expr>new <name><name>ColumnSlice</name><index>[]</index></name><block>{<expr><name>slice</name></expr>}</block></expr></argument>,
                                                           <argument><expr><name>isReversed</name></expr></argument>,
                                                           <argument><expr><call><name>getLimit</name><argument_list>()</argument_list></call></expr></argument>,
                                                           <argument><expr><name>toGroup</name></expr></argument>,
                                                           <argument><expr><name>multiplier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateSliceFilter</name></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name></name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>filter</name></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name><name>SortedSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>columnNames</name> <init>= <expr><call><name>getRequestedColumns</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateColumnNames</name></name><argument_list>(<argument><expr><name>columnNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>new <call><name>NamesQueryFilter</name><argument_list>(<argument><expr><name>columnNames</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>getLimit</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// Internally, we don't support exclusive bounds for slices. Instead,</comment>
        <comment type="line">// we query one more element if necessary and exclude</comment>
        <return>return <expr><name>sliceRestriction</name> != null &amp;&amp; !<call><name><name>sliceRestriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>parameters</name>.<name>limit</name></name> != <name><name>Integer</name>.<name>MAX_VALUE</name></name>
             ? <name><name>parameters</name>.<name>limit</name></name> + 1
             : <name><name>parameters</name>.<name>limit</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>getKeys</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>cfDef</name>.<name>getKeyNameBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <range>: <expr><call><name><name>cfDef</name>.<name>keys</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Restriction</name></type> <name>r</name> <init>= <expr><name><name>keyRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>r</name> != null</expr>;</assert>
            <if>if <condition>(<expr><call><name><name>builder</name>.<name>remainingCount</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
            <block>{
                <for>for (<init><decl><type><name>Term</name></type> <name>t</name> <range>: <expr><name><name>r</name>.<name>eqValues</name></name></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>keys</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            }</block></then>
            <else>else
            <block>{
                <if>if <condition>(<expr><call><name><name>r</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"IN is only supported on the last column of the partition key"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <return>return <expr><name>keys</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>getKeyBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name>buildBound</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name><name>cfDef</name>.<name>keys</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>keyRestrictions</name></expr></argument>, <argument><expr><name>isReversed</name></expr></argument>, <argument><expr><call><name><name>cfDef</name>.<name>getKeyNameBuilder</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Token</name></type> <name>getTokenBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>, <param><decl><type><name><name>IPartitioner</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>p</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr><name>onToken</name></expr>;</assert>

        <decl_stmt><decl><type><name>Restriction</name></type> <name>keyRestriction</name> <init>= <expr><name><name>keyRestrictions</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><call><name><name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call>
               ? <call><name><name>keyRestriction</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
               : <call><name><name>keyRestriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>t</name> == null</expr>)</condition><then>
            <return>return <expr><call><name><name>p</name>.<name>getMinimumToken</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <if>if <condition>(<expr><call><name><name>t</name>.<name>getType</name></name><argument_list>()</argument_list></call> == <name><name>Term</name>.<name>Type</name>.<name>STRING</name></name> &amp;&amp; !<name><name>t</name>.<name>isToken</name></name></expr>)</condition><then>
        <block>{
            <try>try
            <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>text</name> <init>= <expr><call><name><name>t</name>.<name>getText</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>p</name>.<name>getTokenFactory</name></name><argument_list>()</argument_list></call>.<call><name>validate</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name><name>p</name>.<name>getTokenFactory</name></name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>ConfigurationException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then></if>

        <assert>assert <expr><name><name>t</name>.<name>isToken</name></name></expr>;</assert>
        <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>cfDef</name>.<name>getKeyNameBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// We know all keyRestriction must be set</comment>
        <for>for (<init><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <range>: <expr><call><name><name>cfDef</name>.<name>keys</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Restriction</name></type> <name>r</name> <init>= <expr><name><name>keyRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> ? <call><name><name>r</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call> : <call><name><name>r</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>p</name>.<name>getToken</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>build</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>includeKeyBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>Restriction</name></type> <name>r</name> <range>: <expr><name>keyRestrictions</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><name>r</name> == null</expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then>
            <else>else <if>if <condition>(<expr>!<call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr><call><name><name>r</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
        }</block></for>
        <comment type="line">// All equality</comment>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isColumnRange</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// Static CF never entails a column slice</comment>
        <if>if <condition>(<expr>!<name><name>cfDef</name>.<name>isCompact</name></name> &amp;&amp; !<name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="line">// However, collections always entails one</comment>
        <if>if <condition>(<expr><name><name>cfDef</name>.<name>hasCollections</name></name></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>

        <comment type="line">// Otherwise, it is a range query if it has at least one the column alias</comment>
        <comment type="line">// for which no relation is defined or is not EQ.</comment>
        <for>for (<init><decl><type><name>Restriction</name></type> <name>r</name> <range>: <expr><name>columnRestrictions</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><name>r</name> == null || !<call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isWildcard</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>selectedNames</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>SortedSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>getRequestedColumns</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr>!<call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>cfDef</name>.<name>getColumnNameBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Restriction</name></type> <name>r</name> <range>: <expr><name>columnRestrictions</name></expr></range></decl></init>)
        <block>{
            <assert>assert <expr><name>r</name> != null &amp;&amp; <call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <if>if <condition>(<expr><call><name><name>r</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
            <block>{
                <assert>assert <expr><name><name>cfDef</name>.<name>isCompact</name></name></expr>;</assert>
                <comment type="line">// We have a IN. We only support this for the last column, so just create all columns and return.</comment>
                <decl_stmt><decl><type><name><name>SortedSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr>new <call><name><name>TreeSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>r</name>.<name>eqValues</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{
                    <decl_stmt><decl><type><name>Term</name></type> <name>v</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>b</name> <init>= <expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call> : <name>builder</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>cname</name> <init>= <expr><call><name><name>b</name>.<name>add</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>columns</name>.<name>add</name></name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></while>
                <return>return <expr><name>columns</name></expr>;</return>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <if>if <condition>(<expr><name><name>cfDef</name>.<name>isCompact</name></name></expr>)</condition><then>
        <block>{
            <return>return <expr><call><name><name>FBUtilities</name>.<name>singleton</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>build</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// Collections require doing a slice query because a given collection is a</comment>
            <comment type="line">// non-know set of columns, so we shouldn't get there</comment>
            <assert>assert <expr>!<name><name>cfDef</name>.<name>hasCollections</name></name></expr>;</assert>

            <decl_stmt><decl><type><name><name>SortedSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr>new <call><name><name>TreeSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// We need to query the selected column as well as the marker</comment>
            <comment type="line">// column (for the case where the row exists but has no columns outside the PK)</comment>
            <comment type="line">// One exception is "static CF" (non-composite non-compact CF) that</comment>
            <comment type="line">// don't have marker and for which we must query all columns instead</comment>
            <if>if <condition>(<expr><name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// marker</comment>
                <expr_stmt><expr><call><name><name>columns</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><name><name>ByteBufferUtil</name>.<name>EMPTY_BYTE_BUFFER</name></name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// selected columns</comment>
                <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><call><name>getExpandedSelection</name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>columns</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><call><name><name>p</name>.<name>right</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            }</block></then>
            <else>else
            <block>{
                <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>cfDef</name>.<name>metadata</name>.<name>keySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{
                    <decl_stmt><decl><type><name>ColumnIdentifier</name></type> <name>name</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>b</name> <init>= <expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call> : <name>builder</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>cname</name> <init>= <expr><call><name><name>b</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>columns</name>.<name>add</name></name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></while>
            }</block></else></if>
            <return>return <expr><name>columns</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>ByteBuffer</name></type> <name>buildBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>bound</name></decl></param>,
                                         <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>&gt;</argument_list></name></type> <name>names</name></decl></param>,
                                         <param><decl><type><name><name>Restriction</name><index>[]</index></name></type> <name>restrictions</name></decl></param>,
                                         <param><decl><type><name>boolean</name></type> <name>isReversed</name></decl></param>,
                                         <param><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name></decl></param>,
                                         <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <comment type="line">// The end-of-component of composite doesn't depend on whether the</comment>
        <comment type="line">// component type is reversed or not (i.e. the ReversedType is applied</comment>
        <comment type="line">// to the component comparator but not to the end-of-component itself),</comment>
        <comment type="line">// it only depends on whether the slice is reversed</comment>
        <decl_stmt><decl><type><name>Bound</name></type> <name>eocBound</name> <init>= <expr><name>isReversed</name> ? <call><name><name>Bound</name>.<name>reverse</name></name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call> : <name>bound</name></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <range>: <expr><name>names</name></expr></range></decl></init>)
        <block>{
            <comment type="line">// In a restriction, we always have Bound.START &lt; Bound.END for the "base" comparator.</comment>
            <comment type="line">// So if we're doing a reverse slice, we must inverse the bounds when giving them as start and end of the slice filter.</comment>
            <comment type="line">// But if the actual comparator itself is reversed, we must inversed the bounds too.</comment>
            <decl_stmt><decl><type><name>Bound</name></type> <name>b</name> <init>= <expr><name>isReversed</name> == <call><name>isReversedType</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> ? <name>bound</name> : <call><name><name>Bound</name>.<name>reverse</name></name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Restriction</name></type> <name>r</name> <init>= <expr><name><name>restrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>r</name> == null || (!<call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>r</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> == null)</expr>)</condition><then>
            <block>{
                <comment type="line">// There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix.</comment>
                <comment type="line">// For composites, if there was preceding component and we're computing the end, we must change the last component</comment>
                <comment type="line">// End-Of-Component, otherwise we would be selecting only one record.</comment>
                <if>if <condition>(<expr><call><name><name>builder</name>.<name>componentCount</name></name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp; <name>eocBound</name> == <name><name>Bound</name>.<name>END</name></name></expr>)</condition><then>
                    <return>return <expr><call><name><name>builder</name>.<name>buildAsEndOfRange</name></name><argument_list>()</argument_list></call></expr>;</return></then>
                <else>else
                    <return>return <expr><call><name><name>builder</name>.<name>build</name></name><argument_list>()</argument_list></call></expr>;</return></else></if>
            }</block></then></if>

            <if>if <condition>(<expr><call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <assert>assert <expr><call><name><name>r</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>;</assert>
                <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><call><name><name>r</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <assert>assert <expr><name>t</name> != null</expr>;</assert>
                <return>return <expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name><name>r</name>.<name>getRelation</name></name><argument_list>(<argument><expr><name>eocBound</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></for>
        <comment type="line">// Means no relation at all or everything was an equal</comment>
        <return>return <expr>(<name>bound</name> == <name><name>Bound</name>.<name>END</name></name>) ? <call><name><name>builder</name>.<name>buildAsEndOfRange</name></name><argument_list>()</argument_list></call> : <call><name><name>builder</name>.<name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>getRequestedBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr><call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><call><name>buildBound</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name><name>cfDef</name>.<name>columns</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>columnRestrictions</name></expr></argument>, <argument><expr><name>isReversed</name></expr></argument>, <argument><expr><call><name><name>cfDef</name>.<name>getColumnNameBuilder</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>getIndexExpressions</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name><name>Collections</name>.</name>&lt;<name>IndexExpression</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>expressions</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>metadataRestrictions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <for>for (<init><decl><type><name>Term</name></type> <name>t</name> <range>: <expr><name><name>restriction</name>.<name>eqValues</name></name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>value</name> <init>= <expr><call><name><name>t</name>.<name>getByteBuffer</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>value</name>.<name>remaining</name></name><argument_list>()</argument_list></call> &gt; 0xFFFF</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Index expression values may not be larger than 64K"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    <expr_stmt><expr><call><name><name>expressions</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>IndexExpression</name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>, <argument><expr><name><name>IndexOperator</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></then>
            <else>else
            <block>{
                <for>for (<init><decl><type><name>Bound</name></type> <name>b</name> <range>: <expr><call><name><name>Bound</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>restriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> != null</expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>value</name> <init>= <expr><call><name><name>restriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>.<call><name>getByteBuffer</name><argument_list>(<argument><expr><name><name>name</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><call><name><name>value</name>.<name>remaining</name></name><argument_list>()</argument_list></call> &gt; 0xFFFF</expr>)</condition><then>
                            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Index expression values may not be larger than 64K"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                        <expr_stmt><expr><call><name><name>expressions</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>IndexExpression</name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>, <argument><expr><call><name><name>restriction</name>.<name>getIndexOperator</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></else></if>
        }</block></for>
        <return>return <expr><name>expressions</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getExpandedSelection</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>selectedNames</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <range>: <expr><name>cfDef</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>selection</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>Pair</name>.</name>&lt;<name><name>CFDefinition</name>.<name>Name</name></name></expr></argument>, <argument><expr><name>Selector</name>&gt;<call><name>create</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>name</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <return>return <expr><name>selection</name></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <return>return <expr><name>selectedNames</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>value</name><parameter_list>(<param><decl><type><name>IColumn</name></type> <name>c</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr>(<name>c</name> instanceof <name>CounterColumn</name>)
             ? <call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><call><name><name>CounterContext</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>total</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
             : <call><name><name>c</name>.<name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>addReturnValue</name><parameter_list>(<param><decl><type><name>ResultSet</name></type> <name>cqlRows</name></decl></param>, <param><decl><type><name>Selector</name></type> <name>s</name></decl></param>, <param><decl><type><name>IColumn</name></type> <name>c</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>c</name> == null || <call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>cqlRows</name>.<name>addColumnValue</name></name><argument_list>(<argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>s</name>.<name>hasFunction</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <switch>switch <condition>(<expr><call><name><name>s</name>.<name>function</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <case>case <expr><name>WRITE_TIME</name></expr>:
                    <expr_stmt><expr><call><name><name>cqlRows</name>.<name>addColumnValue</name></name><argument_list>(<argument><expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                </case><case>case <expr><name>TTL</name></expr>:
                    <if>if <condition>(<expr><name>c</name> instanceof <name>ExpiringColumn</name></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>ttl</name> <init>= <expr>((<name>ExpiringColumn</name>)<name>c</name>).<call><name>getLocalDeletionTime</name><argument_list>()</argument_list></call> - <call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>cqlRows</name>.<name>addColumnValue</name></name><argument_list>(<argument><expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><name>ttl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else
                    <block>{
                        <expr_stmt><expr><call><name><name>cqlRows</name>.<name>addColumnValue</name></name><argument_list>(<argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <return>return;</return>
            </case>}</block></switch>
        }</block></then></if>

        <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>value</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>addReturnValue</name><parameter_list>(<param><decl><type><name>ResultSet</name></type> <name>cqlRows</name></decl></param>, <param><decl><type><name>Selector</name></type> <name>s</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>value</name> != null &amp;&amp; <call><name><name>s</name>.<name>hasFunction</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <switch>switch <condition>(<expr><call><name><name>s</name>.<name>function</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <case>case <expr><name>DATE_OF</name></expr>:
                    <expr_stmt><expr><name>value</name> = <call><name><name>DateType</name>.<name>instance</name>.<name>decompose</name></name><argument_list>(<argument><expr>new <call><name>Date</name><argument_list>(<argument><expr><call><name><name>UUIDGen</name>.<name>unixTimestamp</name></name><argument_list>(<argument><expr><call><name><name>UUIDGen</name>.<name>getUUID</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>UNIXTIMESTAMP_OF</name></expr>:
                    <expr_stmt><expr><name>value</name> = <call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><call><name><name>UUIDGen</name>.<name>unixTimestamp</name></name><argument_list>(<argument><expr><call><name><name>UUIDGen</name>.<name>getUUID</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>WRITE_TIME</name></expr>:
                </case><case>case <expr><name>TTL</name></expr>:
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr>"Cannot return the timestamp or ttl of a value"</expr></argument>)</argument_list></call></expr>;</throw>
            </case>}</block></switch>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>cqlRows</name>.<name>addColumnValue</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ResultSet</name></type> <name>createResult</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ColumnSpecification</name></argument>&gt;</argument_list></name></type> <name>names</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ColumnSpecification</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>selection</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>names</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>p</name>.<name>right</name>.<name>hasFunction</name></name><argument_list>()</argument_list></call>
                      ? new <call><name>ColumnSpecification</name><argument_list>(<argument><expr><name><name>p</name>.<name>left</name>.<name>ksName</name></name></expr></argument>, <argument><expr><name><name>p</name>.<name>left</name>.<name>cfName</name></name></expr></argument>, <argument><expr>new <call><name>ColumnIdentifier</name><argument_list>(<argument><expr><call><name><name>p</name>.<name>right</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>p</name>.<name>right</name>.<name>function</name></name><argument_list>()</argument_list></call>.<name>resultType</name></expr></argument>)</argument_list></call>
                      : <name><name>p</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>new <call><name>ResultSet</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>columnsInOrder</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <comment type="line">// If the restriction for the last column alias is an IN, respect</comment>
        <comment type="line">// requested order</comment>
        <decl_stmt><decl><type><name>Restriction</name></type> <name>last</name> <init>= <expr><name><name>columnRestrictions</name><index>[<expr><name><name>columnRestrictions</name>.<name>length</name></name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>last</name> == null || !<call><name><name>last</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>cf</name>.<name>getSortedColumns</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>cfDef</name>.<name>getColumnNameBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>columnRestrictions</name>.<name>length</name></name> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>columnRestrictions</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name><name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>requested</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>last</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>last</name>.<name>eqValues</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>b</name> <init>= <expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call> : <name>builder</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>requested</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>b</name>.<name>add</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <return>return <expr>new <class><super><name><name>Iterable</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list>
            <block>{
                <return>return <expr>new <class><super><name><name>AbstractIterator</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
                <block>{
                    <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>requested</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <function><type><specifier>public</specifier> <name>IColumn</name></type> <name>computeNext</name><parameter_list>()</parameter_list>
                    <block>{
                        <if>if <condition>(<expr>!<call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <return>return <expr><call><name>endOfData</name><argument_list>()</argument_list></call></expr>;</return></then></if>
                        <decl_stmt><decl><type><name>IColumn</name></type> <name>column</name> <init>= <expr><call><name><name>cf</name>.<name>getColumn</name></name><argument_list>(<argument><expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <return>return <expr><name>column</name> == null ? <call><name>computeNext</name><argument_list>()</argument_list></call> : <name>column</name></expr>;</return>
                    }</block></function>
                }</block></class></expr>;</return>
            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ResultSet</name></type> <name>process</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name> <init>= <expr><call><name>getExpandedSelection</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ResultSet</name></type> <name>cqlRows</name> <init>= <expr><call><name>createResult</name><argument_list>(<argument><expr><name>selection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>Row</name></name></type> <name>row</name> <range>: <expr><name>rows</name></expr></range></decl></init>)
        <block>{
            <comment type="line">// Not columns match the query, skip</comment>
            <if>if <condition>(<expr><name><name>row</name>.<name>cf</name></name> == null</expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <decl_stmt><decl><type><name>ByteBuffer</name><index>[]</index></type> <name>keyComponents</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>cfDef</name>.<name>hasCompositeKey</name></name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>keyComponents</name> = ((<name>CompositeType</name>)<call><name><name>cfDef</name>.<name>cfm</name>.<name>getKeyValidator</name></name><argument_list>()</argument_list></call>).<call><name>split</name><argument_list>(<argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>keyComponents</name> = new <name><name>ByteBuffer</name><index>[]</index></name><block>{ <expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr> }</block></expr>;</expr_stmt>
            }</block></else></if>

            <if>if <condition>(<expr><name><name>cfDef</name>.<name>isCompact</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// One cqlRow per column</comment>
                <for>for (<init><decl><type><name>IColumn</name></type> <name>c</name> <range>: <expr><call><name>columnsInOrder</name><argument_list>(<argument><expr><name><name>row</name>.<name>cf</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <decl_stmt><decl><type><name>ByteBuffer</name><index>[]</index></type> <name>components</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>components</name> = ((<name>CompositeType</name>)<name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name>).<call><name>split</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>sliceRestriction</name> != null</expr>)</condition><then>
                    <block>{
                        <comment type="line">// For dynamic CF, the column could be out of the requested bounds, filter here</comment>
                        <if>if <condition>(<expr>!<call><name><name>sliceRestriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name><name>sliceRestriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call>.<call><name>getByteBuffer</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <continue>continue;</continue></then></if>
                        <if>if <condition>(<expr>!<call><name><name>sliceRestriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name><name>sliceRestriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>.<call><name>getByteBuffer</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <continue>continue;</continue></then></if>
                    }</block></then></if></else></if>

                    <comment type="line">// Respect selection order</comment>
                    <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><name><name>p</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Selector</name></type> <name>selector</name> <init>= <expr><name><name>p</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>
                        <switch>switch <condition>(<expr><name><name>name</name>.<name>kind</name></name></expr>)</condition>
                        <block>{
                            <case>case <expr><name>KEY_ALIAS</name></expr>:
                                <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name><name>keyComponents</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </case><case>case <expr><name>COLUMN_ALIAS</name></expr>:
                                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>val</name> <init>= <expr><name><name>cfDef</name>.<name>isComposite</name></name>
                                               ? (<name><name>name</name>.<name>position</name></name> &lt; <name><name>components</name>.<name>length</name></name> ? <name><name>components</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name> : null)
                                               : <call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                                <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </case><case>case <expr><name>VALUE_ALIAS</name></expr>:
                                <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </case><case>case <expr><name>COLUMN_METADATA</name></expr>:
                                <comment type="line">// This should not happen for compact CF</comment>
                                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
                            </case><default>default:
                                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
                        </default>}</block></switch>
                    }</block></for>
                }</block></for>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// Sparse case: group column in cqlRow when composite prefix is equal</comment>
                <decl_stmt><decl><type><name>CompositeType</name></type> <name>composite</name> <init>= <expr>(<name>CompositeType</name>)<name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name><name>ColumnGroupMap</name>.<name>Builder</name></name></type> <name>builder</name> <init>= <expr>new <call><name><name>ColumnGroupMap</name>.<name>Builder</name></name><argument_list>(<argument><expr><name>composite</name></expr></argument>, <argument><expr><name><name>cfDef</name>.<name>hasCollections</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for (<init><decl><type><name>IColumn</name></type> <name>c</name> <range>: <expr><name><name>row</name>.<name>cf</name></name></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>

                <for>for (<init><decl><type><name>ColumnGroupMap</name></type> <name>group</name> <range>: <expr><call><name><name>builder</name>.<name>groups</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <expr_stmt><expr><call><name>handleGroup</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>, <argument><expr><name>keyComponents</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>cqlRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            }</block></then>
            <else>else
            <block>{
                <if>if <condition>(<expr><call><name><name>row</name>.<name>cf</name>.<name>hasOnlyTombstones</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <continue>continue;</continue></then></if>

                <comment type="line">// Static case: One cqlRow for all columns</comment>
                <comment type="line">// Respect selection order</comment>
                <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><name><name>p</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Selector</name></type> <name>selector</name> <init>= <expr><name><name>p</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name><name>name</name>.<name>kind</name></name> == <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>KEY_ALIAS</name></name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name><name>keyComponents</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>

                    <decl_stmt><decl><type><name>IColumn</name></type> <name>c</name> <init>= <expr><call><name><name>row</name>.<name>cf</name>.<name>getColumn</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></else></if></else></if>
        }</block></for>

        <expr_stmt><expr><call><name>orderResults</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name>cqlRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Internal calls always return columns in the comparator order, even when reverse was set</comment>
        <if>if <condition>(<expr><name>isReversed</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>cqlRows</name>.<name>reverse</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// Trim result if needed to respect the limit</comment>
        <expr_stmt><expr><call><name><name>cqlRows</name>.<name>trim</name></name><argument_list>(<argument><expr><name><name>parameters</name>.<name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cqlRows</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Orders results when multiple keys are selected (using IN)
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>orderResults</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name></decl></param>, <param><decl><type><name>ResultSet</name></type> <name>cqlRows</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// There is nothing to do if</comment>
        <comment type="line">//   a. there are no results,</comment>
        <comment type="line">//   b. no ordering information where given,</comment>
        <comment type="line">//   c. key restriction is a Range or not an IN expression</comment>
        <if>if <condition>(<expr><call><name><name>cqlRows</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0 || <call><name><name>parameters</name>.<name>orderings</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> || <name>isKeyRange</name> || !<name>keyIsInRelation</name></expr>)</condition><then>
            <return>return;</return></then></if>


        <comment type="line">// optimization when only *one* order condition was given</comment>
        <comment type="line">// because there is no point of using composite comparator if there is only one order condition</comment>
        <if>if <condition>(<expr><call><name><name>parameters</name>.<name>orderings</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>ordering</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>parameters</name>.<name>orderings</name>.<name>keySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name><name>cqlRows</name>.<name>rows</name></name></expr></argument>, <argument><expr>new <call><name>SingleColumnComparator</name><argument_list>(<argument><expr><call><name>getColumnPositionInSelect</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name>ordering</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ordering</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <comment type="line">// builds a 'composite' type for multi-column comparison from the comparators of the ordering components</comment>
        <comment type="line">// and passes collected position information and built composite comparator to CompositeComparator to do</comment>
        <comment type="line">// an actual comparison of the CQL rows.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>types</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>parameters</name>.<name>orderings</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>positions</name> <init>= <expr>new <name><name>int</name><index>[<expr><call><name><name>parameters</name>.<name>orderings</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnIdentifier</name></type> <name>identifier</name> <range>: <expr><call><name><name>parameters</name>.<name>orderings</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>orderingColumn</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>types</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>orderingColumn</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>positions</name><index>[<expr><name>idx</name>++</expr>]</index></name> = <call><name>getColumnPositionInSelect</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name>orderingColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name><name>cqlRows</name>.<name>rows</name></name></expr></argument>, <argument><expr>new <call><name>CompositeComparator</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>positions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// determine position of column in the select clause</comment>
    <function><type><specifier>private</specifier> <name>int</name></type> <name>getColumnPositionInSelect</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name></decl></param>, <param><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>columnName</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>selection</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <if>if <condition>(<expr><call><name><name>selection</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<call><name><name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>i</name></expr>;</return></then></if>
        }</block></for>

        <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Column %s wasn't found in select clause."</expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * For sparse composite, returns wheter two columns belong to the same
     * cqlRow base on the full list of component in the name.
     * Two columns do belong together if they differ only by the last
     * component.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isSameRow</name><parameter_list>(<param><decl><type><name><name>ByteBuffer</name><index>[]</index></name></type> <name>c1</name></decl></param>, <param><decl><type><name><name>ByteBuffer</name><index>[]</index></name></type> <name>c2</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// Cql don't allow to insert columns who doesn't have all component of</comment>
        <comment type="line">// the composite set for sparse composite. Someone coming from thrift</comment>
        <comment type="line">// could hit that though. But since we have no way to handle this</comment>
        <comment type="line">// correctly, better fail here and tell whomever may hit that (if</comment>
        <comment type="line">// someone ever do) to change the definition to a dense composite</comment>
        <assert>assert <expr><name><name>c1</name>.<name>length</name></name> == <name><name>c2</name>.<name>length</name></name> : "Sparse composite should not have partial column names"</expr>;</assert>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>c1</name>.<name>length</name></name> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <if>if <condition>(<expr>!<name><name>c1</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr><name><name>c2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleGroup</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>, <param><decl><type><name><name>ByteBuffer</name><index>[]</index></name></type> <name>keyComponents</name></decl></param>, <param><decl><type><name>ColumnGroupMap</name></type> <name>columns</name></decl></param>, <param><decl><type><name>ResultSet</name></type> <name>cqlRows</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// Respect requested order</comment>
        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><name><name>p</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Selector</name></type> <name>selector</name> <init>= <expr><name><name>p</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name><name>name</name>.<name>kind</name></name></expr>)</condition>
            <block>{
                <case>case <expr><name>KEY_ALIAS</name></expr>:
                    <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name><name>keyComponents</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>COLUMN_ALIAS</name></expr>:
                    <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><call><name><name>columns</name>.<name>getKeyComponent</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>position</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>VALUE_ALIAS</name></expr>:
                    <comment type="line">// This should not happen for SPARSE</comment>
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
                </case><case>case <expr><name>COLUMN_METADATA</name></expr>:
                    <if>if <condition>(<expr><call><name><name>name</name>.<name>type</name>.<name>isCollection</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>IColumn</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>collection</name> <init>= <expr><call><name><name>columns</name>.<name>getCollection</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>value</name> <init>= <expr><name>collection</name> == null
                                         ? null
                                         : ((<name>CollectionType</name>)<name><name>name</name>.<name>type</name></name>).<call><name>serialize</name><argument_list>(<argument><expr><name>collection</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else
                    <block>{
                        <decl_stmt><decl><type><name>IColumn</name></type> <name>c</name> <init>= <expr><call><name><name>columns</name>.<name>getSimple</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name>addReturnValue</name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr><name>selector</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                </case><default>default:
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
            </default>}</block></switch>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isReversedType</name><parameter_list>(<param><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name><name>name</name>.<name>type</name></name> instanceof <name>ReversedType</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>columnFilterIsIdentity</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>Restriction</name></type> <name>r</name> <range>: <expr><name>columnRestrictions</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><name>r</name> != null</expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>RawStatement</name> <super><extends>extends <name>CFStatement</name></extends></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Parameters</name></type> <name>parameters</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>selectClause</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Relation</name></argument>&gt;</argument_list></name></type> <name>whereClause</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>RawStatement</name><parameter_list>(<param><decl><type><name>CFName</name></type> <name>cfName</name></decl></param>, <param><decl><type><name>Parameters</name></type> <name>parameters</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>selectClause</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Relation</name></argument>&gt;</argument_list></name></type> <name>whereClause</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>parameters</name></name> = <name>parameters</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>selectClause</name></name> = <name>selectClause</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>whereClause</name></name> = <name>whereClause</name> == null ? <name><name>Collections</name>.</name>&lt;<name>Relation</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call> : <name>whereClause</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name><name>ParsedStatement</name>.<name>Prepared</name></name></type> <name>prepare</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
        <block>{
            <decl_stmt><decl><type><name>CFMetaData</name></type> <name>cfm</name> <init>= <expr><call><name><name>ThriftValidation</name>.<name>validateColumnFamily</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name><name>parameters</name>.<name>limit</name></name> &lt;= 0</expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"LIMIT must be strictly positive"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name>CFDefinition</name></type> <name>cfDef</name> <init>= <expr><call><name><name>cfm</name>.<name>getCfDef</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SelectStatement</name></type> <name>stmt</name> <init>= <expr>new <call><name>SelectStatement</name><argument_list>(<argument><expr><name>cfDef</name></expr></argument>, <argument><expr><call><name>getBoundsTerms</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name><index>[]</index></type> <name>names</name> <init>= <expr>new <name><name>CFDefinition</name>.<name>Name</name><index>[<expr><call><name>getBoundsTerms</name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IPartitioner</name></type> <name>partitioner</name> <init>= <expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Select clause</comment>
            <if>if <condition>(<expr><name><name>parameters</name>.<name>isCount</name></name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr>!<call><name><name>selectClause</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Only COUNT(*) and COUNT(1) operations are currently supported."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            }</block></then>
            <else>else
            <block>{
                <for>for (<init><decl><type><name>Selector</name></type> <name>t</name> <range>: <expr><name>selectClause</name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>t</name>.<name>id</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>name</name> == null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Undefined name %s in selection clause"</expr></argument>, <argument><expr><call><name><name>t</name>.<name>id</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    <if>if <condition>(<expr><call><name><name>t</name>.<name>hasFunction</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><call><name><name>name</name>.<name>type</name>.<name>isCollection</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Function %s is not supported on collections"</expr></argument>, <argument><expr><call><name><name>t</name>.<name>function</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                        <switch>switch <condition>(<expr><call><name><name>t</name>.<name>function</name></name><argument_list>()</argument_list></call></expr>)</condition>
                        <block>{
                            <case>case <expr><name>WRITE_TIME</name></expr>:
                            </case><case>case <expr><name>TTL</name></expr>:
                                <if>if <condition>(<expr><name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>COLUMN_METADATA</name></name> &amp;&amp; <name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>VALUE_ALIAS</name></name></expr>)</condition><then>
                                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Cannot use function %s on PRIMARY KEY part %s"</expr></argument>, <argument><expr><call><name><name>t</name>.<name>function</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                                <break>break;</break>
                            </case><case>case <expr><name>DATE_OF</name></expr>:
                            </case><case>case <expr><name>UNIXTIMESTAMP_OF</name></expr>:
                                <if>if <condition>(<expr>!(<name><name>name</name>.<name>type</name></name> instanceof <name>TimeUUIDType</name>)</expr>)</condition><then>
                                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Function %s is only allowed on timeuuid columns"</expr></argument>, <argument><expr><call><name><name>t</name>.<name>function</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                                <break>break;</break>
                        </case>}</block></switch>
                    }</block></then></if>

                    <expr_stmt><expr><call><name><name>stmt</name>.<name>selectedNames</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>Pair</name>.<name>create</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></else></if>

            <comment type="block">/*
             * WHERE clause. For a given entity, rules are:
             *   - EQ relation conflicts with anything else (including a 2nd EQ)
             *   - Can't have more than one LT(E) relation (resp. GT(E) relation)
             *   - IN relation are restricted to row keys (for now) and conflics with anything else
             *     (we could allow two IN for the same entity but that doesn't seem very useful)
             *   - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value in CQL so far)
             */</comment>
            <for>for (<init><decl><type><name>Relation</name></type> <name>rel</name> <range>: <expr><name>whereClause</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>rel</name>.<name>getEntity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>name</name> == null</expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Undefined name %s in where clause ('%s')"</expr></argument>, <argument><expr><call><name><name>rel</name>.<name>getEntity</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <if>if <condition>(<expr><call><name><name>rel</name>.<name>operator</name></name><argument_list>()</argument_list></call> == <name><name>Relation</name>.<name>Type</name>.<name>IN</name></name></expr>)</condition><then>
                <block>{
                    <for>for (<init><decl><type><name>Term</name></type> <name>value</name> <range>: <expr><call><name><name>rel</name>.<name>getInValues</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                        <if>if <condition>(<expr><call><name><name>value</name>.<name>isBindMarker</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <expr_stmt><expr><name><name>names</name><index>[<expr><name><name>value</name>.<name>bindIndex</name></name></expr>]</index></name> = <name>name</name></expr>;</expr_stmt></then></if></for>
                }</block></then>
                <else>else
                <block>{
                    <decl_stmt><decl><type><name>Term</name></type> <name>value</name> <init>= <expr><call><name><name>rel</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>value</name>.<name>isBindMarker</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><name><name>names</name><index>[<expr><name><name>value</name>.<name>bindIndex</name></name></expr>]</index></name> = <name>name</name></expr>;</expr_stmt></then></if>
                }</block></else></if>

                <switch>switch <condition>(<expr><name><name>name</name>.<name>kind</name></name></expr>)</condition>
                <block>{
                    <case>case <expr><name>KEY_ALIAS</name></expr>:
                        <expr_stmt><expr><name><name>stmt</name>.<name>keyRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name> = <call><name>updateRestriction</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stmt</name>.<name>keyRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </case><case>case <expr><name>COLUMN_ALIAS</name></expr>:
                        <expr_stmt><expr><name><name>stmt</name>.<name>columnRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name> = <call><name>updateRestriction</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stmt</name>.<name>columnRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </case><case>case <expr><name>VALUE_ALIAS</name></expr>:
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Restricting the value of a compact CF (%s) is not supported"</expr></argument>, <argument><expr><name><name>name</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                    </case><case>case <expr><name>COLUMN_METADATA</name></expr>:
                        <expr_stmt><expr><call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>updateRestriction</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </case>}</block></switch>
            }</block></for>

            <comment type="block">/*
             * At this point, the select statement if fully constructed, but we still have a few things to validate
             */</comment>

            <comment type="line">// If a component of the PRIMARY KEY is restricted by a non-EQ relation, all preceding</comment>
            <comment type="line">// components must have a EQ, and all following must have no restriction</comment>
            <decl_stmt><decl><type><name>boolean</name></type> <name>shouldBeDone</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>previous</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>cfDef</name>.<name>columns</name>.<name>values</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>stmt</name>.<name>columnRestrictions</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>cname</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><name><name>stmt</name>.<name>columnRestrictions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>restriction</name> == null</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>shouldBeDone</name> = true</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>shouldBeDone</name></expr>)</condition><then>
                <block>{
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)"</expr></argument>, <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>shouldBeDone</name> = true</expr>;</expr_stmt>
                    <comment type="line">// For non-composite slices, we don't support internally the difference between exclusive and</comment>
                    <comment type="line">// inclusive bounds, so we deal with it manually.</comment>
                    <if>if <condition>(<expr>!<name><name>cfDef</name>.<name>isComposite</name></name> &amp;&amp; (!<call><name><name>restriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> || !<call><name><name>restriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                        <expr_stmt><expr><name><name>stmt</name>.<name>sliceRestriction</name></name> = <name>restriction</name></expr>;</expr_stmt></then></if>
                }</block></then>
                <comment type="line">// We only support IN for the last name and for compact storage so far</comment>
                <comment type="line">// TODO: #3885 allows us to extend to non compact as well, but that remains to be done</comment>
                <else>else <if>if <condition>(<expr><call><name><name>restriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1 &amp;&amp; (!<name><name>cfDef</name>.<name>isCompact</name></name> || <name>i</name> != <name><name>stmt</name>.<name>columnRestrictions</name>.<name>length</name></name> - 1)</expr>)</condition><then>
                <block>{
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"PRIMARY KEY part %s cannot be restricted by IN relation"</expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if></else></if></else></if></else></if>

                <expr_stmt><expr><name>previous</name> = <name>cname</name></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// If a component of the partition key is restricted by a non-EQ relation, all preceding</comment>
            <comment type="line">// components must have a EQ, and all following must have no restriction</comment>
            <expr_stmt><expr><name>shouldBeDone</name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><name>previous</name> = null</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>stmt</name>.<name>keyIsInRelation</name></name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><name>iter</name> = <call><name><name>cfDef</name>.<name>keys</name>.<name>values</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>stmt</name>.<name>keyRestrictions</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>cname</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><name><name>stmt</name>.<name>keyRestrictions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>restriction</name> == null</expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name><name>stmt</name>.<name>onToken</name></name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"The token() function must be applied to all partition key components or none of them"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <comment type="line">// Under a non order perserving partitioner, the only time not restricting a key part is allowed is if none are restricted</comment>
                    <if>if <condition>(<expr>!<call><name><name>partitioner</name>.<name>preservesOrder</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>i</name> &gt; 0 &amp;&amp; <name><name>stmt</name>.<name>keyRestrictions</name><index>[<expr><name>i</name>-1</expr>]</index></name> != null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Partition key part %s must be restricted since preceding part is"</expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <expr_stmt><expr><name><name>stmt</name>.<name>isKeyRange</name></name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><name>shouldBeDone</name> = true</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>shouldBeDone</name></expr>)</condition><then>
                <block>{
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"partition key part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)"</expr></argument>, <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then>
                <else>else <if>if <condition>(<expr><name><name>restriction</name>.<name>onToken</name></name></expr>)</condition><then>
                <block>{
                    <comment type="line">// If this is a query on tokens, it's necessary a range query (there can be more than one key per token), so reject IN queries (as we don't know how to do them)</comment>
                    <expr_stmt><expr><name><name>stmt</name>.<name>isKeyRange</name></name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>stmt</name>.<name>onToken</name></name> = true</expr>;</expr_stmt>

                    <if>if <condition>(<expr><call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>restriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Select using the token() function don't support IN clause"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                }</block></then>
                <else>else <if>if <condition>(<expr><name><name>stmt</name>.<name>onToken</name></name></expr>)</condition><then>
                <block>{
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"The token() function must be applied to all partition key components or none of them"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name><name>restriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                    <block>{
                        <comment type="line">// We only support IN for the last name so far</comment>
                        <if>if <condition>(<expr><name>i</name> != <name><name>stmt</name>.<name>keyRestrictions</name>.<name>length</name></name> - 1</expr>)</condition><then>
                            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Partition KEY part %s cannot be restricted by IN relation (only the last part of the partition key can)"</expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                        <expr_stmt><expr><name><name>stmt</name>.<name>keyIsInRelation</name></name> = true</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then>
                <else>else
                <block>{
                    <if>if <condition>(<expr>!<call><name><name>partitioner</name>.<name>preservesOrder</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Only EQ and IN relation are supported on the partition key for random partitioners (unless you use the token() function)"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <expr_stmt><expr><name><name>stmt</name>.<name>isKeyRange</name></name> = true</expr>;</expr_stmt>
                    <expr_stmt><expr><name>shouldBeDone</name> = true</expr>;</expr_stmt>
                }</block></else></if></else></if></else></if></else></if></else></if>
                <expr_stmt><expr><name>previous</name> = <name>cname</name></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Deal with indexed columns</comment>
            <if>if <condition>(<expr>!<call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name><name>stmt</name>.<name>isKeyRange</name></name> = true</expr>;</expr_stmt>
                <decl_stmt><decl><type><name>boolean</name></type> <name>hasEq</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>SecondaryIndexManager</name></type> <name>idxManager</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<name>indexManager</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>indexedNames</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>SecondaryIndex</name></type> <name>index</name> <range>: <expr><call><name><name>idxManager</name>.<name>getIndexes</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <for>for (<init><decl><type><name>ColumnDefinition</name></type> <name>cdef</name> <range>: <expr><call><name><name>index</name>.<name>getColumnDefs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                        <expr_stmt><expr><call><name><name>indexedNames</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>cdef</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                }</block></for>

                <comment type="line">// Note: we cannot use idxManager.indexes() methods because we don't have a complete column name at this point, we only</comment>
                <comment type="line">// have the indexed component.</comment>
                <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <comment type="line">// We don't support IN for indexed values (basically this would require supporting a form of OR)</comment>
                    <if>if <condition>(<expr><call><name><name>restriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Cannot use IN operator on column not part of the PRIMARY KEY"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <if>if <condition>(<expr><call><name><name>indexedNames</name>.<name>contains</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<name><name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>hasEq</name> = true</expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
                <if>if <condition>(<expr>!<name>hasEq</name></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"No indexed columns present in by-columns clause with Equal operator"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <comment type="line">// If we have indexed columns and the key = X clause, we will do a range query, but if it's a IN relation, we don't know how to handle it.</comment>
                <if>if <condition>(<expr><name><name>stmt</name>.<name>keyIsInRelation</name></name></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Select on indexed columns and with IN clause for the PRIMARY KEY are not supported"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name><name>stmt</name>.<name>parameters</name>.<name>orderings</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr>!<call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"ORDER BY with 2ndary indexes is not supported."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <if>if <condition>(<expr><name><name>stmt</name>.<name>isKeyRange</name></name></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"ORDER BY is only supported when the partition key is restricted by an EQ or an IN."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <comment type="line">// If we order an IN query, we'll have to do a manual sort post-query. Currently, this sorting requires that we</comment>
                <comment type="line">// have queried the column on which we sort (TODO: we should update it to add the column on which we sort to the one</comment>
                <comment type="line">// queried automatically, and then removing it from the resultSet afterwards if needed)</comment>
                <if>if <condition>(<expr><name><name>stmt</name>.<name>keyIsInRelation</name></name> &amp;&amp; !<call><name><name>stmt</name>.<name>selectedNames</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <comment type="line">// empty means wildcard was used</comment>
                <block>{
                    <for>for (<init><decl><type><name>ColumnIdentifier</name></type> <name>column</name> <range>: <expr><call><name><name>stmt</name>.<name>parameters</name>.<name>orderings</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <decl_stmt><decl><type><name>boolean</name></type> <name>hasColumn</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
                        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>selectPair</name> <range>: <expr><name><name>stmt</name>.<name>selectedNames</name></name></expr></range></decl></init>)
                        <block>{
                            <if>if <condition>(<expr><call><name><name>selectPair</name>.<name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>hasColumn</name> = true</expr>;</expr_stmt>
                                <break>break;</break>
                            }</block></then></if>
                        }</block></for>

                        <if>if <condition>(<expr>!<name>hasColumn</name></expr>)</condition><then>
                            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"ORDER BY could not be used on columns missing in select clause."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    }</block></for>
                }</block></then></if>

                <decl_stmt><decl><type><name>Boolean</name><index>[]</index></type> <name>reversedMap</name> <init>= <expr>new <name><name>Boolean</name><index>[<expr><call><name><name>cfDef</name>.<name>columns</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>stmt</name>.<name>parameters</name>.<name>orderings</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>ColumnIdentifier</name></type> <name>column</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>reversed</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>name</name> == null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Order by on unknown column %s"</expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <if>if <condition>(<expr><name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>COLUMN_ALIAS</name></name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Order by is currently only supported on the clustered columns of the PRIMARY KEY, got %s"</expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <if>if <condition>(<expr><name>i</name>++ != <name><name>name</name>.<name>position</name></name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Order by currently only support the ordering of columns following their declared order in the PRIMARY KEY"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <expr_stmt><expr><name><name>reversedMap</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name> = (<name>reversed</name> != <call><name>isReversedType</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                }</block></for>

                <comment type="line">// Check that all boolean in reversedMap, if set, agrees</comment>
                <decl_stmt><decl><type><name>Boolean</name></type> <name>isReversed</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>Boolean</name></type> <name>b</name> <range>: <expr><name>reversedMap</name></expr></range></decl></init>)
                <block>{
                    <comment type="line">// Column on which order is specified can be in any order</comment>
                    <if>if <condition>(<expr><name>b</name> == null</expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <if>if <condition>(<expr><name>isReversed</name> == null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>isReversed</name> = <name>b</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>isReversed</name> != <name>b</name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Unsupported order by relation"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                }</block></for>
                <assert>assert <expr><name>isReversed</name> != null</expr>;</assert>
                <expr_stmt><expr><name><name>stmt</name>.<name>isReversed</name></name> = <name>isReversed</name></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// Make sure this queries is allowed (note: only key range can involve filtering underneath)</comment>
            <if>if <condition>(<expr>!<name><name>parameters</name>.<name>allowFiltering</name></name> &amp;&amp; <name><name>stmt</name>.<name>isKeyRange</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// We will potentially filter data if either:</comment>
                <comment type="line">//  - Have more than one IndexExpression</comment>
                <comment type="line">//  - Have no index expression and the column filter is not the identity</comment>
                <if>if <condition>(<expr><call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1 || (<call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>stmt</name>.<name>columnFilterIsIdentity</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Cannot execute this query as it might involve data filtering and thus may have unpredictable performance. "
                                                    + "If you want to execute this query despite the performance unpredictability, use ALLOW FILTERING"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            }</block></then></if>

            <return>return <expr>new <call><name><name>ParsedStatement</name>.<name>Prepared</name></name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>Arrays</name>.</name>&lt;<name>ColumnSpecification</name>&gt;<call><name>asList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><name>Restriction</name></type> <name>updateRestriction</name><parameter_list>(<param><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name></decl></param>, <param><decl><type><name>Restriction</name></type> <name>restriction</name></decl></param>, <param><decl><type><name>Relation</name></type> <name>newRel</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
        <block>{
            <if>if <condition>(<expr><name><name>newRel</name>.<name>onToken</name></name> &amp;&amp; <name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>KEY_ALIAS</name></name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"The token() function is only supported on the partition key, found on %s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <switch>switch <condition>(<expr><call><name><name>newRel</name>.<name>operator</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <case>case <expr><name>EQ</name></expr>:
                    <if>if <condition>(<expr><name>restriction</name> != null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s cannot be restricted by more than one relation if it includes an Equal"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    <expr_stmt><expr><name>restriction</name> = new <call><name>Restriction</name><argument_list>(<argument><expr><call><name><name>newRel</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>newRel</name>.<name>onToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>IN</name></expr>:
                    <if>if <condition>(<expr><name>restriction</name> != null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s cannot be restricted by more than one reation if it includes a IN"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    <expr_stmt><expr><name>restriction</name> = new <call><name>Restriction</name><argument_list>(<argument><expr><call><name><name>newRel</name>.<name>getInValues</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>GT</name></expr>:
                </case><case>case <expr><name>GTE</name></expr>:
                </case><case>case <expr><name>LT</name></expr>:
                </case><case>case <expr><name>LTE</name></expr>:
                    <if>if <condition>(<expr><name>restriction</name> == null</expr>)</condition><then>
                        <expr_stmt><expr><name>restriction</name> = new <call><name>Restriction</name><argument_list>(<argument><expr><name><name>newRel</name>.<name>onToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><call><name><name>restriction</name>.<name>setBound</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name></name></expr></argument>, <argument><expr><call><name><name>newRel</name>.<name>operator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>newRel</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </case>}</block></switch>
            <return>return <expr><name>restriction</name></expr>;</return>
        }</block></function>

        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"SelectRawStatement[name=%s, selectClause=%s, whereClause=%s, isCount=%s, limit=%s]"</expr></argument>,
                    <argument><expr><name>cfName</name></expr></argument>,
                    <argument><expr><name>selectClause</name></expr></argument>,
                    <argument><expr><name>whereClause</name></expr></argument>,
                    <argument><expr><name><name>parameters</name>.<name>isCount</name></name></expr></argument>,
                    <argument><expr><name><name>parameters</name>.<name>limit</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">// A rather raw class that simplify validation and query for select</comment>
    <comment type="line">// Don't made public as this can be easily badly used</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>Restriction</name>
    <block>{
        <comment type="line">// for equality</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>eqValues</name></decl>;</decl_stmt> <comment type="line">// if null, it's a restriction by bounds</comment>

        <comment type="line">// for bounds</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Term</name><index>[]</index></type> <name>bounds</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>boundInclusive</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>onToken</name></decl>;</decl_stmt>

        <constructor><name>Restriction</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>values</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>eqValues</name></name> = <name>values</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>bounds</name></name> = null</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>boundInclusive</name></name> = null</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>onToken</name></name> = false</expr>;</expr_stmt>
        }</block></constructor>

        <constructor><name>Restriction</name><parameter_list>(<param><decl><type><name>Term</name></type> <name>value</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>onToken</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><name>Restriction</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>onToken</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>eqValues</name></name> = null</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>bounds</name></name> = new <name><name>Term</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>boundInclusive</name></name> = new <name><name>boolean</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>onToken</name></name> = <name>onToken</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><name>boolean</name></type> <name>isEquality</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><name>eqValues</name> != null</expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>, <param><decl><type><name>Term</name></type> <name>t</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setInclusive</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = true</expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>Term</name></type> <name>bound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isInclusive</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> == null || <name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name><name>Relation</name>.<name>Type</name></name></type> <name>getRelation</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>eocBound</name></decl></param>, <param><decl><type><name>Bound</name></type> <name>inclusiveBound</name></decl></param>)</parameter_list>
        <block>{
            <switch>switch <condition>(<expr><name>eocBound</name></expr>)</condition>
            <block>{
                <case>case <expr><name>START</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>inclusiveBound</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>Relation</name>.<name>Type</name>.<name>GTE</name></name> : <name><name>Relation</name>.<name>Type</name>.<name>GT</name></name></expr>;</return>
                </case><case>case <expr><name>END</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>inclusiveBound</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>Relation</name>.<name>Type</name>.<name>LTE</name></name> : <name><name>Relation</name>.<name>Type</name>.<name>LT</name></name></expr>;</return>
            </case>}</block></switch>
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></function>

        <function><type><specifier>public</specifier> <name>IndexOperator</name></type> <name>getIndexOperator</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <switch>switch <condition>(<expr><name>b</name></expr>)</condition>
            <block>{
                <case>case <expr><name>START</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>IndexOperator</name>.<name>GTE</name></name> : <name><name>IndexOperator</name>.<name>GT</name></name></expr>;</return>
                </case><case>case <expr><name>END</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>IndexOperator</name>.<name>LTE</name></name> : <name><name>IndexOperator</name>.<name>LT</name></name></expr>;</return>
            </case>}</block></switch>
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setBound</name><parameter_list>(<param><decl><type><name>ColumnIdentifier</name></type> <name>name</name></decl></param>, <param><decl><type><name><name>Relation</name>.<name>Type</name></name></type> <name>type</name></decl></param>, <param><decl><type><name>Term</name></type> <name>t</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
        <block>{
            <decl_stmt><decl><type><name>Bound</name></type> <name>b</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>inclusive</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
            <block>{
                <case>case <expr><name>GT</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>START</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = false</expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>GTE</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>START</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = true</expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>LT</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>END</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = false</expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>LTE</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>END</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = true</expr>;</expr_stmt>
                    <break>break;</break>
            </case>}</block></switch>

            <if>if <condition>(<expr><name>bounds</name> == null</expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s cannot be restricted by both an equal and an inequal relation"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <if>if <condition>(<expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> != null</expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Invalid restrictions found on %s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <expr_stmt><expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = <name>inclusive</name></expr>;</expr_stmt>
        }</block></function>

        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>s</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>eqValues</name> == null</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>s</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"SLICE(%s %s, %s %s)"</expr></argument>, <argument><expr><name><name>boundInclusive</name><index>[<expr>0</expr>]</index></name> ? "&gt;=" : "&gt;"</expr></argument>,
                                                            <argument><expr><name><name>bounds</name><index>[<expr>0</expr>]</index></name></expr></argument>,
                                                            <argument><expr><name><name>boundInclusive</name><index>[<expr>1</expr>]</index></name> ? "&lt;=" : "&lt;"</expr></argument>,
                                                            <argument><expr><name><name>bounds</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>s</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"EQ(%s)"</expr></argument>, <argument><expr><name>eqValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <return>return <expr><name>onToken</name> ? <name>s</name> + "*" : <name>s</name></expr>;</return>
        }</block></function>
    }</block></class>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Parameters</name>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>limit</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>orderings</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isCount</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>allowFiltering</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>Parameters</name><parameter_list>(<param><decl><type><name>int</name></type> <name>limit</name></decl></param>, <param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>orderings</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isCount</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>allowFiltering</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>limit</name></name> = <name>limit</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>orderings</name></name> = <name>orderings</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>isCount</name></name> = <name>isCount</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>allowFiltering</name></name> = <name>allowFiltering</name></expr>;</expr_stmt>
        }</block></constructor>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Used in orderResults(...) method when single 'ORDER BY' condition where given
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>SingleColumnComparator</name> <super><implements>implements <name><name>Comparator</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>comparator</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>SingleColumnComparator</name><parameter_list>(<param><decl><type><name>int</name></type> <name>columnIndex</name></decl></param>, <param><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>orderer</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>index</name> = <name>columnIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>comparator</name> = <name>orderer</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>a</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><call><name><name>comparator</name>.<name>compare</name></name><argument_list>(<argument><expr><call><name><name>a</name>.<name>get</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>b</name>.<name>get</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Used in orderResults(...) method when multiple 'ORDER BY' conditions where given
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>CompositeComparator</name> <super><implements>implements <name><name>Comparator</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>orderTypes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>positions</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>CompositeComparator</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>orderTypes</name></decl></param>, <param><decl><type><name><name>int</name><index>[]</index></name></type> <name>positions</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>orderTypes</name></name> = <name>orderTypes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>positions</name></name> = <name>positions</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>a</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>positions</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name> <init>= <expr><call><name><name>orderTypes</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>columnPos</name> <init>= <expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>aValue</name> <init>= <expr><call><name><name>a</name>.<name>get</name></name><argument_list>(<argument><expr><name>columnPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>bValue</name> <init>= <expr><call><name><name>b</name>.<name>get</name></name><argument_list>(<argument><expr><name>columnPos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>comparison</name> <init>= <expr><call><name><name>type</name>.<name>compare</name></name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>bValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>comparison</name> != 0</expr>)</condition><then>
                    <return>return <expr><name>comparison</name></expr>;</return></then></if>
            }</block></for>

            <return>return <expr>0</expr>;</return>
        }</block></function>
    }</block></class>
}</block></class>
</unit>
