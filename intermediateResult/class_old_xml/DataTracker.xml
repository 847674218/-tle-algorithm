<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\db\DataTracker.java"><comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>CopyOnWriteArrayList</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicLong</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicReference</name></name>;</import>

<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>collect</name></name>.*;</import>

<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>OperationType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name>.<name>SSTableReader</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>notifications</name>.<name>INotification</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>notifications</name>.<name>INotificationConsumer</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>notifications</name>.<name>SSTableAddedNotification</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>notifications</name>.<name>SSTableListChangedNotification</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>IntervalTree</name>.<name>Interval</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>IntervalTree</name>.<name>IntervalTree</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>WrappedRunnable</name></name>;</import>

<class><specifier>public</specifier> class <name>DataTracker</name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>DataTracker</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>INotificationConsumer</name></argument>&gt;</argument_list></name></type> <name>subscribers</name> <init>= <expr>new <call><name><name>CopyOnWriteArrayList</name><argument_list>&lt;<argument><name>INotificationConsumer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>ColumnFamilyStore</name></type> <name>cfstore</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>AtomicReference</name><argument_list>&lt;<argument><name>View</name></argument>&gt;</argument_list></name></type> <name>view</name></decl>;</decl_stmt>

    <comment type="line">// On disk live and total size</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicLong</name></type> <name>liveSize</name> <init>= <expr>new <call><name>AtomicLong</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicLong</name></type> <name>totalSize</name> <init>= <expr>new <call><name>AtomicLong</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>DataTracker</name><parameter_list>(<param><decl><type><name>ColumnFamilyStore</name></type> <name>cfstore</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name><name>this</name>.<name>cfstore</name></name> = <name>cfstore</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>view</name></name> = new <call><name><name>AtomicReference</name><argument_list>&lt;<argument><name>View</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><specifier>public</specifier> <name>Memtable</name></type> <name>getMemtable</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call>.<name>memtable</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>getMemtablesPendingFlush</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call>.<name>memtablesPendingFlush</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getSSTables</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call>.<name>sstables</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getUncompactingSSTables</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call>.<call><name>nonCompactingSStables</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>View</name></type> <name>getView</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Switch the current memtable.
     * This atomically adds the current memtable to the memtables pending
     * flush and replace it with a fresh memtable.
     *
     * @return the previous current memtable (the one added to the pending
     * flush)
     */</comment>
    <function><type><specifier>public</specifier> <name>Memtable</name></type> <name>switchMemtable</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// atomically change the current memtable</comment>
        <decl_stmt><decl><type><name>Memtable</name></type> <name>newMemtable</name> <init>= <expr>new <call><name>Memtable</name><argument_list>(<argument><expr><name>cfstore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Memtable</name></type> <name>toFlushMemtable</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
        <do>do
        <block>{
            <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>toFlushMemtable</name> = <name><name>currentView</name>.<name>memtable</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>switchMemtable</name></name><argument_list>(<argument><expr><name>newMemtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <return>return <expr><name>toFlushMemtable</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Renew the current memtable without putting the old one for a flush.
     * Used when we flush but a memtable is clean (in which case we must
     * change it because it was frozen).
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>renewMemtable</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Memtable</name></type> <name>newMemtable</name> <init>= <expr>new <call><name>Memtable</name><argument_list>(<argument><expr><name>cfstore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
        <do>do
        <block>{
            <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>renewMemtable</name></name><argument_list>(<argument><expr><name>newMemtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>replaceFlushed</name><parameter_list>(<param><decl><type><name>Memtable</name></type> <name>memtable</name></decl></param>, <param><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>cfstore</name>.<name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
            <do>do
            <block>{
                <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>replaceFlushed</name></name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>sstable</name></expr></argument>)</argument_list></call>.<call><name>replace</name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
            <return>return;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
        <do>do
        <block>{
            <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>replaceFlushed</name></name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>addNewSSTablesSize</name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>notifyAdded</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>incrementallyBackup</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>incrementallyBackup</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>SSTableReader</name></type> <name>sstable</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>DatabaseDescriptor</name>.<name>isIncrementalBackupsEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr>new <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>
            <block>{
                <decl_stmt><decl><type><name>File</name></type> <name>backupsDir</name> <init>= <expr><call><name><name>Directories</name>.<name>getBackupsDirectory</name></name><argument_list>(<argument><expr><name><name>sstable</name>.<name>descriptor</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>sstable</name>.<name>createLinks</name></name><argument_list>(<argument><expr><call><name><name>backupsDir</name>.<name>getCanonicalPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>StorageService</name>.<name>tasks</name>.<name>execute</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return A subset of the given active sstables that have been marked compacting,
     * or null if the thresholds cannot be met: files that are marked compacting must
     * later be unmarked using unmarkCompacting.
     *
     * Note that we could acquire references on the marked sstables and release them in
     * unmarkCompacting, but since we will never call markCompacted on a sstable marked
     * as compacting (unless there is a serious bug), we can skip this.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>markCompacting</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>tomark</name></decl></param>, <param><decl><type><name>int</name></type> <name>min</name></decl></param>, <param><decl><type><name>int</name></type> <name>max</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>max</name> &lt; <name>min</name> || <name>max</name> &lt; 1</expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if>
        <if>if <condition>(<expr><name>tomark</name> == null || <call><name><name>tomark</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if>

        <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>subset</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <comment type="line">// order preserving set copy of the input</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>remaining</name> <init>= <expr>new <call><name><name>LinkedHashSet</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>tomark</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <do>do
        <block>{
            <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// find the subset that is active and not already compacting</comment>
            <expr_stmt><expr><call><name><name>remaining</name>.<name>removeAll</name></name><argument_list>(<argument><expr><name><name>currentView</name>.<name>compacting</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>remaining</name>.<name>retainAll</name></name><argument_list>(<argument><expr><name><name>currentView</name>.<name>sstables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>remaining</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; <name>min</name></expr>)</condition><then>
                <comment type="line">// cannot meet the min threshold</comment>
                <return>return <expr>null</expr>;</return></then></if>

            <comment type="line">// cap the newly compacting items into a subset set</comment>
            <expr_stmt><expr><name>subset</name> = new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>remaining</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>added</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>added</name> &lt; <name>max</name> &amp;&amp; <call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>added</name>++</expr></incr>)
                <expr_stmt><expr><call><name><name>subset</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

            <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>markCompacting</name></name><argument_list>(<argument><expr><name>subset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
        <return>return <expr><name>subset</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Removes files from compacting status: this is different from 'markCompacted'
     * because it should be run regardless of whether a compaction succeeded.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>unmarkCompacting</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>unmark</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>cfstore</name>.<name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// We don't know if the original compaction suceeded or failed, which makes it difficult to know</comment>
            <comment type="line">// if the sstable reference has already been released.</comment>
            <comment type="line">// A "good enough" approach is to mark the sstables involved compacted, which if compaction succeeded</comment>
            <comment type="line">// is harmlessly redundant, and if it failed ensures that at least the sstable will get deleted on restart.</comment>
            <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>unmark</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>sstable</name>.<name>markCompacted</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if>

        <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
        <do>do
        <block>{
            <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>unmarkCompacting</name></name><argument_list>(<argument><expr><name>unmark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>markCompacted</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>, <param><decl><type><name>OperationType</name></type> <name>compactionType</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>replace</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifySSTablesChanged</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>compactionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>replaceCompactedSSTables</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>replacements</name></decl></param>, <param><decl><type><name>OperationType</name></type> <name>compactionType</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>replace</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>notifySSTablesChanged</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>, <argument><expr><name>compactionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addInitialSSTables</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>replace</name><argument_list>(<argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// no notifications or backup necessary</comment>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addSSTables</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>replace</name><argument_list>(<argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name>incrementallyBackup</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>notifyAdded</name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * removes all sstables that are not busy compacting.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>unreferenceSSTables</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>notCompacting</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
        <do>do
        <block>{
            <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>notCompacting</name> = <call><name><name>currentView</name>.<name>nonCompactingSStables</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>replace</name></name><argument_list>(<argument><expr><name>notCompacting</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <if>if <condition>(<expr><call><name><name>notCompacting</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// notifySSTablesChanged -&gt; LeveledManifest.promote doesn't like a no-op "promotion"</comment>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>notifySSTablesChanged</name><argument_list>(<argument><expr><name>notCompacting</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>UNKNOWN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>postReplace</name><argument_list>(<argument><expr><name>notCompacting</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/** (Re)initializes the tracker, purging all references. */</comment>
    <function><type><name>void</name></type> <name>init</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>view</name>.<name>set</name></name><argument_list>(<argument><expr>new <call><name>View</name><argument_list>(<argument><expr>new <call><name>Memtable</name><argument_list>(<argument><expr><name>cfstore</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name><name>Collections</name>.</name>&lt;<name>Memtable</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>,
                          <argument><expr>new <call><name>IntervalTree</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>replace</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>oldSSTables</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>replacements</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>cfstore</name>.<name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>removeOldSSTablesSize</name><argument_list>(<argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>replacements</name> = <call><name><name>Collections</name>.<name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>View</name></type> <name>currentView</name></decl>, <decl><type ref="prev"/><name>newView</name></decl>;</decl_stmt>
        <do>do
        <block>{
            <expr_stmt><expr><name>currentView</name> = <call><name><name>view</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newView</name> = <call><name><name>currentView</name>.<name>replace</name></name><argument_list>(<argument><expr><name>oldSSTables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        while <condition>(<expr>!<call><name><name>view</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>currentView</name></expr></argument>, <argument><expr><name>newView</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

        <expr_stmt><expr><call><name>postReplace</name><argument_list>(<argument><expr><name>oldSSTables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>postReplace</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>oldSSTables</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>replacements</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>addNewSSTablesSize</name><argument_list>(<argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>removeOldSSTablesSize</name><argument_list>(<argument><expr><name>oldSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>addNewSSTablesSize</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>newSSTables</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>newSSTables</name></expr></range></decl></init>)
        <block>{
            <assert>assert <expr><call><name><name>sstable</name>.<name>getKeySamples</name></name><argument_list>()</argument_list></call> != null</expr>;</assert>
            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"adding %s to list of files tracked for %s.%s"</expr></argument>,
                            <argument><expr><name><name>sstable</name>.<name>descriptor</name></name></expr></argument>, <argument><expr><name><name>cfstore</name>.<name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><call><name><name>cfstore</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <decl_stmt><decl><type><name>long</name></type> <name>size</name> <init>= <expr><call><name><name>sstable</name>.<name>bytesOnDisk</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>liveSize</name>.<name>addAndGet</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>totalSize</name>.<name>addAndGet</name></name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sstable</name>.<name>setTrackedBy</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>removeOldSSTablesSize</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>oldSSTables</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>oldSSTables</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"removing %s from list of files tracked for %s.%s"</expr></argument>,
                            <argument><expr><name><name>sstable</name>.<name>descriptor</name></name></expr></argument>, <argument><expr><name><name>cfstore</name>.<name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><call><name><name>cfstore</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name><name>liveSize</name>.<name>addAndGet</name></name><argument_list>(<argument><expr>-<call><name><name>sstable</name>.<name>bytesOnDisk</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>firstToCompact</name> <init>= <expr><call><name><name>sstable</name>.<name>markCompacted</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>firstToCompact</name> : <name>sstable</name> + " was already marked compacted"</expr>;</assert>
            <expr_stmt><expr><call><name><name>sstable</name>.<name>releaseReference</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getLiveSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>liveSize</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>totalSize</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>spaceReclaimed</name><parameter_list>(<param><decl><type><name>long</name></type> <name>size</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>totalSize</name>.<name>addAndGet</name></name><argument_list>(<argument><expr>-<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>estimatedKeys</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name>n</name> += <call><name><name>sstable</name>.<name>estimatedKeys</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>n</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getEstimatedRowSizeHistogram</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>histogram</name> <init>= <expr>new <name><name>long</name><index>[<expr>90</expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>rowSize</name> <init>= <expr><call><name><name>sstable</name>.<name>getEstimatedRowSize</name></name><argument_list>()</argument_list></call>.<call><name>getBuckets</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>histogram</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr><name><name>histogram</name><index>[<expr><name>i</name></expr>]</index></name> += <name><name>rowSize</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
        }</block></for>

        <return>return <expr><name>histogram</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getEstimatedColumnCountHistogram</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>histogram</name> <init>= <expr>new <name><name>long</name><index>[<expr>90</expr>]</index></name></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>columnSize</name> <init>= <expr><call><name><name>sstable</name>.<name>getEstimatedColumnCount</name></name><argument_list>()</argument_list></call>.<call><name>getBuckets</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>histogram</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr><name><name>histogram</name><index>[<expr><name>i</name></expr>]</index></name> += <name><name>columnSize</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
        }</block></for>

        <return>return <expr><name>histogram</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getCompressionRatio</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>sum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>total</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>sstable</name>.<name>getCompressionRatio</name></name><argument_list>()</argument_list></call> != <name><name>Double</name>.<name>MIN_VALUE</name></name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>sum</name> += <call><name><name>sstable</name>.<name>getCompressionRatio</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>total</name>++</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>total</name> != 0 ? (<name>double</name>)<name>sum</name>/<name>total</name>: 0</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMinRowSize</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>min</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><name>min</name> == 0 || <call><name><name>sstable</name>.<name>getEstimatedRowSize</name></name><argument_list>()</argument_list></call>.<call><name>min</name><argument_list>()</argument_list></call> &lt; <name>min</name></expr>)</condition><then>
                <expr_stmt><expr><name>min</name> = <call><name><name>sstable</name>.<name>getEstimatedRowSize</name></name><argument_list>()</argument_list></call>.<call><name>min</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
        <return>return <expr><name>min</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMaxRowSize</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>max</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>sstable</name>.<name>getEstimatedRowSize</name></name><argument_list>()</argument_list></call>.<call><name>max</name><argument_list>()</argument_list></call> &gt; <name>max</name></expr>)</condition><then>
                <expr_stmt><expr><name>max</name> = <call><name><name>sstable</name>.<name>getEstimatedRowSize</name></name><argument_list>()</argument_list></call>.<call><name>max</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
        <return>return <expr><name>max</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMeanRowSize</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>sum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name>sum</name> += <call><name><name>sstable</name>.<name>getEstimatedRowSize</name></name><argument_list>()</argument_list></call>.<call><name>mean</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>count</name> &gt; 0 ? <name>sum</name> / <name>count</name> : 0</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMeanColumns</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>sum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name>sum</name> += <call><name><name>sstable</name>.<name>getEstimatedColumnCount</name></name><argument_list>()</argument_list></call>.<call><name>mean</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>count</name> &gt; 0 ? <call>(<name>int</name>) <argument_list>(<argument><expr><name>sum</name> / <name>count</name></expr></argument>)</argument_list></call> : 0</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getBloomFilterFalsePositives</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name><range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name>count</name> += <call><name><name>sstable</name>.<name>getBloomFilterFalsePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>count</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getRecentBloomFilterFalsePositives</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name><range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name>count</name> += <call><name><name>sstable</name>.<name>getRecentBloomFilterFalsePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>count</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getBloomFilterFalseRatio</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>falseCount</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>trueCount</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name><range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name>falseCount</name> += <call><name><name>sstable</name>.<name>getBloomFilterFalsePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>trueCount</name> += <call><name><name>sstable</name>.<name>getBloomFilterTruePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><name>falseCount</name> == 0L &amp;&amp; <name>trueCount</name> == 0L</expr>)</condition><then>
            <return>return <expr>0d</expr>;</return></then></if>
        <return>return <expr>(<name>double</name>) <name>falseCount</name> / (<name>trueCount</name> + <name>falseCount</name>)</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getRecentBloomFilterFalseRatio</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>falseCount</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>trueCount</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name><range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name>falseCount</name> += <call><name><name>sstable</name>.<name>getRecentBloomFilterFalsePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>trueCount</name> += <call><name><name>sstable</name>.<name>getRecentBloomFilterTruePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <if>if <condition>(<expr><name>falseCount</name> == 0L &amp;&amp; <name>trueCount</name> == 0L</expr>)</condition><then>
            <return>return <expr>0d</expr>;</return></then></if>
        <return>return <expr>(<name>double</name>) <name>falseCount</name> / (<name>trueCount</name> + <name>falseCount</name>)</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>notifySSTablesChanged</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>removed</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>added</name></decl></param>, <param><decl><type><name>OperationType</name></type> <name>compactionType</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>INotificationConsumer</name></type> <name>subscriber</name> <range>: <expr><name>subscribers</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>INotification</name></type> <name>notification</name> <init>= <expr>new <call><name>SSTableListChangedNotification</name><argument_list>(<argument><expr><name>added</name></expr></argument>, <argument><expr><name>removed</name></expr></argument>, <argument><expr><name>compactionType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>subscriber</name>.<name>handleNotification</name></name><argument_list>(<argument><expr><name>notification</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>notifyAdded</name><parameter_list>(<param><decl><type><name>SSTableReader</name></type> <name>added</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>INotificationConsumer</name></type> <name>subscriber</name> <range>: <expr><name>subscribers</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>INotification</name></type> <name>notification</name> <init>= <expr>new <call><name>SSTableAddedNotification</name><argument_list>(<argument><expr><name>added</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>subscriber</name>.<name>handleNotification</name></name><argument_list>(<argument><expr><name>notification</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>subscribe</name><parameter_list>(<param><decl><type><name>INotificationConsumer</name></type> <name>consumer</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>subscribers</name>.<name>add</name></name><argument_list>(<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>unsubscribe</name><parameter_list>(<param><decl><type><name>INotificationConsumer</name></type> <name>consumer</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>found</name> <init>= <expr><call><name><name>subscribers</name>.<name>remove</name></name><argument_list>(<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>found</name> : <name>consumer</name> + " not subscribed"</expr>;</assert>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>IntervalTree</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>buildIntervalTree</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Interval</name></argument>&gt;</argument_list></name></type> <name>intervals</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Interval</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Iterables</name>.<name>size</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>intervals</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Interval</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>sstable</name>.<name>first</name></name></expr></argument>, <argument><expr><name><name>sstable</name>.<name>last</name></name></expr></argument>, <argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr>new <call><name><name>IntervalTree</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>intervals</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * An immutable structure holding the current memtable, the memtables pending
     * flush, the sstables for a column family, and the sstables that are active
     * in compaction (a subset of the sstables).
     */</comment>
    <class><specifier>static</specifier> class <name>View</name>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Memtable</name></type> <name>memtable</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtablesPendingFlush</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>compacting</name></decl>;</decl_stmt>
        <comment type="line">// We can't use a SortedSet here because "the ordering maintained by a sorted set (whether or not an</comment>
        <comment type="line">// explicit comparator is provided) must be &lt;i&gt;consistent with equals&lt;/i&gt;."  In particular,</comment>
        <comment type="line">// ImmutableSortedSet will ignore any objects that compare equally with an existing Set member.</comment>
        <comment type="line">// Obviously, dropping sstables whose max column timestamp happens to be equal to another's</comment>
        <comment type="line">// is not acceptable for us.  So, we use a List instead.</comment>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>IntervalTree</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>intervalTree</name></decl>;</decl_stmt>

        <constructor><name>View</name><parameter_list>(<param><decl><type><name>Memtable</name></type> <name>memtable</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>pendingFlush</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>compacting</name></decl></param>, <param><decl><type><name><name>IntervalTree</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>intervalTree</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>memtable</name></name> = <name>memtable</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>memtablesPendingFlush</name></name> = <name>pendingFlush</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>sstables</name></name> = <name>sstables</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>compacting</name></name> = <name>compacting</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>intervalTree</name></name> = <name>intervalTree</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name><name>Sets</name>.<name><name>SetView</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></name></type> <name>nonCompactingSStables</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>compacting</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>View</name></type> <name>switchMemtable</name><parameter_list>(<param><decl><type><name>Memtable</name></type> <name>newMemtable</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>newPending</name> <init>= <expr><name><name>ImmutableSet</name>.</name>&lt;<name>Memtable</name>&gt;<call><name>builder</name><argument_list>()</argument_list></call>.<call><name>addAll</name><argument_list>(<argument><expr><name>memtablesPendingFlush</name></expr></argument>)</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><name>memtable</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>View</name><argument_list>(<argument><expr><name>newMemtable</name></expr></argument>, <argument><expr><name>newPending</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>compacting</name></expr></argument>, <argument><expr><name>intervalTree</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>View</name></type> <name>renewMemtable</name><parameter_list>(<param><decl><type><name>Memtable</name></type> <name>newMemtable</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr>new <call><name>View</name><argument_list>(<argument><expr><name>newMemtable</name></expr></argument>, <argument><expr><name>memtablesPendingFlush</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>compacting</name></expr></argument>, <argument><expr><name>intervalTree</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>View</name></type> <name>replaceFlushed</name><parameter_list>(<param><decl><type><name>Memtable</name></type> <name>flushedMemtable</name></decl></param>, <param><decl><type><name>SSTableReader</name></type> <name>newSSTable</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>newPending</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><name>memtablesPendingFlush</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>flushedMemtable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>newSSTables</name> <init>= <expr><call><name>newSSTables</name><argument_list>(<argument><expr><name>newSSTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IntervalTree</name></type> <name>intervalTree</name> <init>= <expr><call><name>buildIntervalTree</name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>View</name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>newPending</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>unmodifiableList</name></name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>compacting</name></expr></argument>, <argument><expr><name>intervalTree</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>View</name></type> <name>replace</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>oldSSTables</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>replacements</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>newSSTables</name> <init>= <expr><call><name>newSSTables</name><argument_list>(<argument><expr><name>oldSSTables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IntervalTree</name></type> <name>intervalTree</name> <init>= <expr><call><name>buildIntervalTree</name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>View</name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>memtablesPendingFlush</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>unmodifiableList</name></name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>compacting</name></expr></argument>, <argument><expr><name>intervalTree</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>View</name></type> <name>markCompacting</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>tomark</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>compactingNew</name> <init>= <expr><name><name>ImmutableSet</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>builder</name><argument_list>()</argument_list></call>.<call><name>addAll</name><argument_list>(<argument><expr><name>compacting</name></expr></argument>)</argument_list></call>.<call><name>addAll</name><argument_list>(<argument><expr><name>tomark</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>View</name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>memtablesPendingFlush</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>compactingNew</name></expr></argument>, <argument><expr><name>intervalTree</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>View</name></type> <name>unmarkCompacting</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>tounmark</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>compactingNew</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><name>compacting</name></expr></argument>, <argument><expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><name>tounmark</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr>new <call><name>View</name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>memtablesPendingFlush</name></expr></argument>, <argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>compactingNew</name></expr></argument>, <argument><expr><name>intervalTree</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>newSSTables</name><parameter_list>(<param><decl><type><name>SSTableReader</name></type> <name>newSSTable</name></decl></param>)</parameter_list>
        <block>{
            <comment type="line">// not performance-sensitive, don't obsess over doing a selection merge here</comment>
            <return>return <expr><call><name>newSSTables</name><argument_list>(<argument><expr><name><name>Collections</name>.</name>&lt;<name>SSTableReader</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><name>newSSTable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>newSSTables</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>oldSSTables</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>replacements</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name><name>ImmutableSet</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>oldSet</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><name>oldSSTables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>newSSTablesSize</name> <init>= <expr><call><name><name>sstables</name>.<name>size</name></name><argument_list>()</argument_list></call> - <call><name><name>oldSSTables</name>.<name>size</name></name><argument_list>()</argument_list></call> + <call><name><name>Iterables</name>.<name>size</name></name><argument_list>(<argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><name>newSSTablesSize</name> &gt;= <call><name><name>Iterables</name>.<name>size</name></name><argument_list>(<argument><expr><name>replacements</name></expr></argument>)</argument_list></call> : <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Incoherent new size %d replacing %s by %s in %s"</expr></argument>, <argument><expr><name>newSSTablesSize</name></expr></argument>, <argument><expr><name>oldSSTables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</assert>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>newSSTables</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>newSSTablesSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr>!<call><name><name>oldSet</name>.<name>contains</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>newSSTables</name>.<name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
            <expr_stmt><expr><call><name><name>Iterables</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name><name>newSSTables</name>.<name>size</name></name><argument_list>()</argument_list></call> == <name>newSSTablesSize</name> : <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Expecting new size of %d, got %d while replacing %s by %s in %s"</expr></argument>, <argument><expr><name>newSSTablesSize</name></expr></argument>, <argument><expr><call><name><name>newSSTables</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>oldSSTables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</assert>
            <return>return <expr><name>newSSTables</name></expr>;</return>
        }</block></function>

        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"View(pending_count=%d, sstables=%s, compacting=%s)"</expr></argument>, <argument><expr><call><name><name>memtablesPendingFlush</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>compacting</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>
}</block></class>
</unit>
