<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\tools\NodeCmd.java"><package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>tools</name></name>;</package>
<comment type="block">/*
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *
 */</comment>


<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>PrintStream</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>management</name>.<name>MemoryUsage</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>ConnectException</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>InetAddress</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>UnknownHostException</name></name>;</import>
<import>import <name><name>java</name>.<name>text</name>.<name>DecimalFormat</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name>.<name>Entry</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>ExecutionException</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>cli</name></name>.*;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>JMXEnabledThreadPoolExecutorMBean</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>ConfigurationException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>ColumnFamilyStoreMBean</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>CompactionManagerMBean</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>OperationType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>MessagingServiceMBean</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>CacheServiceMBean</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageProxyMBean</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>InvalidRequestException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>EstimatedHistogram</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>Pair</name></name>;</import>

<class><specifier>public</specifier> class <name>NodeCmd</name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>SNAPSHOT_COLUMNFAMILY_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"cf"</expr></argument>, <argument><expr>"column-family"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>HOST_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"h"</expr></argument>, <argument><expr>"host"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>PORT_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"p"</expr></argument>, <argument><expr>"port"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>USERNAME_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"u"</expr></argument>,  <argument><expr>"username"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>PASSWORD_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"pw"</expr></argument>, <argument><expr>"password"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>TAG_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"t"</expr></argument>, <argument><expr>"tag"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>PRIMARY_RANGE_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"pr"</expr></argument>, <argument><expr>"partitioner-range"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>START_TOKEN_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"st"</expr></argument>, <argument><expr>"start-token"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>END_TOKEN_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"et"</expr></argument>, <argument><expr>"end-token"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>SNAPSHOT_REPAIR_OPT</name> <init>= <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>"snapshot"</expr></argument>, <argument><expr>"with-snapshot"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>DEFAULT_HOST</name> <init>= <expr>"127.0.0.1"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>DEFAULT_PORT</name> <init>= <expr>7199</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>ToolOptions</name></type> <name>options</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>NodeProbe</name></type> <name>probe</name></decl>;</decl_stmt>

    <expr_stmt><expr>static
    <block>{
        <expr><name>options</name> = new <call><name>ToolOptions</name><argument_list>()</argument_list></call></expr>;

        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>SNAPSHOT_COLUMNFAMILY_OPT</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"only take a snapshot of the specified column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>HOST_OPT</name></expr></argument>,     <argument><expr>true</expr></argument>, <argument><expr>"node hostname or ip address"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>PORT_OPT</name></expr></argument>,     <argument><expr>true</expr></argument>, <argument><expr>"remote jmx agent port number"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>USERNAME_OPT</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"remote jmx agent username"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>PASSWORD_OPT</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"remote jmx agent password"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>TAG_OPT</name></expr></argument>,      <argument><expr>true</expr></argument>, <argument><expr>"optional name to give a snapshot"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>PRIMARY_RANGE_OPT</name></expr></argument>, <argument><expr>false</expr></argument>, <argument><expr>"only repair the first range returned by the partitioner for the node"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>SNAPSHOT_REPAIR_OPT</name></expr></argument>, <argument><expr>false</expr></argument>, <argument><expr>"repair one node at a time using snapshots"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>START_TOKEN_OPT</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"token at which repair range starts"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>END_TOKEN_OPT</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"token at which repair range ends"</expr></argument>)</argument_list></call></expr>;
    }</block>

    public <call><name>NodeCmd</name><argument_list>(<argument><expr><name>NodeProbe</name> <name>probe</name></expr></argument>)</argument_list></call>
    <block>{
        <expr><name><name>this</name>.<name>probe</name></name> = <name>probe</name></expr>;
    }</block>

    private enum <name>NodeCommand</name>
    <block>{
        <expr><name>CFHISTOGRAMS</name></expr>,
        <expr><name>CFSTATS</name></expr>,
        <expr><name>CLEANUP</name></expr>,
        <expr><name>CLEARSNAPSHOT</name></expr>,
        <expr><name>COMPACT</name></expr>,
        <expr><name>COMPACTIONSTATS</name></expr>,
        <expr><name>DECOMMISSION</name></expr>,
        <expr><name>DISABLEGOSSIP</name></expr>,
        <expr><name>DISABLETHRIFT</name></expr>,
        <expr><name>DRAIN</name></expr>,
        <expr><name>ENABLEGOSSIP</name></expr>,
        <expr><name>ENABLETHRIFT</name></expr>,
        <expr><name>FLUSH</name></expr>,
        <expr><name>GETCOMPACTIONTHRESHOLD</name></expr>,
        <expr><name>GETENDPOINTS</name></expr>,
        <expr><name>GETSSTABLES</name></expr>,
        <expr><name>GOSSIPINFO</name></expr>,
        <expr><name>INFO</name></expr>,
        <expr><name>INVALIDATEKEYCACHE</name></expr>,
        <expr><name>INVALIDATEROWCACHE</name></expr>,
        <expr><name>JOIN</name></expr>,
        <expr><name>MOVE</name></expr>,
        <expr><name>NETSTATS</name></expr>,
        <expr><name>PROXYHISTOGRAMS</name></expr>,
        <expr><name>REBUILD</name></expr>,
        <expr><name>REFRESH</name></expr>,
        <expr><name>REMOVETOKEN</name></expr>,
        <expr><name>REPAIR</name></expr>,
        <expr><name>RING</name></expr>,
        <expr><name>SCRUB</name></expr>,
        <expr><name>SETCACHECAPACITY</name></expr>,
        <expr><name>SETCOMPACTIONTHRESHOLD</name></expr>,
        <expr><name>SETCOMPACTIONTHROUGHPUT</name></expr>,
        <expr><name>SETSTREAMTHROUGHPUT</name></expr>,
        <expr><name>SNAPSHOT</name></expr>,
        <expr><name>STATUSTHRIFT</name></expr>,
        <expr><name>STOP</name></expr>,
        <expr><name>TPSTATS</name></expr>,
        <expr><name>UPGRADESSTABLES</name></expr>,
        <expr><name>VERSION</name></expr>,
        <expr><name>DESCRIBERING</name></expr>,
        <expr><name>RANGEKEYSAMPLE</name></expr>,
        <expr><name>REBUILD_INDEX</name></expr>,
        <expr><name>RESETLOCALSCHEMA</name></expr>
    }</block>


    <comment type="block" format="javadoc">/**
     * Prints usage information to stdout.
     */</comment>
    private static <name>void</name> <call><name>printUsage</name><argument_list>()</argument_list></call>
    <block>{
        <expr><name>HelpFormatter</name> <name>hf</name> = new <call><name>HelpFormatter</name><argument_list>()</argument_list></call></expr>;
        <expr><name>StringBuilder</name> <name>header</name> = new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr>;
        <expr><call><name><name>header</name>.<name>append</name></name><argument_list>(<argument><expr>"\nAvailable commands:\n"</expr></argument>)</argument_list></call></expr>;
        <comment type="line">// No args</comment>
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"join"</expr></argument>, <argument><expr>"Join the ring"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"info"</expr></argument>, <argument><expr>"Print node information (uptime, load, ...)"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"cfstats"</expr></argument>, <argument><expr>"Print statistics on column families"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"version"</expr></argument>, <argument><expr>"Print cassandra version"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"tpstats"</expr></argument>, <argument><expr>"Print usage statistics of thread pools"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"proxyhistograms"</expr></argument>, <argument><expr>"Print statistic histograms for network operations"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"drain"</expr></argument>, <argument><expr>"Drain the node (stop accepting writes and flush all column families)"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"decommission"</expr></argument>, <argument><expr>"Decommission the *node I am connecting to*"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"compactionstats"</expr></argument>, <argument><expr>"Print statistics on compactions"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"disablegossip"</expr></argument>, <argument><expr>"Disable gossip (effectively marking the node dead)"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"enablegossip"</expr></argument>, <argument><expr>"Reenable gossip"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"disablethrift"</expr></argument>, <argument><expr>"Disable thrift server"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"enablethrift"</expr></argument>, <argument><expr>"Reenable thrift server"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"statusthrift"</expr></argument>, <argument><expr>"Status of thrift server"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"gossipinfo"</expr></argument>, <argument><expr>"Shows the gossip information for the cluster"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"invalidatekeycache"</expr></argument>, <argument><expr>"Invalidate the key cache"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"invalidaterowcache"</expr></argument>, <argument><expr>"Invalidate the row cache"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"resetlocalschema"</expr></argument>, <argument><expr>"Reset node's local schema and resync"</expr></argument>)</argument_list></call></expr>;

        <comment type="line">// One arg</comment>
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"ring [keyspace]"</expr></argument>, <argument><expr>"Print information about the token ring for a given keyspace (for all keyspaces if it is not specified)"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"netstats [host]"</expr></argument>, <argument><expr>"Print network information on provided host (connecting node by default)"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"move &lt;new token&gt;"</expr></argument>, <argument><expr>"Move node on the token ring to a new token"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"removetoken status|force|&lt;token&gt;"</expr></argument>, <argument><expr>"Show status of current token removal, force completion of pending removal or remove providen token"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"setcompactionthroughput &lt;value_in_mb&gt;"</expr></argument>, <argument><expr>"Set the MB/s throughput cap for compaction in the system, or 0 to disable throttling."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"setstreamthroughput &lt;value_in_mb&gt;"</expr></argument>, <argument><expr>"Set the MB/s throughput cap for streaming in the system, or 0 to disable throttling."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"describering [keyspace]"</expr></argument>, <argument><expr>"Shows the token ranges info of a given keyspace."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"rangekeysample"</expr></argument>, <argument><expr>"Shows the sampled keys held across all keyspaces."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"rebuild [src-dc-name]"</expr></argument>, <argument><expr>"Rebuild data by streaming from other nodes (similarly to bootstrap)"</expr></argument>)</argument_list></call></expr>;

        <comment type="line">// Two args</comment>
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"snapshot [keyspaces...] -cf [columnfamilyName] -t [snapshotName]"</expr></argument>, <argument><expr>"Take a snapshot of the optionally specified column family of the specified keyspaces using optional name snapshotName"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"clearsnapshot [keyspaces...] -t [snapshotName]"</expr></argument>, <argument><expr>"Remove snapshots for the specified keyspaces. Either remove all snapshots or remove the snapshots with the given name."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"flush [keyspace] [cfnames]"</expr></argument>, <argument><expr>"Flush one or more column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"repair [keyspace] [cfnames]"</expr></argument>, <argument><expr>"Repair one or more column family (use -pr to repair only the first range returned by the partitioner)"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"cleanup [keyspace] [cfnames]"</expr></argument>, <argument><expr>"Run cleanup on one or more column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"compact [keyspace] [cfnames]"</expr></argument>, <argument><expr>"Force a (major) compaction on one or more column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"scrub [keyspace] [cfnames]"</expr></argument>, <argument><expr>"Scrub (rebuild sstables for) one or more column family"</expr></argument>)</argument_list></call></expr>;

        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"upgradesstables [keyspace] [cfnames]"</expr></argument>, <argument><expr>"Scrub (rebuild sstables for) one or more column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"getcompactionthreshold &lt;keyspace&gt; &lt;cfname&gt;"</expr></argument>, <argument><expr>"Print min and max compaction thresholds for a given column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"cfhistograms &lt;keyspace&gt; &lt;cfname&gt;"</expr></argument>, <argument><expr>"Print statistic histograms for a given column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"refresh &lt;keyspace&gt; &lt;cf-name&gt;"</expr></argument>, <argument><expr>"Load newly placed SSTables to the system without restart."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"rebuild_index &lt;keyspace&gt; &lt;cf-name&gt; &lt;idx1,idx1&gt;"</expr></argument>, <argument><expr>"a full rebuilds of native secondry index for a given column family. IndexNameExample: Standard3.IdxName,Standard3.IdxName1"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"setcachecapacity &lt;key-cache-capacity&gt; &lt;row-cache-capacity&gt;"</expr></argument>, <argument><expr>"Set global key and row cache capacities (in MB units)."</expr></argument>)</argument_list></call></expr>;

        <comment type="line">// Three args</comment>
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"getendpoints &lt;keyspace&gt; &lt;cf&gt; &lt;key&gt;"</expr></argument>, <argument><expr>"Print the end points that owns the key"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"getsstables &lt;keyspace&gt; &lt;cf&gt; &lt;key&gt;"</expr></argument>, <argument><expr>"Print the sstable filenames that own the key"</expr></argument>)</argument_list></call></expr>;

        <comment type="line">// Four args</comment>
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"setcompactionthreshold &lt;keyspace&gt; &lt;cfname&gt; &lt;minthreshold&gt; &lt;maxthreshold&gt;"</expr></argument>, <argument><expr>"Set the min and max compaction thresholds for a given column family"</expr></argument>)</argument_list></call></expr>;
        <expr><call><name>addCmdHelp</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"stop &lt;compaction_type&gt;"</expr></argument>, <argument><expr>"Supported types are COMPACTION, VALIDATION, CLEANUP, SCRUB, INDEX_BUILD"</expr></argument>)</argument_list></call></expr>;

        <expr><name>String</name> <name>usage</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"java %s --host &lt;arg&gt; &lt;command&gt;%n"</expr></argument>, <argument><expr><call><name><name>NodeCmd</name>.<name><name>class</name>.<name>getName</name></name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>hf</name>.<name>printHelp</name></name><argument_list>(<argument><expr><name>usage</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>header</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
    }</block>

    private static <name>void</name> <call><name>addCmdHelp</name><argument_list>(<argument><expr><name>StringBuilder</name> <name>sb</name></expr></argument>, <argument><expr><name>String</name> <name>cmd</name></expr></argument>, <argument><expr><name>String</name> <name>description</name></expr></argument>)</argument_list></call>
    <block>{
        <expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"  "</expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;
        <comment type="line">// Ghetto indentation (trying, but not too hard, to not look too bad)</comment>
        <if>if <condition>(<expr><call><name><name>cmd</name>.<name>length</name></name><argument_list>()</argument_list></call> &lt;= 20</expr>)</condition><then>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name><name>cmd</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 22</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>
        <call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>" - "</expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr><name>description</name></expr></argument>)</argument_list></call>.<call><name>append</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Write a textual representation of the Cassandra ring.
     *
     * @param outs the stream to write to
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>printRing</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>, <param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokenToEndpoint</name> <init>= <expr><call><name><name>probe</name>.<name>getTokenToEndpointMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenToEndpoint</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>liveNodes</name> <init>= <expr><call><name><name>probe</name>.<name>getLiveNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>deadNodes</name> <init>= <expr><call><name><name>probe</name>.<name>getUnreachableNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>joiningNodes</name> <init>= <expr><call><name><name>probe</name>.<name>getJoiningNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>leavingNodes</name> <init>= <expr><call><name><name>probe</name>.<name>getLeavingNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>movingNodes</name> <init>= <expr><call><name><name>probe</name>.<name>getMovingNodes</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>loadMap</name> <init>= <expr><call><name><name>probe</name>.<name>getLoadMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>String</name></type> <name>format</name> <init>= <expr>"%-16s%-12s%-12s%-7s%-8s%-16s%-20s%-44s%n"</expr></init></decl>;</decl_stmt>

        <comment type="line">// Calculate per-token ownership of the ring</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>ownerships</name></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>ownerships</name> = <call><name><name>probe</name>.<name>effectiveOwnership</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>"Address"</expr></argument>, <argument><expr>"DC"</expr></argument>, <argument><expr>"Rack"</expr></argument>, <argument><expr>"Status"</expr></argument>, <argument><expr>"State"</expr></argument>, <argument><expr>"Load"</expr></argument>, <argument><expr>"Effective-Ownership"</expr></argument>, <argument><expr>"Token"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ConfigurationException</name></type> <name>ex</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>ownerships</name> = <call><name><name>probe</name>.<name>getOwnership</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"Note: Ownership information does not include topology, please specify a keyspace. \n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>"Address"</expr></argument>, <argument><expr>"DC"</expr></argument>, <argument><expr>"Rack"</expr></argument>, <argument><expr>"Status"</expr></argument>, <argument><expr>"State"</expr></argument>, <argument><expr>"Load"</expr></argument>, <argument><expr>"Owns"</expr></argument>, <argument><expr>"Token"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></catch></try>

        <comment type="line">// show pre-wrap token twice so you can always read a node's range as</comment>
        <comment type="line">// (previous line token, current line token]</comment>
        <if>if <condition>(<expr><call><name><name>sortedTokens</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>sortedTokens</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <for>for (<init><decl><type><name>String</name></type> <name>token</name> <range>: <expr><name>sortedTokens</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>primaryEndpoint</name> <init>= <expr><call><name><name>tokenToEndpoint</name>.<name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>dataCenter</name></decl>;</decl_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><name>dataCenter</name> = <call><name><name>probe</name>.<name>getEndpointSnitchInfoProxy</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenter</name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>UnknownHostException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><name>dataCenter</name> = "Unknown"</expr>;</expr_stmt>
            }</block></catch></try>
            <decl_stmt><decl><type><name>String</name></type> <name>rack</name></decl>;</decl_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><name>rack</name> = <call><name><name>probe</name>.<name>getEndpointSnitchInfoProxy</name></name><argument_list>()</argument_list></call>.<call><name>getRack</name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>UnknownHostException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><name>rack</name> = "Unknown"</expr>;</expr_stmt>
            }</block></catch></try>
            <decl_stmt><decl><type><name>String</name></type> <name>status</name> <init>= <expr><call><name><name>liveNodes</name>.<name>contains</name></name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call>
                            ? "Up"
                            : <call><name><name>deadNodes</name>.<name>contains</name></name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call>
                              ? "Down"
                              : "?"</expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>String</name></type> <name>state</name> <init>= <expr>"Normal"</expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>joiningNodes</name>.<name>contains</name></name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>state</name> = "Joining"</expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><call><name><name>leavingNodes</name>.<name>contains</name></name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>state</name> = "Leaving"</expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><call><name><name>movingNodes</name>.<name>contains</name></name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>state</name> = "Moving"</expr>;</expr_stmt></then></if></else></if></else></if>

            <decl_stmt><decl><type><name>String</name></type> <name>load</name> <init>= <expr><call><name><name>loadMap</name>.<name>containsKey</name></name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call>
                          ? <call><name><name>loadMap</name>.<name>get</name></name><argument_list>(<argument><expr><name>primaryEndpoint</name></expr></argument>)</argument_list></call>
                          : "?"</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>owns</name> <init>= <expr>new <call><name>DecimalFormat</name><argument_list>(<argument><expr>"##0.00%"</expr></argument>)</argument_list></call>.<call><name>format</name><argument_list>(<argument><expr><call><name><name>ownerships</name>.<name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call> == null ? 0.0F : <call><name><name>ownerships</name>.<name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>primaryEndpoint</name></expr></argument>, <argument><expr><name>dataCenter</name></expr></argument>, <argument><expr><name>rack</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>state</name></expr></argument>, <argument><expr><name>load</name></expr></argument>, <argument><expr><name>owns</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>printThreadPoolStats</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-25s%10s%10s%15s%10s%18s%n"</expr></argument>, <argument><expr>"Pool Name"</expr></argument>, <argument><expr>"Active"</expr></argument>, <argument><expr>"Pending"</expr></argument>, <argument><expr>"Completed"</expr></argument>, <argument><expr>"Blocked"</expr></argument>, <argument><expr>"All time blocked"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>JMXEnabledThreadPoolExecutorMBean</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>threads</name> <init>= <expr><call><name><name>probe</name>.<name>getThreadPoolMBeanProxies</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>threads</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>JMXEnabledThreadPoolExecutorMBean</name></argument>&gt;</argument_list></name></type> <name>thread</name> <init>= <expr><call><name><name>threads</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>poolName</name> <init>= <expr><call><name><name>thread</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>JMXEnabledThreadPoolExecutorMBean</name></type> <name>threadPoolProxy</name> <init>= <expr><call><name><name>thread</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-25s%10s%10s%15s%10s%18s%n"</expr></argument>,
                        <argument><expr><name>poolName</name></expr></argument>,
                        <argument><expr><call><name><name>threadPoolProxy</name>.<name>getActiveCount</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>threadPoolProxy</name>.<name>getPendingTasks</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>threadPoolProxy</name>.<name>getCompletedTasks</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>threadPoolProxy</name>.<name>getCurrentlyBlockedTasks</name></name><argument_list>()</argument_list></call></expr></argument>,
                        <argument><expr><call><name><name>threadPoolProxy</name>.<name>getTotalBlockedTasks</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%n%-20s%10s%n"</expr></argument>, <argument><expr>"Message type"</expr></argument>, <argument><expr>"Dropped"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>entry</name> <range>: <expr><call><name><name>probe</name>.<name>getDroppedMessages</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-20s%10s%n"</expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Write node information.
     *
     * @param outs the stream to write to
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>printInfo</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>gossipInitialized</name> <init>= <expr><call><name><name>probe</name>.<name>isInitialized</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Token"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Gossip active"</expr></argument>, <argument><expr><name>gossipInitialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Thrift active"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>isThriftServerRunning</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Load"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>getLoadString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>gossipInitialized</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Generation No"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>getCurrentGenerationNumber</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Generation No"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

        <comment type="line">// Uptime</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>secondsUp</name> <init>= <expr><call><name><name>probe</name>.<name>getUptime</name></name><argument_list>()</argument_list></call> / 1000</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %d%n"</expr></argument>, <argument><expr>"Uptime (seconds)"</expr></argument>, <argument><expr><name>secondsUp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Memory usage</comment>
        <decl_stmt><decl><type><name>MemoryUsage</name></type> <name>heapUsage</name> <init>= <expr><call><name><name>probe</name>.<name>getHeapMemoryUsage</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>memUsed</name> <init>= <expr>(<name>double</name>)<call><name><name>heapUsage</name>.<name>getUsed</name></name><argument_list>()</argument_list></call> / (1024 * 1024)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>double</name></type> <name>memMax</name> <init>= <expr>(<name>double</name>)<call><name><name>heapUsage</name>.<name>getMax</name></name><argument_list>()</argument_list></call> / (1024 * 1024)</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %.2f / %.2f%n"</expr></argument>, <argument><expr>"Heap Memory (MB)"</expr></argument>, <argument><expr><name>memUsed</name></expr></argument>, <argument><expr><name>memMax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Data Center/Rack</comment>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Data Center"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>getDataCenter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Rack"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>getRack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Exceptions</comment>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: %s%n"</expr></argument>, <argument><expr>"Exceptions"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>getExceptionCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>CacheServiceMBean</name></type> <name>cacheService</name> <init>= <expr><call><name><name>probe</name>.<name>getCacheServiceMBean</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Key Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds</comment>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: size %d (bytes), capacity %d (bytes), %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n"</expr></argument>,
                    <argument><expr>"Key Cache"</expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getKeyCacheSize</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getKeyCacheCapacityInBytes</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getKeyCacheHits</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getKeyCacheRequests</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getKeyCacheRecentHitRate</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getKeyCacheSavePeriodInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Row Cache: Hits, Requests, RecentHitRate, SavePeriodInSeconds</comment>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-17s: size %d (bytes), capacity %d (bytes), %d hits, %d requests, %.3f recent hit rate, %d save period in seconds%n"</expr></argument>,
                    <argument><expr>"Row Cache"</expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getRowCacheSize</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getRowCacheCapacityInBytes</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getRowCacheHits</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getRowCacheRequests</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getRowCacheRecentHitRate</name></name><argument_list>()</argument_list></call></expr></argument>,
                    <argument><expr><call><name><name>cacheService</name>.<name>getRowCacheSavePeriodInSeconds</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>printReleaseVersion</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"ReleaseVersion: " + <call><name><name>probe</name>.<name>getReleaseVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>printNetworkStats</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>addr</name></decl></param>, <param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"Mode: %s%n"</expr></argument>, <argument><expr><call><name><name>probe</name>.<name>getOperationMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>hosts</name> <init>= <expr><name>addr</name> == null ? <call><name><name>probe</name>.<name>getStreamDestinations</name></name><argument_list>()</argument_list></call> : new <class><super><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list><block>{<block>{<constructor_decl><name>add</name><parameter_list>(<param><decl><type><name>addr</name></type></decl></param>)</parameter_list>;</constructor_decl>}</block>}</block></class></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>hosts</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"Not sending any streams."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>host</name> <range>: <expr><name>hosts</name></expr></range></decl></init>)
        <block>{
            <try>try
            <block>{
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>files</name> <init>= <expr><call><name><name>probe</name>.<name>getFilesDestinedFor</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>files</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"Streaming to: %s%n"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name>String</name></type> <name>file</name> <range>: <expr><name>files</name></expr></range></decl></init>)
                        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"   %s%n"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>" Nothing streaming to %s%n"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"   Error retrieving file data for %s%n"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
        }</block></for>

        <expr_stmt><expr><name>hosts</name> = <name>addr</name> == null ? <call><name><name>probe</name>.<name>getStreamSources</name></name><argument_list>()</argument_list></call> : new <class><super><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list><block>{<block>{<constructor_decl><name>add</name><parameter_list>(<param><decl><type><name>addr</name></type></decl></param>)</parameter_list>;</constructor_decl> }</block>}</block></class></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>hosts</name>.<name>size</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"Not receiving any streams."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>host</name> <range>: <expr><name>hosts</name></expr></range></decl></init>)
        <block>{
            <try>try
            <block>{
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>files</name> <init>= <expr><call><name><name>probe</name>.<name>getIncomingFiles</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>files</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"Streaming from: %s%n"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name>String</name></type> <name>file</name> <range>: <expr><name>files</name></expr></range></decl></init>)
                        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"   %s%n"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>" Nothing streaming from %s%n"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"   Error retrieving file data for %s%n"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
        }</block></for>

        <decl_stmt><decl><type><name>MessagingServiceMBean</name></type> <name>ms</name> <init>= <expr><name><name>probe</name>.<name>msProxy</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-25s"</expr></argument>, <argument><expr>"Pool Name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%10s"</expr></argument>, <argument><expr>"Active"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%10s"</expr></argument>, <argument><expr>"Pending"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%15s%n"</expr></argument>, <argument><expr>"Completed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>pending</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>completed</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>pending</name> = 0</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>n</name> <range>: <expr><call><name><name>ms</name>.<name>getCommandPendingTasks</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><name>pending</name> += <name>n</name></expr>;</expr_stmt></for>
        <expr_stmt><expr><name>completed</name> = 0</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>long</name></type> <name>n</name> <range>: <expr><call><name><name>ms</name>.<name>getCommandCompletedTasks</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><name>completed</name> += <name>n</name></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-25s%10s%10s%15s%n"</expr></argument>, <argument><expr>"Commands"</expr></argument>, <argument><expr>"n/a"</expr></argument>, <argument><expr><name>pending</name></expr></argument>, <argument><expr><name>completed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>pending</name> = 0</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>n</name> <range>: <expr><call><name><name>ms</name>.<name>getResponsePendingTasks</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><name>pending</name> += <name>n</name></expr>;</expr_stmt></for>
        <expr_stmt><expr><name>completed</name> = 0</expr>;</expr_stmt>
        <for>for (<init><decl><type><name>long</name></type> <name>n</name> <range>: <expr><call><name><name>ms</name>.<name>getResponseCompletedTasks</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><name>completed</name> += <name>n</name></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%-25s%10s%10s%15s%n"</expr></argument>, <argument><expr>"Responses"</expr></argument>, <argument><expr>"n/a"</expr></argument>, <argument><expr><name>pending</name></expr></argument>, <argument><expr><name>completed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>printCompactionStats</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>compactionThroughput</name> <init>= <expr><call><name><name>probe</name>.<name>getCompactionThroughput</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>CompactionManagerMBean</name></type> <name>cm</name> <init>= <expr><call><name><name>probe</name>.<name>getCompactionManagerProxy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"pending tasks: " + <call><name><name>cm</name>.<name>getPendingTasks</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>cm</name>.<name>getCompactions</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%25s%16s%16s%16s%16s%10s%n"</expr></argument>, <argument><expr>"compaction type"</expr></argument>, <argument><expr>"keyspace"</expr></argument>, <argument><expr>"column family"</expr></argument>, <argument><expr>"bytes compacted"</expr></argument>, <argument><expr>"bytes total"</expr></argument>, <argument><expr>"progress"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name>long</name></type> <name>remainingBytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>c</name> <range>: <expr><call><name><name>cm</name>.<name>getCompactions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>percentComplete</name> <init>= <expr>new <call><name>Long</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"totalBytes"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0
                                   ? "n/a"
                                   : new <call><name>DecimalFormat</name><argument_list>(<argument><expr>"0.00"</expr></argument>)</argument_list></call>.<call><name>format</name><argument_list>(<argument><expr>(<name>double</name>) new <call><name>Long</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"bytesComplete"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> / new <call><name>Long</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"totalBytes"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> * 100</expr></argument>)</argument_list></call> + "%"</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%25s%16s%16s%16s%16s%10s%n"</expr></argument>, <argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"taskType"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"keyspace"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"columnfamily"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"bytesComplete"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"totalBytes"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>percentComplete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"taskType"</expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name><name>OperationType</name>.<name>COMPACTION</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>remainingBytes</name> += (new <call><name>Long</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"totalBytes"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> - new <call><name>Long</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>get</name></name><argument_list>(<argument><expr>"bytesComplete"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
        }</block></for>
        <decl_stmt><decl><type><name>long</name></type> <name>remainingTimeInSecs</name> <init>= <expr><name>compactionThroughput</name> == 0 || <name>remainingBytes</name> == 0
                        ? -1 
                        : (<name>remainingBytes</name>) / <call>(<name>long</name>) <argument_list>(<argument><expr>1024L * 1024L * <name>compactionThroughput</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>remainingTime</name> <init>= <expr><name>remainingTimeInSecs</name> &lt; 0 
                        ? "n/a"
                        : <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%dh%02dm%02ds"</expr></argument>, <argument><expr><name>remainingTimeInSecs</name> / 3600</expr></argument>, <argument><expr>(<name>remainingTimeInSecs</name> % 3600) / 60</expr></argument>, <argument><expr>(<name>remainingTimeInSecs</name> % 60)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

        <expr_stmt><expr><call><name><name>outs</name>.<name>printf</name></name><argument_list>(<argument><expr>"%25s%10s%n"</expr></argument>, <argument><expr>"Active compaction remaining time : "</expr></argument>, <argument><expr><name>remainingTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>printColumnFamilyStats</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name> <argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name> <argument_list>&lt;<argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>cfstoreMap</name> <init>= <expr>new <call><name><name>HashMap</name> <argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name> <argument_list>&lt;<argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// get a list of column family stores</comment>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>cfamilies</name> <init>= <expr><call><name><name>probe</name>.<name>getColumnFamilyStoreMBeanProxies</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>cfamilies</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name></type> <name>entry</name> <init>= <expr><call><name><name>cfamilies</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>tableName</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnFamilyStoreMBean</name></type> <name>cfsProxy</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<call><name><name>cfstoreMap</name>.<name>containsKey</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name></type> <name>columnFamilies</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>columnFamilies</name>.<name>add</name></name><argument_list>(<argument><expr><name>cfsProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>cfstoreMap</name>.<name>put</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>cfstoreMap</name>.<name>get</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call>.<call><name>add</name><argument_list>(<argument><expr><name>cfsProxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>

        <comment type="line">// print out the table statistics</comment>
        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>entry</name> <range>: <expr><call><name><name>cfstoreMap</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>tableName</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ColumnFamilyStoreMBean</name></argument>&gt;</argument_list></name></type> <name>columnFamilies</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>tableReadCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>tableWriteCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>tablePendingTasks</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>tableTotalReadTime</name> <init>= <expr>0.0f</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>tableTotalWriteTime</name> <init>= <expr>0.0f</expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"Keyspace: " + <name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>ColumnFamilyStoreMBean</name></type> <name>cfstore</name> <range>: <expr><name>columnFamilies</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>long</name></type> <name>writeCount</name> <init>= <expr><call><name><name>cfstore</name>.<name>getWriteCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>readCount</name> <init>= <expr><call><name><name>cfstore</name>.<name>getReadCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>readCount</name> &gt; 0</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>tableReadCount</name> += <name>readCount</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tableTotalReadTime</name> += <call><name><name>cfstore</name>.<name>getTotalReadLatencyMicros</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>writeCount</name> &gt; 0</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>tableWriteCount</name> += <name>writeCount</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tableTotalWriteTime</name> += <call><name><name>cfstore</name>.<name>getTotalWriteLatencyMicros</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>tablePendingTasks</name> += <call><name><name>cfstore</name>.<name>getPendingTasks</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <decl_stmt><decl><type><name>double</name></type> <name>tableReadLatency</name> <init>= <expr><name>tableReadCount</name> &gt; 0 ? <name>tableTotalReadTime</name> / <name>tableReadCount</name> / 1000 : <name><name>Double</name>.<name>NaN</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>double</name></type> <name>tableWriteLatency</name> <init>= <expr><name>tableWriteCount</name> &gt; 0 ? <name>tableTotalWriteTime</name> / <name>tableWriteCount</name> / 1000 : <name><name>Double</name>.<name>NaN</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\tRead Count: " + <name>tableReadCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\tRead Latency: " + <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><name>tableReadLatency</name></expr></argument>)</argument_list></call> + " ms."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\tWrite Count: " + <name>tableWriteCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\tWrite Latency: " + <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s"</expr></argument>, <argument><expr><name>tableWriteLatency</name></expr></argument>)</argument_list></call> + " ms."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\tPending Tasks: " + <name>tablePendingTasks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// print out column family statistics for this table</comment>
            <for>for (<init><decl><type><name>ColumnFamilyStoreMBean</name></type> <name>cfstore</name> <range>: <expr><name>columnFamilies</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tColumn Family: " + <call><name><name>cfstore</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tSSTable count: " + <call><name><name>cfstore</name>.<name>getLiveSSTableCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tSpace used (live): " + <call><name><name>cfstore</name>.<name>getLiveDiskSpaceUsed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tSpace used (total): " + <call><name><name>cfstore</name>.<name>getTotalDiskSpaceUsed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tNumber of Keys (estimate): " + <call><name><name>cfstore</name>.<name>estimateKeys</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tMemtable Columns Count: " + <call><name><name>cfstore</name>.<name>getMemtableColumnsCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tMemtable Data Size: " + <call><name><name>cfstore</name>.<name>getMemtableDataSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tMemtable Switch Count: " + <call><name><name>cfstore</name>.<name>getMemtableSwitchCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tRead Count: " + <call><name><name>cfstore</name>.<name>getReadCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tRead Latency: " + <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%01.3f"</expr></argument>, <argument><expr><call><name><name>cfstore</name>.<name>getRecentReadLatencyMicros</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call> + " ms."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tWrite Count: " + <call><name><name>cfstore</name>.<name>getWriteCount</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tWrite Latency: " + <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%01.3f"</expr></argument>, <argument><expr><call><name><name>cfstore</name>.<name>getRecentWriteLatencyMicros</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call> + " ms."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tPending Tasks: " + <call><name><name>cfstore</name>.<name>getPendingTasks</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tBloom Filter False Positives: " + <call><name><name>cfstore</name>.<name>getBloomFilterFalsePositives</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tBloom Filter False Ratio: " + <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%01.5f"</expr></argument>, <argument><expr><call><name><name>cfstore</name>.<name>getRecentBloomFilterFalseRatio</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tBloom Filter Space Used: " + <call><name><name>cfstore</name>.<name>getBloomFilterDiskSpaceUsed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tCompacted row minimum size: " + <call><name><name>cfstore</name>.<name>getMinRowSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tCompacted row maximum size: " + <call><name><name>cfstore</name>.<name>getMaxRowSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t\tCompacted row mean size: " + <call><name><name>cfstore</name>.<name>getMeanRowSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"----------------"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>printRemovalStatus</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"RemovalStatus: " + <call><name><name>probe</name>.<name>getRemovalStatus</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printCfHistograms</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keySpace</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>, <param><decl><type><name>PrintStream</name></type> <name>output</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ColumnFamilyStoreMBean</name></type> <name>store</name> <init>= <expr><call><name><name>this</name>.<name>probe</name>.<name>getCfsProxy</name></name><argument_list>(<argument><expr><name>keySpace</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// default is 90 offsets</comment>
        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>offsets</name> <init>= <expr>new <call><name>EstimatedHistogram</name><argument_list>()</argument_list></call>.<call><name>getBucketOffsets</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>rrlh</name> <init>= <expr><call><name><name>store</name>.<name>getRecentReadLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>rwlh</name> <init>= <expr><call><name><name>store</name>.<name>getRecentWriteLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>sprh</name> <init>= <expr><call><name><name>store</name>.<name>getRecentSSTablesPerReadHistogram</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>ersh</name> <init>= <expr><call><name><name>store</name>.<name>getEstimatedRowSizeHistogram</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>ecch</name> <init>= <expr><call><name><name>store</name>.<name>getEstimatedColumnCountHistogram</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s/%s histograms"</expr></argument>, <argument><expr><name>keySpace</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%-10s%10s%18s%18s%18s%18s"</expr></argument>,
                                     <argument><expr>"Offset"</expr></argument>, <argument><expr>"SSTables"</expr></argument>, <argument><expr>"Write Latency"</expr></argument>, <argument><expr>"Read Latency"</expr></argument>, <argument><expr>"Row Size"</expr></argument>, <argument><expr>"Column Count"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>offsets</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%-10d%10s%18s%18s%18s%18s"</expr></argument>,
                                         <argument><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                         <argument><expr>(<name>i</name> &lt; <name><name>sprh</name>.<name>length</name></name> ? <name><name>sprh</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>,
                                         <argument><expr>(<name>i</name> &lt; <name><name>rwlh</name>.<name>length</name></name> ? <name><name>rwlh</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>,
                                         <argument><expr>(<name>i</name> &lt; <name><name>rrlh</name>.<name>length</name></name> ? <name><name>rrlh</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>,
                                         <argument><expr>(<name>i</name> &lt; <name><name>ersh</name>.<name>length</name></name> ? <name><name>ersh</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>,
                                         <argument><expr>(<name>i</name> &lt; <name><name>ecch</name>.<name>length</name></name> ? <name><name>ecch</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printProxyHistograms</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>output</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>StorageProxyMBean</name></type> <name>sp</name> <init>= <expr><call><name><name>this</name>.<name>probe</name>.<name>getSpProxy</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>offsets</name> <init>= <expr>new <call><name>EstimatedHistogram</name><argument_list>()</argument_list></call>.<call><name>getBucketOffsets</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>rrlh</name> <init>= <expr><call><name><name>sp</name>.<name>getRecentReadLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>rwlh</name> <init>= <expr><call><name><name>sp</name>.<name>getRecentWriteLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name><index>[]</index></type> <name>rrnglh</name> <init>= <expr><call><name><name>sp</name>.<name>getRecentRangeLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr>"proxy histograms"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%-10s%10s%18s%18s"</expr></argument>,
                                        <argument><expr>"Offset"</expr></argument>, <argument><expr>"Read Latency"</expr></argument>, <argument><expr>"Write Latency"</expr></argument>, <argument><expr>"Range Latency"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>offsets</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%-10d%18s%18s%18s"</expr></argument>,
                                            <argument><expr><name><name>offsets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                            <argument><expr>(<name>i</name> &lt; <name><name>rrlh</name>.<name>length</name></name> ? <name><name>rrlh</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>,
                                            <argument><expr>(<name>i</name> &lt; <name><name>rwlh</name>.<name>length</name></name> ? <name><name>rwlh</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>,
                                            <argument><expr>(<name>i</name> &lt; <name><name>rrnglh</name>.<name>length</name></name> ? <name><name>rrnglh</name><index>[<expr><name>i</name></expr>]</index></name> : "0")</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printEndPoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keySpace</name></decl></param>, <param><decl><type><name>String</name></type> <name>cf</name></decl></param>, <param><decl><type><name>String</name></type> <name>key</name></decl></param>, <param><decl><type><name>PrintStream</name></type> <name>output</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name><name>this</name>.<name>probe</name>.<name>getEndpoints</name></name><argument_list>(<argument><expr><name>keySpace</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>InetAddress</name></type> <name>anEndpoint</name> <range>: <expr><name>endpoints</name></expr></range></decl></init>)
        <block>{
           <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>anEndpoint</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printSSTables</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name>String</name></type> <name>cf</name></decl></param>, <param><decl><type><name>String</name></type> <name>key</name></decl></param>, <param><decl><type><name>PrintStream</name></type> <name>output</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name><name>this</name>.<name>probe</name>.<name>getSSTables</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>output</name>.<name>println</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printIsThriftServerRunning</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>probe</name>.<name>isThriftServerRunning</name></name><argument_list>()</argument_list></call> ? "running" : "not running"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>main</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>args</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument>, <argument><expr><name>ParseException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>CommandLineParser</name></type> <name>parser</name> <init>= <expr>new <call><name>PosixParser</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ToolCommandLine</name></type> <name>cmd</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>

        <try>try
        <block>{
            <expr_stmt><expr><name>cmd</name> = new <call><name>ToolCommandLine</name><argument_list>(<argument><expr><call><name><name>parser</name>.<name>parse</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ParseException</name></type> <name>p</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr><call><name><name>p</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></catch></try>

        <decl_stmt><decl><type><name>String</name></type> <name>host</name> <init>= <expr><call><name><name>cmd</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name><name>HOST_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call> ? <call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>HOST_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call> : <name>DEFAULT_HOST</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>port</name> <init>= <expr><name>DEFAULT_PORT</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>String</name></type> <name>portNum</name> <init>= <expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>PORT_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>portNum</name> != null</expr>)</condition><then>
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><name>port</name> = <call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name>portNum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>NumberFormatException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>ParseException</name><argument_list>(<argument><expr>"Port must be a number"</expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then></if>

        <decl_stmt><decl><type><name>String</name></type> <name>username</name> <init>= <expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>USERNAME_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>password</name> <init>= <expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>PASSWORD_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>NodeProbe</name></type> <name>probe</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>probe</name> = <name>username</name> == null ? new <call><name>NodeProbe</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call> : new <call><name>NodeProbe</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>ioe</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>Throwable</name></type> <name>inner</name> <init>= <expr><call><name>findInnermostThrowable</name><argument_list>(<argument><expr><name>ioe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>inner</name> instanceof <name>ConnectException</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>printf</name></name><argument_list>(<argument><expr>"Failed to connect to '%s:%d': %s\n"</expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr><call><name><name>inner</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>inner</name> instanceof <name>UnknownHostException</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>printf</name></name><argument_list>(<argument><expr>"Cannot resolve '%s': unknown host\n"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>ioe</name></expr></argument>, <argument><expr>"Error connecting to remote JMX agent!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></catch></try>
        <try>try
        <block>{
            <decl_stmt><decl><type><name>NodeCommand</name></type> <name>command</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>

            <try>try
            <block>{
                <expr_stmt><expr><name>command</name> = <call><name><name>cmd</name>.<name>getCommand</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IllegalArgumentException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>


            <decl_stmt><decl><type><name>NodeCmd</name></type> <name>nodeCmd</name> <init>= <expr>new <call><name>NodeCmd</name><argument_list>(<argument><expr><name>probe</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Execute the requested command.</comment>
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>arguments</name> <init>= <expr><call><name><name>cmd</name>.<name>getCommandArguments</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>tag</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>columnFamilyName</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>

            <switch>switch <condition>(<expr><name>command</name></expr>)</condition>
            <block>{
                <case>case <expr><name>RING</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printRing</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then>
                    <else>else                      <block>{ <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printRing</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>, <argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></else></if><empty_stmt>;</empty_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>INFO</name></expr>            : <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printInfo</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>CFSTATS</name></expr>         : <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printColumnFamilyStats</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>TPSTATS</name></expr>         : <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printThreadPoolStats</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>VERSION</name></expr>         : <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printReleaseVersion</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>COMPACTIONSTATS</name></expr> : <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printCompactionStats</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>DISABLEGOSSIP</name></expr>   : <expr_stmt><expr><call><name><name>probe</name>.<name>stopGossiping</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>ENABLEGOSSIP</name></expr>    : <expr_stmt><expr><call><name><name>probe</name>.<name>startGossiping</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>DISABLETHRIFT</name></expr>   : <expr_stmt><expr><call><name><name>probe</name>.<name>stopThriftServer</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>ENABLETHRIFT</name></expr>    : <expr_stmt><expr><call><name><name>probe</name>.<name>startThriftServer</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>STATUSTHRIFT</name></expr>    : <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printIsThriftServerRunning</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr><name>RESETLOCALSCHEMA</name></expr>: <expr_stmt><expr><call><name><name>probe</name>.<name>resetLocalSchema</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>

                </case><case>case <expr><name>DECOMMISSION</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> &gt; 0</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr>"Decommission will decommission the node you are connected to and does not take arguments!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>decommission</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>DRAIN</name></expr> :
                    <try>try <block>{ <expr_stmt><expr><call><name><name>probe</name>.<name>drain</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>ee</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>ee</name></expr></argument>, <argument><expr>"Error occured during flushing"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></catch></try>
                    <break>break;</break>

                </case><case>case <expr><name>NETSTATS</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printNetworkStats</name></name><argument_list>(<argument><expr><call><name><name>InetAddress</name>.<name>getByName</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then>
                    <else>else                      <block>{ <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printNetworkStats</name></name><argument_list>(<argument><expr>null</expr></argument>, <argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></else></if>
                    <break>break;</break>

                </case><case>case <expr><name>SNAPSHOT</name></expr> :
                    <expr_stmt><expr><name>columnFamilyName</name> = <call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>SNAPSHOT_COLUMNFAMILY_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <comment type="block">/* FALL THRU */</comment>
                </case><case>case <expr><name>CLEARSNAPSHOT</name></expr> :
                    <expr_stmt><expr><name>tag</name> = <call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>TAG_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>handleSnapshots</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name>columnFamilyName</name></expr></argument>, <argument><expr><name>probe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>MOVE</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 1</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Missing token argument for move."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>move</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>JOIN</name></expr>:
                    <if>if <condition>(<expr><call><name><name>probe</name>.<name>isJoined</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr>"This node has already joined the ring."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <expr_stmt><expr><call><name><name>probe</name>.<name>joinRing</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>SETCOMPACTIONTHROUGHPUT</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 1</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Missing value argument."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>setCompactionThroughput</name></name><argument_list>(<argument><expr><call><name><name>Integer</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>SETSTREAMTHROUGHPUT</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 1</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Missing value argument."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>setStreamThroughput</name></name><argument_list>(<argument><expr><call><name><name>Integer</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>REBUILD</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> &gt; 1</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Too many arguments."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>rebuild</name></name><argument_list>(<argument><expr><name><name>arguments</name>.<name>length</name></name> == 1 ? <name><name>arguments</name><index>[<expr>0</expr>]</index></name> : null</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>REMOVETOKEN</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 1</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Missing an argument for removetoken (either status, force, or a token)"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then>
                    <else>else <if>if <condition>(<expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr>"status"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printRemovalStatus</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then>
                    <else>else <if>if <condition>(<expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr>"force"</expr></argument>)</argument_list></call></expr>)</condition><then>  <block>{ <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printRemovalStatus</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name><name>probe</name>.<name>forceRemoveCompletion</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> }</block></then>
                    <else>else                                    <block>{ <expr_stmt><expr><call><name><name>probe</name>.<name>removeToken</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></else></if></else></if></else></if>
                    <break>break;</break>

                </case><case>case <expr><name>INVALIDATEKEYCACHE</name></expr> :
                    <expr_stmt><expr><call><name><name>probe</name>.<name>invalidateKeyCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>INVALIDATEROWCACHE</name></expr> :
                    <expr_stmt><expr><call><name><name>probe</name>.<name>invalidateRowCache</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>CLEANUP</name></expr> :
                </case><case>case <expr><name>COMPACT</name></expr> :
                </case><case>case <expr><name>REPAIR</name></expr>  :
                </case><case>case <expr><name>FLUSH</name></expr>   :
                </case><case>case <expr><name>SCRUB</name></expr>   :
                </case><case>case <expr><name>UPGRADESSTABLES</name></expr>   :
                    <expr_stmt><expr><call><name>optionalKSandCFs</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>, <argument><expr><name>probe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>GETCOMPACTIONTHRESHOLD</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 2</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"getcompactionthreshold requires ks and cf args."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>getCompactionThreshold</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>CFHISTOGRAMS</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 2</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"cfhistograms requires ks and cf args"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printCfHistograms</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>SETCACHECAPACITY</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 2</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"setcachecapacity requires key-cache-capacity, and row-cache-capacity args."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>setCacheCapacities</name></name><argument_list>(<argument><expr><call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>SETCOMPACTIONTHRESHOLD</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 4</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"setcompactionthreshold requires ks, cf, min, and max threshold args."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <decl_stmt><decl><type><name>int</name></type> <name>minthreshold</name> <init>= <expr><call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>maxthreshold</name> <init>= <expr><call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>(<name>minthreshold</name> &lt; 0) || (<name>maxthreshold</name> &lt; 0)</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Thresholds must be positive integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <if>if <condition>(<expr><name>minthreshold</name> &gt; <name>maxthreshold</name></expr>)</condition><then>              <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Min threshold cannot be greater than max."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <if>if <condition>(<expr><name>minthreshold</name> &lt; 2 &amp;&amp; <name>maxthreshold</name> != 0</expr>)</condition><then>    <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Min threshold must be at least 2"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>setCompactionThreshold</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>minthreshold</name></expr></argument>, <argument><expr><name>maxthreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>GETENDPOINTS</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 3</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"getendpoints requires ks, cf and key args"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printEndPoints</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>GETSSTABLES</name></expr>:
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 3</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"getsstables requires ks, cf and key args"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printSSTables</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>PROXYHISTOGRAMS</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 0</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"proxyhistograms does not take arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printProxyHistograms</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>REFRESH</name></expr>:
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 2</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"load_new_sstables requires ks and cf args"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>loadNewSSTables</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>REBUILD_INDEX</name></expr>:
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> &lt; 2</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"rebuild_index requires ks and cf args"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> &gt;= 3</expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>probe</name>.<name>rebuildIndex</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>2</expr>]</index></name>.<call><name>split</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                    <else>else
                        <expr_stmt><expr><call><name><name>probe</name>.<name>rebuildIndex</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>arguments</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

                    <break>break;</break>

                </case><case>case <expr><name>GOSSIPINFO</name></expr> : <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printGossipInfo</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

                </case><case>case <expr><name>STOP</name></expr>:
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 1</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"stop requires a type."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>probe</name>.<name>stop</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name>.<call><name>toUpperCase</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>DESCRIBERING</name></expr> :
                    <if>if <condition>(<expr><name><name>arguments</name>.<name>length</name></name> != 1</expr>)</condition><then> <block>{ <expr_stmt><expr><call><name>badUse</name><argument_list>(<argument><expr>"Missing keyspace argument for describering."</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
                    <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printDescribeRing</name></name><argument_list>(<argument><expr><name><name>arguments</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr><name>RANGEKEYSAMPLE</name></expr> :
                    <expr_stmt><expr><call><name><name>nodeCmd</name>.<name>printRangeKeySample</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>

                </case><default>default :
                    <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Unreachable code."</expr></argument>)</argument_list></call></expr>;</throw>
            </default>}</block></switch>
        }</block>
        <finally>finally
        <block>{
            <if>if <condition>(<expr><name>probe</name> != null</expr>)</condition><then>
            <block>{
                <try>try
                <block>{
                    <expr_stmt><expr><call><name><name>probe</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>)</parameter_list>
                <block>{
                    <comment type="line">// swallow the exception so the user will see the real one.</comment>
                }</block></catch></try>
            }</block></then></if>
        }</block></finally></try>
        <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr><call><name><name>probe</name>.<name>isFailed</name></name><argument_list>()</argument_list></call> ? 1 : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>Throwable</name></type> <name>findInnermostThrowable</name><parameter_list>(<param><decl><type><name>Throwable</name></type> <name>ex</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Throwable</name></type> <name>inner</name> <init>= <expr><call><name><name>ex</name>.<name>getCause</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>inner</name> == null ? <name>ex</name> : <call><name>findInnermostThrowable</name><argument_list>(<argument><expr><name>inner</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printDescribeRing</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspaceName</name></decl></param>, <param><decl><type><name>PrintStream</name></type> <name>out</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Schema Version:" + <call><name><name>probe</name>.<name>getSchemaVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"TokenRange: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <for>for (<init><decl><type><name>String</name></type> <name>tokenRangeString</name> <range>: <expr><call><name><name>probe</name>.<name>describeRing</name></name><argument_list>(<argument><expr><name>keyspaceName</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"\t" + <name>tokenRangeString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InvalidRequestException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getWhy</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printRangeKeySample</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>outs</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"RangeKeySample: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tokenStrings</name> <init>= <expr><call><name><name>this</name>.<name>probe</name>.<name>sampleKeyRange</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>tokenString</name> <range>: <expr><name>tokenStrings</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>outs</name>.<name>println</name></name><argument_list>(<argument><expr>"\t" + <name>tokenString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>printGossipInfo</name><parameter_list>(<param><decl><type><name>PrintStream</name></type> <name>out</name></decl></param>)</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>out</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>probe</name>.<name>getGossipInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>badUse</name><parameter_list>(<param><decl><type><name>String</name></type> <name>useStr</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr><name>useStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>printUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>err</name><parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>, <param><decl><type><name>String</name></type> <name>errStr</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr><name>errStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>e</name>.<name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>complainNonzeroArgs</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>args</name></decl></param>, <param><decl><type><name>NodeCommand</name></type> <name>cmd</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name><name>args</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr>"Too many arguments for command '"+<call><name><name>cmd</name>.<name>toString</name></name><argument_list>()</argument_list></call>+"'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>handleSnapshots</name><parameter_list>(<param><decl><type><name>NodeCommand</name></type> <name>nc</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>cmdArgs</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>, <param><decl><type><name>NodeProbe</name></type> <name>probe</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>keyspaces</name> <init>= <expr><call><name><name>Arrays</name>.<name>copyOfRange</name></name><argument_list>(<argument><expr><name>cmdArgs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cmdArgs</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>"Requested snapshot for: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>( <expr><name><name>keyspaces</name>.<name>length</name></name> &gt; 0</expr> )</condition><then>
        <block>{
          <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>keyspaces</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
              <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr><name><name>keyspaces</name><index>[<expr><name>i</name></expr>]</index></name> + " "</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>"all keyspaces "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>columnFamily</name> != null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>print</name></name><argument_list>(<argument><expr>"and column family: " + <name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>nc</name></expr>)</condition>
        <block>{
            <case>case <expr><name>SNAPSHOT</name></expr> :
                <if>if <condition>(<expr><name>tag</name> == null || <call><name><name>tag</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>tag</name> = new <call><name>Long</name><argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name><name>probe</name>.<name>takeSnapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>keyspaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Snapshot directory: " + <name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr><name>CLEARSNAPSHOT</name></expr> :
                <expr_stmt><expr><call><name><name>probe</name>.<name>clearSnapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>keyspaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
        </case>}</block></switch>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>optionalKSandCFs</name><parameter_list>(<param><decl><type><name>NodeCommand</name></type> <name>nc</name></decl></param>, <param><decl><type><name>ToolCommandLine</name></type> <name>cmd</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>cmdArgs</name></decl></param>, <param><decl><type><name>NodeProbe</name></type> <name>probe</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <comment type="line">// if there is one additional arg, it's the keyspace; more are columnfamilies</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>keyspaces</name> <init>= <expr><name><name>cmdArgs</name>.<name>length</name></name> == 0 ? <call><name><name>probe</name>.<name>getKeyspaces</name></name><argument_list>()</argument_list></call> : <call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name><name>cmdArgs</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>keyspace</name> <range>: <expr><name>keyspaces</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr>!<call><name><name>probe</name>.<name>getKeyspaces</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr>"Keyspace [" + <name>keyspace</name> + "] does not exist."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <comment type="line">// second loop so we're less likely to die halfway through due to invalid keyspace</comment>
        <for>for (<init><decl><type><name>String</name></type> <name>keyspace</name> <range>: <expr><name>keyspaces</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>columnFamilies</name> <init>= <expr><name><name>cmdArgs</name>.<name>length</name></name> &lt;= 1 ? new <name><name>String</name><index>[<expr>0</expr>]</index></name> : <call><name><name>Arrays</name>.<name>copyOfRange</name></name><argument_list>(<argument><expr><name>cmdArgs</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name><name>cmdArgs</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>nc</name></expr>)</condition>
            <block>{
                <case>case <expr><name>REPAIR</name></expr>  :
                    <decl_stmt><decl><type><name>boolean</name></type> <name>snapshot</name> <init>= <expr><call><name><name>cmd</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name><name>SNAPSHOT_REPAIR_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>primaryRange</name> <init>= <expr><call><name><name>cmd</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name><name>PRIMARY_RANGE_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>cmd</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name><name>START_TOKEN_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call> || <call><name><name>cmd</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name><name>END_TOKEN_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>probe</name>.<name>forceRepairRangeAsync</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>START_TOKEN_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name><name>END_TOKEN_OPT</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                    <else>else
                        <expr_stmt><expr><call><name><name>probe</name>.<name>forceRepairAsync</name></name><argument_list>(<argument><expr><name><name>System</name>.<name>out</name></name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>, <argument><expr><name>primaryRange</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                    <break>break;</break>
                </case><case>case <expr><name>FLUSH</name></expr>   :
                    <try>try <block>{ <expr_stmt><expr><call><name><name>probe</name>.<name>forceTableFlush</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>ee</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>ee</name></expr></argument>, <argument><expr>"Error occurred during flushing"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></catch></try>
                    <break>break;</break>
                </case><case>case <expr><name>COMPACT</name></expr> :
                    <try>try <block>{ <expr_stmt><expr><call><name><name>probe</name>.<name>forceTableCompaction</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>ee</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>ee</name></expr></argument>, <argument><expr>"Error occurred during compaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></catch></try>
                    <break>break;</break>
                </case><case>case <expr><name>CLEANUP</name></expr> :
                    <if>if <condition>(<expr><call><name><name>keyspace</name>.<name>equals</name></name><argument_list>(<argument><expr>"system"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <break>break;</break> }</block></then></if> <comment type="line">// Skip cleanup on system cfs.</comment>
                    <try>try <block>{ <expr_stmt><expr><call><name><name>probe</name>.<name>forceTableCleanup</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>ee</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>ee</name></expr></argument>, <argument><expr>"Error occurred during cleanup"</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></catch></try>
                    <break>break;</break>
                </case><case>case <expr><name>SCRUB</name></expr> :
                    <try>try <block>{ <expr_stmt><expr><call><name><name>probe</name>.<name>scrub</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>ee</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>ee</name></expr></argument>, <argument><expr>"Error occurred while scrubbing keyspace " + <name>keyspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></catch></try>
                    <break>break;</break>
                </case><case>case <expr><name>UPGRADESSTABLES</name></expr> :
                    <try>try <block>{ <expr_stmt><expr><call><name><name>probe</name>.<name>upgradeSSTables</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>ee</name></decl></param>)</parameter_list> <block>{ <expr_stmt><expr><call><name>err</name><argument_list>(<argument><expr><name>ee</name></expr></argument>, <argument><expr>"Error occurred while upgrading the sstables for keyspace " + <name>keyspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></catch></try>
                    <break>break;</break>
                </case><default>default:
                    <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Unreachable code."</expr></argument>)</argument_list></call></expr>;</throw>
            </default>}</block></switch>
        }</block></for>
    }</block></function>


    <class><specifier>private</specifier> <specifier>static</specifier> class <name>ToolOptions</name> <super><extends>extends <name>Options</name></extends></super>
    <block>{
        <function><type><specifier>public</specifier> <name>void</name></type> <name>addOption</name><parameter_list>(<param><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>opts</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>hasArgument</name></decl></param>, <param><decl><type><name>String</name></type> <name>description</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>addOption</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><name>hasArgument</name></expr></argument>, <argument><expr><name>description</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>addOption</name><parameter_list>(<param><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>opts</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>hasArgument</name></decl></param>, <param><decl><type><name>String</name></type> <name>description</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>required</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>addOption</name><argument_list>(<argument><expr><name><name>opts</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>opts</name>.<name>right</name></name></expr></argument>, <argument><expr><name>hasArgument</name></expr></argument>, <argument><expr><name>description</name></expr></argument>, <argument><expr><name>required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>addOption</name><parameter_list>(<param><decl><type><name>String</name></type> <name>opt</name></decl></param>, <param><decl><type><name>String</name></type> <name>longOpt</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>hasArgument</name></decl></param>, <param><decl><type><name>String</name></type> <name>description</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>required</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>Option</name></type> <name>option</name> <init>= <expr>new <call><name>Option</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>longOpt</name></expr></argument>, <argument><expr><name>hasArgument</name></expr></argument>, <argument><expr><name>description</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>option</name>.<name>setRequired</name></name><argument_list>(<argument><expr><name>required</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>addOption</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></function>
    }</block></class>

    <class><specifier>private</specifier> <specifier>static</specifier> class <name>ToolCommandLine</name>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>CommandLine</name></type> <name>commandLine</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>ToolCommandLine</name><parameter_list>(<param><decl><type><name>CommandLine</name></type> <name>commands</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>commandLine</name> = <name>commands</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>Option</name><index>[]</index></type> <name>getOptions</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>commandLine</name>.<name>getOptions</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasOption</name><parameter_list>(<param><decl><type><name>String</name></type> <name>opt</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><call><name><name>commandLine</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>String</name></type> <name>getOptionValue</name><parameter_list>(<param><decl><type><name>String</name></type> <name>opt</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><call><name><name>commandLine</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>NodeCommand</name></type> <name>getCommand</name><parameter_list>()</parameter_list>
        <block>{
            <if>if <condition>(<expr><call><name><name>commandLine</name>.<name>getArgs</name></name><argument_list>()</argument_list></call>.<name>length</name> == 0</expr>)</condition><then>
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Command was not specified."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name>String</name></type> <name>command</name> <init>= <expr><call><name><name>commandLine</name>.<name>getArgs</name></name><argument_list>()</argument_list></call><index>[<expr>0</expr>]</index></expr></init></decl>;</decl_stmt>

            <try>try
            <block>{
                <return>return <expr><call><name><name>NodeCommand</name>.<name>valueOf</name></name><argument_list>(<argument><expr><call><name><name>command</name>.<name>toUpperCase</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IllegalArgumentException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Unrecognized command: " + <name>command</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></function>

        <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getCommandArguments</name><parameter_list>()</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>List</name></type> <name>params</name> <init>= <expr><call><name><name>commandLine</name>.<name>getArgList</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>params</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; 2</expr>)</condition><then> <comment type="line">// command parameters are empty</comment>
                <return>return <expr>new <name><name>String</name><index>[<expr>0</expr>]</index></name></expr>;</return></then></if>

            <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>toReturn</name> <init>= <expr>new <name><name>String</name><index>[<expr><call><name><name>params</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>params</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <expr_stmt><expr><name><name>toReturn</name><index>[<expr><name>i</name> - 1</expr>]</index></name> = (<name>String</name>) <call><name><name>params</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

            <return>return <expr><name>toReturn</name></expr>;</return>
        }</block></function>
    }</block></class>
}
</unit>
