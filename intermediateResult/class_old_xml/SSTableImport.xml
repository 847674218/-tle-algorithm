<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\tools\SSTableImport.java"><comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>tools</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>Schema</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>AbstractType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>BytesType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>MarshalException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>ByteBufferUtil</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>cli</name></name>.*;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>ConfigurationException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>QueryPath</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>IPartitioner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name>.<name>SSTableWriter</name></name>;</import>
<import>import <name><name>org</name>.<name>codehaus</name>.<name>jackson</name>.<name>type</name>.<name>TypeReference</name></name>;</import>

<import>import <name><name>org</name>.<name>codehaus</name>.<name>jackson</name>.<name>JsonFactory</name></name>;</import>
<import>import <name><name>org</name>.<name>codehaus</name>.<name>jackson</name>.<name>map</name>.<name>MappingJsonFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>codehaus</name>.<name>jackson</name>.<name>JsonParser</name></name>;</import>

<import>import static <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>ByteBufferUtil</name>.<name>hexToBytes</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Create SSTables from JSON input
 */</comment>
<class><specifier>public</specifier> class <name>SSTableImport</name>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>KEYSPACE_OPTION</name> <init>= <expr>"K"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>COLUMN_FAMILY_OPTION</name> <init>= <expr>"c"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>KEY_COUNT_OPTION</name> <init>= <expr>"n"</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>String</name></type> <name>IS_SORTED_OPTION</name> <init>= <expr>"s"</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>Options</name></type> <name>options</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>CommandLine</name></type> <name>cmd</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>Integer</name></type> <name>keyCountToImport</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isSorted</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>JsonFactory</name></type> <name>factory</name> <init>= <expr>new <call><name>MappingJsonFactory</name><argument_list>()</argument_list></call>.<call><name>configure</name><argument_list>(<argument><expr><name><name>JsonParser</name>.<name>Feature</name>.<name>INTERN_FIELD_NAMES</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>static
    <block>{
        <expr><name>options</name> = new <call><name>Options</name><argument_list>()</argument_list></call></expr>;

        <expr><name>Option</name> <name>optKeyspace</name> = new <call><name>Option</name><argument_list>(<argument><expr><name>KEYSPACE_OPTION</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"Keyspace name."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>optKeyspace</name>.<name>setRequired</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>optKeyspace</name></expr></argument>)</argument_list></call></expr>;

        <expr><name>Option</name> <name>optColfamily</name> = new <call><name>Option</name><argument_list>(<argument><expr><name>COLUMN_FAMILY_OPTION</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"Column Family name."</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>optColfamily</name>.<name>setRequired</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr><name>optColfamily</name></expr></argument>)</argument_list></call></expr>;

        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr>new <call><name>Option</name><argument_list>(<argument><expr><name>KEY_COUNT_OPTION</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr>"Number of keys to import (Optional)."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
        <expr><call><name><name>options</name>.<name>addOption</name></name><argument_list>(<argument><expr>new <call><name>Option</name><argument_list>(<argument><expr><name>IS_SORTED_OPTION</name></expr></argument>, <argument><expr>false</expr></argument>, <argument><expr>"Assume JSON file as already sorted (e.g. created by sstable2json tool) (Optional)."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
    }</block>

    private static <name>class</name> <name><name>JsonColumn</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>
    <block>{
        <expr>private <name>ByteBuffer</name> <name>name</name></expr>;
        <expr>private <name>ByteBuffer</name> <name>value</name></expr>;
        <expr>private <name>long</name> <name>timestamp</name></expr>;

        <expr>private <name>String</name> <name>kind</name></expr>;
        <comment type="line">// Expiring columns</comment>
        <expr>private <name>int</name> <name>ttl</name></expr>;
        <expr>private <name>int</name> <name>localExpirationTime</name></expr>;

        <comment type="line">// Counter columns</comment>
        <expr>private <name>long</name> <name>timestampOfLastDelete</name></expr>;

        <expr>public <call><name>JsonColumn</name><argument_list>(<argument><expr><name>T</name> <name>json</name></expr></argument>, <argument><expr><name>CFMetaData</name> <name>meta</name></expr></argument>, <argument><expr><name>boolean</name> <name>isSubColumn</name></expr></argument>)</argument_list></call>
        <block>{
            <if>if <condition>(<expr><name>json</name> instanceof <name>List</name></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>comparator</name> <init>= <expr>(<name>isSubColumn</name>) ? <name><name>meta</name>.<name>subcolumnComparator</name></name> : <name><name>meta</name>.<name>comparator</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>List</name></type> <name>fields</name> <init>= <expr>(<name><name>List</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name>) <name>json</name></expr></init></decl>;</decl_stmt>

                <assert>assert <expr><call><name><name>fields</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt;= 3 : "Column definition should have at least 3"</expr>;</assert>

                <expr_stmt><expr><name>name</name>  = <call><name>stringAsType</name><argument_list>(<argument><expr>(<name>String</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>timestamp</name> = (<name>Long</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>kind</name> = ""</expr>;</expr_stmt>

                <if>if <condition>(<expr><call><name><name>fields</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 3</expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call> instanceof <name>Boolean</name></expr>)</condition><then>
                    <block>{
                        <comment type="line">// old format, reading this for backward compatibility sake</comment>
                        <if>if <condition>(<expr><call><name><name>fields</name>.<name>size</name></name><argument_list>()</argument_list></call> == 6</expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>kind</name> = "e"</expr>;</expr_stmt>
                            <expr_stmt><expr><name>ttl</name> = (<name>Integer</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>localExpirationTime</name> = (<name>Integer</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt/></block></then></if></block></then></if></block></then></if></block></then></if>}</block></expr>
                        <else>else
                        <block>{
                            <expr_stmt><expr><name>kind</name> = ((<name>Boolean</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call>) ? "d" : ""</expr>;</expr_stmt>
                        <expr_stmt/></block></else>}</block></expr></expr_stmt>
                    }</block></class>
                    <else>else
                    <block>{
                        <expr_stmt><expr><name>kind</name> = (<name>String</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>isExpiring</name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>ttl</name> = (<name>Integer</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>localExpirationTime</name> = (<name>Integer</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <if>if <condition>(<expr><call><name>isCounter</name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <block>{
                            <expr_stmt><expr><name>timestampOfLastDelete</name> = <call>(<name>long</name>) <argument_list>(<argument><expr>(<name>Integer</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if></else></if>
                    }</block></else>
                }

                value <expr_stmt><expr>= <call><name>isDeleted</name><argument_list>()</argument_list></call> ? <call><name><name>ByteBufferUtil</name>.<name>hexToBytes</name></name><argument_list>(<argument><expr>(<name>String</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                                    : <call><name>stringAsType</name><argument_list>(<argument><expr>(<name>String</name>) <call><name><name>fields</name>.<name>get</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>meta</name>.<name>getValueValidator</name></name><argument_list>(<argument><expr><call><name><name>name</name>.<name>duplicate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }
        }

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isDeleted</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>kind</name>.<name>equals</name></name><argument_list>(<argument><expr>"d"</expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isExpiring</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>kind</name>.<name>equals</name></name><argument_list>(<argument><expr>"e"</expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isCounter</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>kind</name>.<name>equals</name></name><argument_list>(<argument><expr>"c"</expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>getName</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>name</name>.<name>duplicate</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>getValue</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>value</name>.<name>duplicate</name></name><argument_list>()</argument_list></call></expr>;</return>
        }</block></function>
    }

    private <function><type><specifier>static</specifier> <name>void</name></type> <name>addToStandardCF</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>row</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>cfamily</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>addColumnsToCF</name><argument_list>(<argument><expr><name>row</name></expr></argument>, <argument><expr>null</expr></argument>, <argument><expr><name>cfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Add columns to a column family.
     *
     * @param row the columns associated with a row
     * @param superName name of the super column if any
     * @param cfamily the column family to add columns to
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>addColumnsToCF</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>row</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>superName</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>cfamily</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>CFMetaData</name></type> <name>cfm</name> <init>= <expr><call><name><name>cfamily</name>.<name>metadata</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>cfm</name> != null</expr>;</assert>

        <for>for (<init><decl><type><name>Object</name></type> <name>c</name> <range>: <expr><name>row</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>JsonColumn</name></type> <name>col</name> <init>= <expr>new <call><name><name>JsonColumn</name><argument_list>&lt;<argument><name>List</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>(<name>List</name>) <name>c</name></expr></argument>, <argument><expr><name>cfm</name></expr></argument>, <argument><expr>(<name>superName</name> != null)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>QueryPath</name></type> <name>path</name> <init>= <expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><name><name>cfm</name>.<name>cfName</name></name></expr></argument>, <argument><expr><name>superName</name></expr></argument>, <argument><expr><call><name><name>col</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>col</name>.<name>isExpiring</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>cfamily</name>.<name>addColumn</name></name><argument_list>(<argument><expr>null</expr></argument>, <argument><expr>new <call><name>ExpiringColumn</name><argument_list>(<argument><expr><call><name><name>col</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>col</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>col</name>.<name>timestamp</name></name></expr></argument>, <argument><expr><name><name>col</name>.<name>ttl</name></name></expr></argument>, <argument><expr><name><name>col</name>.<name>localExpirationTime</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>col</name>.<name>isCounter</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>cfamily</name>.<name>addColumn</name></name><argument_list>(<argument><expr>null</expr></argument>, <argument><expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><call><name><name>col</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>col</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>col</name>.<name>timestamp</name></name></expr></argument>, <argument><expr><name><name>col</name>.<name>timestampOfLastDelete</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>col</name>.<name>isDeleted</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>cfamily</name>.<name>addTombstone</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name><name>col</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>col</name>.<name>timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>cfamily</name>.<name>addColumn</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name><name>col</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>col</name>.<name>timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if></else></if>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Add super columns to a column family.
     *
     * @param row the super columns associated with a row
     * @param cfamily the column family to add columns to
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>addToSuperCF</name><parameter_list>(<param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>row</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>cfamily</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>CFMetaData</name></type> <name>metaData</name> <init>= <expr><call><name><name>cfamily</name>.<name>metadata</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>metaData</name> != null</expr>;</assert>

        <decl_stmt><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>comparator</name> <init>= <expr><name><name>metaData</name>.<name>comparator</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// Super columns</comment>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>row</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>data</name> <init>= <expr>(<name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name>) <call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>addColumnsToCF</name><argument_list>(<argument><expr>(<name><name>List</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name>) <call><name><name>data</name>.<name>get</name></name><argument_list>(<argument><expr>"subColumns"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>stringAsType</name><argument_list>(<argument><expr>(<name>String</name>) <call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>comparator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// *WARNING* markForDeleteAt has been DEPRECATED at Cassandra side</comment>
            <comment type="line">//BigInteger deletedAt = (BigInteger) data.get("deletedAt");</comment>
            <comment type="line">//SuperColumn superColumn = (SuperColumn) cfamily.getColumn(superName);</comment>
            <comment type="line">//superColumn.markForDeleteAt((int) (System.currentTimeMillis()/1000), deletedAt);</comment>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a JSON formatted file to an SSTable.
     *
     * @param jsonFile the file containing JSON formatted data
     * @param keyspace keyspace the data belongs to
     * @param cf column family the data belongs to
     * @param ssTablePath file to write the SSTable to
     *
     * @throws IOException for errors reading/writing input/output
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>importJson</name><parameter_list>(<param><decl><type><name>String</name></type> <name>jsonFile</name></decl></param>, <param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name>String</name></type> <name>cf</name></decl></param>, <param><decl><type><name>String</name></type> <name>ssTablePath</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>columnFamily</name> <init>= <expr><call><name><name>ColumnFamily</name>.<name>create</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>IPartitioner</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>partitioner</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>importedKeys</name> <init>= <expr>(<name>isSorted</name>) ? <call><name>importSorted</name><argument_list>(<argument><expr><name>jsonFile</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>ssTablePath</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call>
                                      : <call><name>importUnsorted</name><argument_list>(<argument><expr><call><name>getParser</name><argument_list>(<argument><expr><name>jsonFile</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>ssTablePath</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>importedKeys</name> != -1</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>printf</name></name><argument_list>(<argument><expr>"%d keys imported successfully.%n"</expr></argument>, <argument><expr><name>importedKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>importUnsorted</name><parameter_list>(<param><decl><type><name>JsonParser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>columnFamily</name></decl></param>, <param><decl><type><name>String</name></type> <name>ssTablePath</name></decl></param>, <param><decl><type><name><name>IPartitioner</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>partitioner</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>importedKeys</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>data</name> <init>= <expr><call><name><name>parser</name>.<name>readValueAs</name></name><argument_list>(<argument><expr>new <class><super><name><name>TypeReference</name><argument_list>&lt;<argument><name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{}</block></class></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>keyCountToImport</name> = (<name>keyCountToImport</name> == null) ? <call><name><name>data</name>.<name>size</name></name><argument_list>()</argument_list></call> : <name>keyCountToImport</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>SSTableWriter</name></type> <name>writer</name> <init>= <expr>new <call><name>SSTableWriter</name><argument_list>(<argument><expr><name>ssTablePath</name></expr></argument>, <argument><expr><name>keyCountToImport</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>printf</name></name><argument_list>(<argument><expr>"Importing %s keys...%n"</expr></argument>, <argument><expr><name>keyCountToImport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// sort by dk representation, but hold onto the hex version</comment>
        <decl_stmt><decl><type><name><name>SortedMap</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>decoratedKeys</name> <init>= <expr>new <call><name><name>TreeMap</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>Object</name></type> <name>keyObject</name> <range>: <expr><call><name><name>data</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr>(<name>String</name>) <name>keyObject</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>decoratedKeys</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>partitioner</name>.<name>decorateKey</name></name><argument_list>(<argument><expr><call><name>hexToBytes</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></name></type> <name>rowKey</name> <range>: <expr><call><name><name>decoratedKeys</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>columnFamily</name>.<name>getType</name></name><argument_list>()</argument_list></call> == <name><name>ColumnFamilyType</name>.<name>Super</name></name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>addToSuperCF</name><argument_list>(<argument><expr>(<name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name>) <call><name><name>data</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>rowKey</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name>addToStandardCF</name><argument_list>(<argument><expr>(<name><name>List</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name>) <call><name><name>data</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>rowKey</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><call><name><name>writer</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>rowKey</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>columnFamily</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>importedKeys</name>++</expr>;</expr_stmt>

            <decl_stmt><decl><type><name>long</name></type> <name>current</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>current</name> - <name>start</name> &gt;= 5000</expr>)</condition><then> <comment type="line">// 5 secs.</comment>
            <block>{
                <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>printf</name></name><argument_list>(<argument><expr>"Currently imported %d keys.%n"</expr></argument>, <argument><expr><name>importedKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>start</name> = <name>current</name></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>keyCountToImport</name> == <name>importedKeys</name></expr>)</condition><then>
                <break>break;</break></then></if>
        }</block></for>

        <expr_stmt><expr><call><name><name>writer</name>.<name>closeAndOpenReader</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>importedKeys</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>int</name></type> <name>importSorted</name><parameter_list>(<param><decl><type><name>String</name></type> <name>jsonFile</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>columnFamily</name></decl></param>, <param><decl><type><name>String</name></type> <name>ssTablePath</name></decl></param>, <param><decl><type><name><name>IPartitioner</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>partitioner</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>importedKeys</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// already imported keys count</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>JsonParser</name></type> <name>parser</name> <init>= <expr><call><name>getParser</name><argument_list>(<argument><expr><name>jsonFile</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>keyCountToImport</name> == null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>keyCountToImport</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Counting keys to import, please wait... (NOTE: to skip this use -n &lt;num_keys&gt;)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>parser</name>.<name>nextToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// START_OBJECT</comment>
            <while>while <condition>(<expr><call><name><name>parser</name>.<name>nextToken</name></name><argument_list>()</argument_list></call> != null</expr>)</condition>
            <block>{
                <expr_stmt><expr><call><name><name>parser</name>.<name>nextToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>parser</name>.<name>skipChildren</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name><name>parser</name>.<name>getCurrentName</name></name><argument_list>()</argument_list></call> == null</expr>)</condition><then> <continue>continue;</continue></then></if>

                <expr_stmt><expr><name>keyCountToImport</name>++</expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>printf</name></name><argument_list>(<argument><expr>"Importing %s keys...%n"</expr></argument>, <argument><expr><name>keyCountToImport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>parser</name> = <call><name>getParser</name><argument_list>(<argument><expr><name>jsonFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// renewing parser</comment>
        <decl_stmt><decl><type><name>SSTableWriter</name></type> <name>writer</name> <init>= <expr>new <call><name>SSTableWriter</name><argument_list>(<argument><expr><name>ssTablePath</name></expr></argument>, <argument><expr><name>keyCountToImport</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>lineNumber</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>prevStoredKey</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name><name>parser</name>.<name>nextToken</name></name><argument_list>()</argument_list></call> != null</expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>key</name> <init>= <expr><call><name><name>parser</name>.<name>getCurrentName</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>key</name> != null</expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>tokenName</name> <init>= <expr><call><name><name>parser</name>.<name>nextToken</name></name><argument_list>()</argument_list></call>.<call><name>name</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>tokenName</name>.<name>equals</name></name><argument_list>(<argument><expr>"START_ARRAY"</expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name><name>columnFamily</name>.<name>getType</name></name><argument_list>()</argument_list></call> == <name><name>ColumnFamilyType</name>.<name>Super</name></name></expr>)</condition><then>
                    <block>{
                        <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Can't write Standard columns to the Super Column Family."</expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></then></if>

                    <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr><call><name><name>parser</name>.<name>readValueAs</name></name><argument_list>(<argument><expr>new <class><super><name><name>TypeReference</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{}</block></class></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>addToStandardCF</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name><name>tokenName</name>.<name>equals</name></name><argument_list>(<argument><expr>"START_OBJECT"</expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><call><name><name>columnFamily</name>.<name>getType</name></name><argument_list>()</argument_list></call> == <name><name>ColumnFamilyType</name>.<name>Standard</name></name></expr>)</condition><then>
                    <block>{
                        <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Can't write Super columns to the Standard Column Family."</expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></then></if>

                    <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr><call><name><name>parser</name>.<name>readValueAs</name></name><argument_list>(<argument><expr>new <class><super><name><name>TypeReference</name><argument_list>&lt;<argument><name><name>Map</name><argument_list>&lt;<argument><name>?</name></argument>, <argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list> <block>{}</block></class></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name>addToSuperCF</name><argument_list>(<argument><expr><name>columns</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Only Array or Hash allowed as row content."</expr></argument>)</argument_list></call></expr>;</throw>
                }</block></else></if></else></if>

                <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>currentKey</name> <init>= <expr><call><name><name>partitioner</name>.<name>decorateKey</name></name><argument_list>(<argument><expr><call><name>hexToBytes</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>prevStoredKey</name> != null &amp;&amp; <call><name><name>prevStoredKey</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>)</argument_list></call> != -1</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>printf</name></name><argument_list>(<argument><expr>"Line %d: Key %s is greater than previous, collection is not sorted properly. Aborting import. You might need to delete SSTables manually.%n"</expr></argument>, <argument><expr><name>lineNumber</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr>-1</expr>;</return>
                }</block></then></if>

                <comment type="line">// saving decorated key</comment>
                <expr_stmt><expr><call><name><name>writer</name>.<name>append</name></name><argument_list>(<argument><expr><name>currentKey</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>columnFamily</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>prevStoredKey</name> = <name>currentKey</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>importedKeys</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>lineNumber</name>++</expr>;</expr_stmt>

                <decl_stmt><decl><type><name>long</name></type> <name>current</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>current</name> - <name>start</name> &gt;= 5000</expr>)</condition><then> <comment type="line">// 5 secs.</comment>
                <block>{
                    <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>printf</name></name><argument_list>(<argument><expr>"Currently imported %d keys.%n"</expr></argument>, <argument><expr><name>importedKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>start</name> = <name>current</name></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr><name>keyCountToImport</name> == <name>importedKeys</name></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></then></if>
        }</block></while>

        <expr_stmt><expr><call><name><name>writer</name>.<name>closeAndOpenReader</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>importedKeys</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get JsonParser object for file
     * @param fileName name of the file
     * @return json parser instance for given file
     * @throws IOException if any I/O error.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>JsonParser</name></type> <name>getParser</name><parameter_list>(<param><decl><type><name>String</name></type> <name>fileName</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name><name>factory</name>.<name>createJsonParser</name></name><argument_list>(<argument><expr>new <call><name>File</name><argument_list>(<argument><expr><name>fileName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Converts JSON to an SSTable file. JSON input can either be a file specified
     * using an optional command line argument, or supplied on standard in.
     *
     * @param args command line arguments
     * @throws IOException on failure to open/read/write files or output streams
     * @throws ParseException on failure to parse JSON input
     * @throws ConfigurationException on configuration error.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>main</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>args</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ParseException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>CommandLineParser</name></type> <name>parser</name> <init>= <expr>new <call><name>PosixParser</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{
            <expr_stmt><expr><name>cmd</name> = <call><name><name>parser</name>.<name>parse</name></name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>cli</name>.<name>ParseException</name></name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>printProgramUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></catch></try>

        <if>if <condition>(<expr><call><name><name>cmd</name>.<name>getArgs</name></name><argument_list>()</argument_list></call>.<name>length</name> != 2</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>printProgramUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <decl_stmt><decl><type><name>String</name></type> <name>json</name>     <init>= <expr><call><name><name>cmd</name>.<name>getArgs</name></name><argument_list>()</argument_list></call><index>[<expr>0</expr>]</index></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>ssTable</name>  <init>= <expr><call><name><name>cmd</name>.<name>getArgs</name></name><argument_list>()</argument_list></call><index>[<expr>1</expr>]</index></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>keyspace</name> <init>= <expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name>KEYSPACE_OPTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>cfamily</name>  <init>= <expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name>COLUMN_FAMILY_OPTION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>cmd</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name>KEY_COUNT_OPTION</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>keyCountToImport</name> = <call><name><name>Integer</name>.<name>valueOf</name></name><argument_list>(<argument><expr><call><name><name>cmd</name>.<name>getOptionValue</name></name><argument_list>(<argument><expr><name>KEY_COUNT_OPTION</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>cmd</name>.<name>hasOption</name></name><argument_list>(<argument><expr><name>IS_SORTED_OPTION</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>isSorted</name> = true</expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>loadSchemas</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &lt; 1</expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>msg</name> <init>= <expr>"no non-system tables are defined"</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>ConfigurationException</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>

        <try>try
        <block>{
            <expr_stmt><expr><call><name>importJson</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>cfamily</name></expr></argument>, <argument><expr><name>ssTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>e</name>.<name>printStackTrace</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>err</name>.<name>println</name></name><argument_list>(<argument><expr>"ERROR: " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></catch></try>

        <expr_stmt><expr><call><name><name>System</name>.<name>exit</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>printProgramUsage</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>printf</name></name><argument_list>(<argument><expr>"Usage: %s -s -K &lt;keyspace&gt; -c &lt;column_family&gt; -n &lt;num_keys&gt; &lt;json&gt; &lt;sstable&gt;%n%n"</expr></argument>,
                            <argument><expr><call><name><name>SSTableImport</name>.<name><name>class</name>.<name>getName</name></name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"Options:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>Object</name></type> <name>o</name> <range>:  <expr><call><name><name>options</name>.<name>getOptions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Option</name></type> <name>opt</name> <init>= <expr>(<name>Option</name>) <name>o</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>out</name>.<name>println</name></name><argument_list>(<argument><expr>"  -" +<call><name><name>opt</name>.<name>getOpt</name></name><argument_list>()</argument_list></call> + " - " + <call><name><name>opt</name>.<name>getDescription</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Used by test framework to set key count
     * @param keyCount numbers of keys to import
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>setKeyCountToImport</name><parameter_list>(<param><decl><type><name>Integer</name></type> <name>keyCount</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>keyCountToImport</name> = <name>keyCount</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Convert a string to bytes (ByteBuffer) according to type
     * @param content string to convert
     * @param type type to use for conversion
     * @return byte buffer representation of the given string
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>ByteBuffer</name></type> <name>stringAsType</name><parameter_list>(<param><decl><type><name>String</name></type> <name>content</name></decl></param>, <param><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></param>)</parameter_list>
    <block>{
        <try>try
        <block>{
            <return>return <expr>(<name>type</name> == <name><name>BytesType</name>.<name>instance</name></name>) ? <call><name>hexToBytes</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call> : <call><name><name>type</name>.<name>fromString</name></name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>MarshalException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

}
</unit>
