<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\service\StorageService.java"><comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOError</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>management</name>.<name>ManagementFactory</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>InetAddress</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>UnknownHostException</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Map</name>.<name>Entry</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicLong</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>MBeanServer</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>Notification</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>NotificationBroadcasterSupport</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name>.<name>ObjectName</name></name>;</import>

<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>base</name>.<name>Supplier</name></name>;</import>
<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>collect</name></name>.*;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>metrics</name>.<name>ClientRequestMetrics</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>log4j</name>.<name>Level</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>lang</name>.<name>StringUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>DebuggableScheduledThreadPoolExecutor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>Stage</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>StageManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>Table</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>commitlog</name>.<name>CommitLog</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>Range</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>gms</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name>.<name>SSTableDeletingTask</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name>.<name>SSTableLoader</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name>.<name>AbstractReplicationStrategy</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name>.<name>DynamicEndpointSnitch</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name>.<name>IEndpointSnitch</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>locator</name>.<name>TokenMetadata</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>IAsyncResult</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>Message</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>MessagingService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>net</name>.<name>ResponseVerbHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>AntiEntropyService</name>.<name>TreeRequestVerbHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>streaming</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>FBUtilities</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>NodeId</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>Pair</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>OutputHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>WrappedRunnable</name></name>;</import>

<comment type="block" format="javadoc">/**
 * This abstraction contains the token/identifier of this node
 * on the identifier space. This token gets gossiped around.
 * This class will also maintain histograms of the load information
 * of other nodes in the cluster.
 */</comment>
<class><specifier>public</specifier> class <name>StorageService</name> <super><extends>extends <name>NotificationBroadcasterSupport</name></extends> <implements>implements <name>IEndpointStateChangeSubscriber</name>, <name>StorageServiceMBean</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>Logger</name></type> <name>logger_</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>StorageService</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>RING_DELAY</name> <init>= <expr><call><name>getRingDelay</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// delay after which we assume ring has stablized</comment>

    <comment type="block">/* JMX notification serial number counter */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicLong</name></type> <name>notificationSerialNumber</name> <init>= <expr>new <call><name>AtomicLong</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* All verb handler identifiers */</comment>
    <enum><specifier>public</specifier> enum <name>Verb</name>
    <block>{
        <decl><name>MUTATION</name></decl>,
        <decl><name>BINARY</name></decl>, <comment type="line">// Deprecated</comment>
        <decl><name>READ_REPAIR</name></decl>,
        <decl><name>READ</name></decl>,
        <decl><name>REQUEST_RESPONSE</name></decl>, <comment type="line">// client-initiated reads and writes</comment>
        <decl><name>STREAM_INITIATE</name></decl>, <comment type="line">// Deprecated</comment>
        <decl><name>STREAM_INITIATE_DONE</name></decl>, <comment type="line">// Deprecated</comment>
        <decl><name>STREAM_REPLY</name></decl>,
        <decl><name>STREAM_REQUEST</name></decl>,
        <decl><name>RANGE_SLICE</name></decl>,
        <decl><name>BOOTSTRAP_TOKEN</name></decl>,
        <decl><name>TREE_REQUEST</name></decl>,
        <decl><name>TREE_RESPONSE</name></decl>,
        <decl><name>JOIN</name></decl>, <comment type="line">// Deprecated</comment>
        <decl><name>GOSSIP_DIGEST_SYN</name></decl>,
        <decl><name>GOSSIP_DIGEST_ACK</name></decl>,
        <decl><name>GOSSIP_DIGEST_ACK2</name></decl>,
        <decl><name>DEFINITIONS_ANNOUNCE</name></decl>, <comment type="line">// Deprecated</comment>
        <decl><name>DEFINITIONS_UPDATE</name></decl>,
        <decl><name>TRUNCATE</name></decl>,
        <decl><name>SCHEMA_CHECK</name></decl>,
        <decl><name>INDEX_SCAN</name></decl>, <comment type="line">// Deprecated</comment>
        <decl><name>REPLICATION_FINISHED</name></decl>,
        <decl><name>INTERNAL_RESPONSE</name></decl>, <comment type="line">// responses to internal calls</comment>
        <decl><name>COUNTER_MUTATION</name></decl>,
        <decl><name>STREAMING_REPAIR_REQUEST</name></decl>,
        <decl><name>STREAMING_REPAIR_RESPONSE</name></decl>,
        <decl><name>SNAPSHOT</name></decl>, <comment type="line">// Similar to nt snapshot</comment>
        <decl><name>MIGRATION_REQUEST</name></decl>,
        <decl><name>GOSSIP_SHUTDOWN</name></decl>,
        <comment type="line">// use as padding for backwards compatability where a previous version needs to validate a verb from the future.</comment>
        <decl><name>UNUSED_1</name></decl>,
        <decl><name>UNUSED_2</name></decl>,
        <decl><name>UNUSED_3</name></decl>,
        ;
        <comment type="line">// remember to add new verbs at the end, since we serialize by ordinal</comment>
    }</block></enum>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Verb</name><index>[]</index></type> <name>VERBS</name> <init>= <expr><call><name><name>Verb</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name><name>EnumMap</name><argument_list>&lt;<argument><name><name>StorageService</name>.<name>Verb</name></name></argument>, <argument><name>Stage</name></argument>&gt;</argument_list></name></type> <name>verbStages</name> <init>= <expr>new <class><super><name><name>EnumMap</name><argument_list>&lt;<argument><name><name>StorageService</name>.<name>Verb</name></name></argument>, <argument><name>Stage</name></argument>&gt;</argument_list></name></super><argument_list>(<argument><expr><name><name>StorageService</name>.<name>Verb</name>.<name>class</name></name></expr></argument>)</argument_list>
    <block>{<block>{
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>MUTATION</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MUTATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>BINARY</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MUTATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>READ_REPAIR</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MUTATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>TRUNCATE</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MUTATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>READ</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>READ</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>REQUEST_RESPONSE</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>REQUEST_RESPONSE</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>STREAM_REPLY</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MISC</name></name></type></decl></param>)</parameter_list>;</constructor_decl> <comment type="line">// TODO does this really belong on misc? I've just copied old behavior here</comment>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>STREAM_REQUEST</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>STREAM</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>RANGE_SLICE</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>READ</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>BOOTSTRAP_TOKEN</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MISC</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>TREE_REQUEST</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>ANTI_ENTROPY</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>TREE_RESPONSE</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>ANTI_ENTROPY</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>STREAMING_REPAIR_REQUEST</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>ANTI_ENTROPY</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>STREAMING_REPAIR_RESPONSE</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>ANTI_ENTROPY</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>GOSSIP_DIGEST_ACK</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>GOSSIP</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>GOSSIP_DIGEST_ACK2</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>GOSSIP</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>GOSSIP_DIGEST_SYN</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>GOSSIP</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>GOSSIP_SHUTDOWN</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>GOSSIP</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>DEFINITIONS_UPDATE</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MIGRATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>SCHEMA_CHECK</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MIGRATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>MIGRATION_REQUEST</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MIGRATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>INDEX_SCAN</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>READ</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>REPLICATION_FINISHED</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MISC</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>INTERNAL_RESPONSE</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>INTERNAL_RESPONSE</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>COUNTER_MUTATION</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MUTATION</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>SNAPSHOT</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>MISC</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>UNUSED_1</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>INTERNAL_RESPONSE</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>UNUSED_2</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>INTERNAL_RESPONSE</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
        <constructor_decl><name>put</name><parameter_list>(<param><decl><type><name><name>Verb</name>.<name>UNUSED_3</name></name></type></decl></param>, <param><decl><type><name><name>Stage</name>.<name>INTERNAL_RESPONSE</name></name></type></decl></param>)</parameter_list>;</constructor_decl>
    }</block>}</block></class></expr></init></decl>;</decl_stmt>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>int</name></type> <name>getRingDelay</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>String</name></type> <name>newdelay</name> <init>= <expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.ring_delay_ms"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>newdelay</name> != null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Overriding RING_DELAY to {}ms"</expr></argument>, <argument><expr><name>newdelay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name><name>Integer</name>.<name>parseInt</name></name><argument_list>(<argument><expr><name>newdelay</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
            <return>return <expr>30 * 1000</expr>;</return></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This pool is used for periodic short (sub-second) tasks.
     */</comment>
     <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>DebuggableScheduledThreadPoolExecutor</name></type> <name>scheduledTasks</name> <init>= <expr>new <call><name>DebuggableScheduledThreadPoolExecutor</name><argument_list>(<argument><expr>"ScheduledTasks"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * This pool is used by tasks that can have longer execution times, and usually are non periodic.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>DebuggableScheduledThreadPoolExecutor</name></type> <name>tasks</name> <init>= <expr>new <call><name>DebuggableScheduledThreadPoolExecutor</name><argument_list>(<argument><expr>"NonPeriodicTasks"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * tasks that do not need to be waited for on shutdown/drain
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>DebuggableScheduledThreadPoolExecutor</name></type> <name>optionalTasks</name> <init>= <expr>new <call><name>DebuggableScheduledThreadPoolExecutor</name><argument_list>(<argument><expr>"OptionalTasks"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>static
    <block>{
        <expr><call><name><name>tasks</name>.<name>setExecuteExistingDelayedTasksAfterShutdownPolicy</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;
    }</block>

    <comment type="block">/* This abstraction maintains the token/endpoint metadata information */</comment>
    private <name>TokenMetadata</name> <name>tokenMetadata_</name> = new <call><name>TokenMetadata</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <name><name>VersionedValue</name>.<name>VersionedValueFactory</name></name></type> <name>valueFactory</name> <init>= <expr>new <call><name><name>VersionedValue</name>.<name>VersionedValueFactory</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>StorageService</name></type> <name>instance</name> <init>= <expr>new <call><name>StorageService</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>IPartitioner</name></type> <name>getPartitioner</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getLocalRanges</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getRangesForEndpoint</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getLocalPrimaryRange</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getPrimaryRangeForEndpoint</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="line">// For JMX's sake. Use getLocalPrimaryRange for internal uses</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getPrimaryRange</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>replicatingNodes</name> <init>= <expr><call><name><name>Collections</name>.<name>synchronizedSet</name></name><argument_list>(<argument><expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>CassandraDaemon</name></type> <name>daemon</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>InetAddress</name></type> <name>removingNode</name></decl>;</decl_stmt>

    <comment type="block">/* Are we starting this node in bootstrap mode? */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isBootstrapMode</name></decl>;</decl_stmt>

    <comment type="block">/* we bootstrap but do NOT join the ring unless told to do so */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isSurveyMode</name><init>= <expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.write_survey"</expr></argument>, <argument><expr>"false"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* when intialized as a client, we shouldn't write to the system table. */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isClientMode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>initialized</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>joined</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

    <enum><specifier>private</specifier> <specifier>static</specifier> enum <name>Mode</name> <block>{ <decl><name>NORMAL</name></decl>, <decl><name>CLIENT</name></decl>, <decl><name>JOINING</name></decl>, <decl><name>LEAVING</name></decl>, <decl><name>DECOMMISSIONED</name></decl>, <decl><name>MOVING</name></decl>, <decl><name>DRAINING</name></decl>, <decl><name>DRAINED</name></decl> }</block></enum>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Mode</name></type> <name>operationMode</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>MigrationManager</name></type> <name>migrationManager</name> <init>= <expr>new <call><name>MigrationManager</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Used for tracking drain progress */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>totalCFs</name></decl>, <decl><type ref="prev"/><name>remainingCFs</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>nextRepairCommand</name> <init>= <expr>new <call><name>AtomicInteger</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ObjectName</name></type> <name>jmxObjectName</name></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>finishBootstrapping</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><name>isBootstrapMode</name> = false</expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/** This method updates the local token on disk  */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>setToken</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>token</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Setting token to {}"</expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>normal</name></name><argument_list>(<argument><expr><call><name>getLocalToken</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>NORMAL</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <constructor><specifier>public</specifier> <name>StorageService</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>MBeanServer</name></type> <name>mbs</name> <init>= <expr><call><name><name>ManagementFactory</name>.<name>getPlatformMBeanServer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>jmxObjectName</name> = new <call><name>ObjectName</name><argument_list>(<argument><expr>"org.apache.cassandra.db:type=StorageService"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>mbs</name>.<name>registerMBean</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>jmxObjectName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <comment type="block">/* register the verb handlers */</comment>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>MUTATION</name></name></expr></argument>, <argument><expr>new <call><name>RowMutationVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>READ_REPAIR</name></name></expr></argument>, <argument><expr>new <call><name>ReadRepairVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>READ</name></name></expr></argument>, <argument><expr>new <call><name>ReadVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>RANGE_SLICE</name></name></expr></argument>, <argument><expr>new <call><name>RangeSliceVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>INDEX_SCAN</name></name></expr></argument>, <argument><expr>new <call><name>IndexScanVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>COUNTER_MUTATION</name></name></expr></argument>, <argument><expr>new <call><name>CounterMutationVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>TRUNCATE</name></name></expr></argument>, <argument><expr>new <call><name>TruncateVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// see BootStrapper for a summary of how the bootstrap verbs interact</comment>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>BOOTSTRAP_TOKEN</name></name></expr></argument>, <argument><expr>new <call><name><name>BootStrapper</name>.<name>BootstrapTokenVerbHandler</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>STREAM_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name>StreamRequestVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>STREAM_REPLY</name></name></expr></argument>, <argument><expr>new <call><name>StreamReplyVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>REPLICATION_FINISHED</name></name></expr></argument>, <argument><expr>new <call><name>ReplicationFinishedVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>REQUEST_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name>ResponseVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>INTERNAL_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name>ResponseVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>TREE_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name>TreeRequestVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>TREE_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name><name>AntiEntropyService</name>.<name>TreeResponseVerbHandler</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>STREAMING_REPAIR_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name><name>StreamingRepairTask</name>.<name>StreamingRepairRequest</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>STREAMING_REPAIR_RESPONSE</name></name></expr></argument>, <argument><expr>new <call><name><name>StreamingRepairTask</name>.<name>StreamingRepairResponse</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>GOSSIP_DIGEST_SYN</name></name></expr></argument>, <argument><expr>new <call><name>GossipDigestSynVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>GOSSIP_DIGEST_ACK</name></name></expr></argument>, <argument><expr>new <call><name>GossipDigestAckVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>GOSSIP_DIGEST_ACK2</name></name></expr></argument>, <argument><expr>new <call><name>GossipDigestAck2VerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>GOSSIP_SHUTDOWN</name></name></expr></argument>, <argument><expr>new <call><name>GossipShutdownVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>DEFINITIONS_UPDATE</name></name></expr></argument>, <argument><expr>new <call><name>DefinitionsUpdateVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>SCHEMA_CHECK</name></name></expr></argument>, <argument><expr>new <call><name>SchemaCheckVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>MIGRATION_REQUEST</name></name></expr></argument>, <argument><expr>new <call><name>MigrationRequestVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>registerVerbHandlers</name><argument_list>(<argument><expr><name><name>Verb</name>.<name>SNAPSHOT</name></name></expr></argument>, <argument><expr>new <call><name>SnapshotVerbHandler</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// spin up the streaming service so it is available for jmx tools.</comment>
        <if>if <condition>(<expr><name><name>StreamingService</name>.<name>instance</name></name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Streaming service is unavailable."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
    }</block></constructor>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>registerDaemon</name><parameter_list>(<param><decl><type><name>CassandraDaemon</name></type> <name>daemon</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name><name>this</name>.<name>daemon</name></name> = <name>daemon</name></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// should only be called via JMX</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopGossiping</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Stopping gossip by operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>initialized</name> = false</expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="line">// should only be called via JMX</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>startGossiping</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<name>initialized</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Starting gossip by operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>start</name></name><argument_list>(<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>initialized</name> = true</expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <comment type="line">// should only be called via JMX</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>startRPCServer</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"No configured RPC daemon"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>daemon</name>.<name>startRPCServer</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopRPCServer</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr>"No configured RPC daemon"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>daemon</name>.<name>stopRPCServer</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isRPCServerRunning</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>daemon</name> == null</expr>)</condition><then>
        <block>{
            <return>return <expr>false</expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>daemon</name>.<name>isRPCServerRunning</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>stopClient</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>unregister</name></name><argument_list>(<argument><expr><name>migrationManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>unregister</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// give it a second so that task accepted before the MessagingService shutdown gets submitted to the stage (to avoid RejectedExecutionException)</comment>
        <try>try <block>{ <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000L</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block> <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list> <block>{}</block></catch></try>
        <expr_stmt><expr><call><name><name>StageManager</name>.<name>shutdownNow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isInitialized</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>initialized</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initClient</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>initClient</name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initClient</name><parameter_list>(<param><decl><type><name>int</name></type> <name>delay</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"StorageService does not support switching modes."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>initialized</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>isClientMode</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Starting up client gossip"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>CLIENT</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>register</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>start</name></name><argument_list>(<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// needed for node-ring gathering.</comment>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>listen</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getLocalAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// sleep a while to allow gossip to warm up (the other nodes need to know about this one before they can reply).</comment>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>ex</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <expr_stmt><expr><call><name><name>Schema</name>.<name>instance</name>.<name>updateVersionAndAnnounce</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initServer</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>initServer</name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>initServer</name><parameter_list>(<param><decl><type><name>int</name></type> <name>delay</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Cassandra version: " + <call><name><name>FBUtilities</name>.<name>getReleaseVersionString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Thrift API version: " + <name><name>Constants</name>.<name>VERSION</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"CQL supported versions: " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><call><name><name>ClientState</name>.<name>getCQLSupportedVersion</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call> + " (default: " + <name><name>ClientState</name>.<name>DEFAULT_CQL_VERSION</name></name> + ")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>initialized</name></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name>isClientMode</name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"StorageService does not support switching modes."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><name>initialized</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>isClientMode</name> = false</expr>;</expr_stmt>

        <comment type="line">// Ensure StorageProxy is initialized on start-up; see CASSANDRA-3797.</comment>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Class</name>.<name>forName</name></name><argument_list>(<argument><expr>"org.apache.cassandra.service.StorageProxy"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ClassNotFoundException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
        <block>{
            <comment type="line">// "Touch" metrics classes to trigger static initialization, such that all metrics become available</comment>
            <comment type="line">// on start-up even if they have not yet been used.</comment>
            <expr_stmt><expr>new <call><name>ClientRequestMetrics</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.load_ring_state"</expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Loading persisted ring state"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>SystemTable</name>.<name>loadTokens</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call> == <call><name><name>FBUtilities</name>.<name>getLocalAddress</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// entry has been mistakenly added, delete it</comment>
                    <expr_stmt><expr><call><name><name>SystemTable</name>.<name>removeToken</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addSavedEndpoint</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
        }</block></then></if>

        <if>if <condition>(<expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.renew_counter_id"</expr></argument>, <argument><expr>"false"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Renewing local node id (as requested)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>NodeId</name>.<name>renewLocalId</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// daemon threads, like our executors', continue to run while shutdown hooks are invoked</comment>
        <decl_stmt><decl><type><name>Thread</name></type> <name>drainOnShutdown</name> <init>= <expr>new <call><name>Thread</name><argument_list>(<argument><expr>new <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
            <block>{
                <decl_stmt><decl><type><name>ThreadPoolExecutor</name></type> <name>mutationStage</name> <init>= <expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>mutationStage</name>.<name>isShutdown</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <return>return;</return></then></if> <comment type="line">// drained already</comment>

                <expr_stmt><expr><call><name>stopRPCServer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>optionalTasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// In-progress writes originating here could generate hints to be written, so shut down MessagingService</comment>
                <comment type="line">// before mutation stage, so we can get all the hints saved before shutting down</comment>
                <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mutationStage</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mutationStage</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>3600</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>SECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>instance</name>.<name>verifyNoHintsInProgress</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>flushes</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>KSMetaData</name></type> <name>ksm</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getKSMetaData</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<name><name>ksm</name>.<name>durableWrites</name></name></expr>)</condition><then>
                    <block>{
                        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                        <block>{
                            <decl_stmt><decl><type><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>future</name> <init>= <expr><call><name><name>cfs</name>.<name>forceFlush</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                            <if>if <condition>(<expr><name>future</name> != null</expr>)</condition><then>
                                <expr_stmt><expr><call><name><name>flushes</name>.<name>add</name></name><argument_list>(<argument><expr><name>future</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                        }</block></for>
                    }</block></then></if>
                }</block></for>
                <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>waitOnFutures</name></name><argument_list>(<argument><expr><name>flushes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>shutdownBlocking</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// wait for miscellaneous tasks like sstable and commitlog segment deletion</comment>
                <expr_stmt><expr><call><name><name>tasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name><name>tasks</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MINUTES</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Miscellaneous task executor still busy after one minute; proceeding with shutdown"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></function>
        }</block></class></expr></argument>, <argument><expr>"StorageServiceShutdownHook"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Runtime</name>.<name>getRuntime</name></name><argument_list>()</argument_list></call>.<call><name>addShutdownHook</name><argument_list>(<argument><expr><name>drainOnShutdown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>Boolean</name>.<name>parseBoolean</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>getProperty</name></name><argument_list>(<argument><expr>"cassandra.join_ring"</expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>joinTokenRing</name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Not joining ring as requested. Use JMX (StorageService-&gt;joinRing()) to initiate ring joining"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>joinTokenRing</name><parameter_list>(<param><decl><type><name>int</name></type> <name>delay</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>ConfigurationException</name></name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Starting up server gossip"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>joined</name> = true</expr>;</expr_stmt>


        <comment type="line">// have to start the gossip service before we can see any info on other nodes.  this is necessary</comment>
        <comment type="line">// for bootstrap to get the load info it needs.</comment>
        <comment type="line">// (we won't be part of the storage ring though until we add a nodeId to our state, below.)</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>register</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>register</name></name><argument_list>(<argument><expr><name>migrationManager</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>start</name></name><argument_list>(<argument><expr><call><name><name>SystemTable</name>.<name>incrementAndGetGeneration</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// needed for node-ring gathering.</comment>

        <comment type="line">// gossip Schema.emptyVersion forcing immediate check for schema updates (see MigrationManager#maybeScheduleSchemaPull)</comment>
        <expr_stmt><expr><call><name><name>Schema</name>.<name>instance</name>.<name>updateVersionAndAnnounce</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Ensure we know our own actual Schema UUID in preparation for updates</comment>

        <comment type="line">// add rpc listening info</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RPC_ADDRESS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>rpcaddress</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>null != <call><name><name>DatabaseDescriptor</name>.<name>getReplaceToken</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>hibernate</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>listen</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getLocalAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>LoadBroadcaster</name>.<name>instance</name>.<name>startBroadcasting</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RELEASE_VERSION</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>releaseVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>start</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// We bootstrap if we haven't successfully bootstrapped before, as long as we are not a seed.</comment>
        <comment type="line">// If we are a seed, or if the user manually sets auto_bootstrap to false,</comment>
        <comment type="line">// we'll skip streaming data from other nodes and jump directly into the ring.</comment>
        <comment type="line">//</comment>
        <comment type="line">// The seed check allows us to skip the RING_DELAY sleep for the single-node cluster case,</comment>
        <comment type="line">// which is useful for both new users and testing.</comment>
        <comment type="line">//</comment>
        <comment type="line">// We attempted to replace this with a schema-presence check, but you need a meaningful sleep</comment>
        <comment type="line">// to get schema info from gossip which defeats the purpose.  See CASSANDRA-4427 for the gory details.</comment>
        <decl_stmt><decl><type><name><name>Token</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>token</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>current</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Bootstrap variables: {} {} {} {}"</expr></argument>,
                      <argument><expr>new <name><name>Object</name><index>[]</index></name><block>{ <expr><call><name><name>DatabaseDescriptor</name>.<name>isAutoBootstrap</name></name><argument_list>()</argument_list></call></expr>,
                                    <expr><call><name><name>SystemTable</name>.<name>bootstrapInProgress</name></name><argument_list>()</argument_list></call></expr>,
                                    <expr><call><name><name>SystemTable</name>.<name>bootstrapComplete</name></name><argument_list>()</argument_list></call></expr>,
                                    <expr><call><name><name>DatabaseDescriptor</name>.<name>getSeeds</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name>.<name>isAutoBootstrap</name></name><argument_list>()</argument_list></call>
            &amp;&amp; !<call><name><name>SystemTable</name>.<name>bootstrapComplete</name></name><argument_list>()</argument_list></call>
            &amp;&amp; !<call><name><name>DatabaseDescriptor</name>.<name>getSeeds</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><call><name><name>SystemTable</name>.<name>bootstrapInProgress</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Detected previous bootstrap failure; retrying"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>IN_PROGRESS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"waiting for ring information"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// first sleep the delay to make sure we see all our peers</comment>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>delay</name></expr>;</condition> <incr><expr><name>i</name> += 1000</expr></incr>)
            <block>{
                <comment type="line">// if we see schema, we can proceed to the next check directly</comment>
                <if>if <condition>(<expr>!<call><name><name>Schema</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name><name>Schema</name>.<name>emptyVersion</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"got schema: {}"</expr></argument>, <argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <try>try
                <block>{
                    <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></for>
            <comment type="line">// if our schema hasn't matched yet, keep sleeping until it does</comment>
            <comment type="line">// (post CASSANDRA-1391 we don't expect this to be necessary very often, but it doesn't hurt to be careful)</comment>
            <while>while <condition>(<expr>!<call><name><name>MigrationManager</name>.<name>isReadyForBootstrap</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"waiting for schema information to complete"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <try>try
                <block>{
                    <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></while>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"schema complete"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"waiting for pending range calculation"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>blockUntilFinished</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"calculation complete, ready to bootstrap"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>


            <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"... got ring + schema info"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name>.<name>getReplaceToken</name></name><argument_list>()</argument_list></call> == null</expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>isMember</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>s</name> <init>= <expr>"This node is already a member of the token ring; bootstrap aborted. (If replacing a dead node, remove the old one from the ring first.)"</expr></init></decl>;</decl_stmt>
                    <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if>
                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"getting bootstrap token"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>token</name> = <call><name><name>BootStrapper</name>.<name>getBootstrapToken</name></name><argument_list>(<argument><expr><name>tokenMetadata_</name></expr></argument>, <argument><expr><call><name><name>LoadBroadcaster</name>.<name>instance</name>.<name>getLoadInfo</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <try>try
                <block>{
                    <comment type="line">// Sleeping additionally to make sure that the server actually is not alive</comment>
                    <comment type="line">// and giving it more time to gossip if alive.</comment>
                    <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name><name>LoadBroadcaster</name>.<name>BROADCAST_INTERVAL</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
                <expr_stmt><expr><name>token</name> = <call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getReplaceToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// check for operator errors...</comment>
                <expr_stmt><expr><name>current</name> = <call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>null != <name>current</name> &amp;&amp; <call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call>.<call><name>getUpdateTimestamp</name><argument_list>()</argument_list></call> &gt; (<call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> - <name>delay</name>)</expr>)</condition><then>
                    <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Cannnot replace a token for a Live node... "</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"Replacing a node with token: " + <name>token</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><call><name>bootstrap</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr>!<name>isBootstrapMode</name></expr>;</assert> <comment type="line">// bootstrap will block until finished</comment>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name>token</name> = <call><name><name>SystemTable</name>.<name>getSavedToken</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>token</name> == null</expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>String</name></type> <name>initialToken</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getInitialToken</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>initialToken</name> == null</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>token</name> = <call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getRandomToken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Generated random token " + <name>token</name> + ". Random tokens will result in an unbalanced ring; see http://wiki.apache.org/cassandra/Operations"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><name>token</name> = <call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>initialToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Saved token not found. Using " + <name>token</name> + " from configuration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Using saved token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>

        <if>if <condition>(<expr>!<name>isSurveyMode</name></expr>)</condition><then>
        <block>{
            <comment type="line">// start participating in the ring.</comment>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>COMPLETED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setToken</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// remove the existing info about the replaced node.</comment>
            <if>if <condition>(<expr><name>current</name> != null</expr>)</condition><then>
                <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>replacedEndpoint</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Bootstrap/Replace/Move completed! Now serving reads."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name><name>tokenMetadata_</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>;</assert>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Bootstrap complete, but write survey mode is active, not becoming an active ring member. Use JMX (StorageService-&gt;joinRing()) to finalize ring joining."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>joinRing</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>ConfigurationException</name></name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr>!<name>joined</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Joining ring by operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>joinTokenRing</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>isSurveyMode</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>setToken</name><argument_list>(<argument><expr><call><name><name>SystemTable</name>.<name>getSavedToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>COMPLETED</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>isSurveyMode</name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Leaving write survey mode and joining ring at operator request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <assert>assert <expr><call><name><name>tokenMetadata_</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>;</assert>
        }</block></then></if></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isJoined</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>joined</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>rebuild</name><parameter_list>(<param><decl><type><name>String</name></type> <name>sourceDc</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"rebuild from dc: {}"</expr></argument>, <argument><expr><name>sourceDc</name> == null ? "(any dc)" : <name>sourceDc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>RangeStreamer</name></type> <name>streamer</name> <init>= <expr>new <call><name>RangeStreamer</name><argument_list>(<argument><expr><name>tokenMetadata_</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>REBUILD</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>streamer</name>.<name>addSourceFilter</name></name><argument_list>(<argument><expr>new <call><name><name>RangeStreamer</name>.<name>FailureDetectorSourceFilter</name></name><argument_list>(<argument><expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>sourceDc</name> != null</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>streamer</name>.<name>addSourceFilter</name></name><argument_list>(<argument><expr>new <call><name><name>RangeStreamer</name>.<name>SingleDatacenterFilter</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sourceDc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>streamer</name>.<name>addRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getLocalRanges</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <expr_stmt><expr><call><name><name>streamer</name>.<name>fetch</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setStreamThroughputMbPerSec</name><parameter_list>(<param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setStreamThroughputOutboundMegabitsPerSec</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"setstreamthroughput: throttle set to {}"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getStreamThroughputMbPerSec</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getStreamThroughputOutboundMegabitsPerSec</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCompactionThroughputMbPerSec</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getCompactionThroughputMbPerSec</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactionThroughputMbPerSec</name><parameter_list>(<param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setCompactionThroughputMbPerSec</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isIncrementalBackupsEnabled</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>isIncrementalBackupsEnabled</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setIncrementalBackupsEnabled</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setIncrementalBackupsEnabled</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setMode</name><parameter_list>(<param><decl><type><name>Mode</name></type> <name>m</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>log</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>null</expr></argument>, <argument><expr><name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>setMode</name><parameter_list>(<param><decl><type><name>Mode</name></type> <name>m</name></decl></param>, <param><decl><type><name>String</name></type> <name>msg</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>log</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>operationMode</name> = <name>m</name></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>logMsg</name> <init>= <expr><name>msg</name> == null ? <call><name><name>m</name>.<name>toString</name></name><argument_list>()</argument_list></call> : <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s: %s"</expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>log</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr><name>logMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr><name>logMsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>bootstrap</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>token</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><name>isBootstrapMode</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// DON'T use setToken, that makes us part of the ring locally which is incorrect until we are done bootstrapping</comment>
        <if>if <condition>(<expr>null == <call><name><name>DatabaseDescriptor</name>.<name>getReplaceToken</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// if not an existing token then bootstrap</comment>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>bootstrapping</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"sleeping " + <name>RING_DELAY</name> + " ms for pending range setup"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// Dont set any state for the node which is bootstrapping the existing token...</comment>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>JOINING</name></name></expr></argument>, <argument><expr>"Starting to bootstrap..."</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>new <call><name>BootStrapper</name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tokenMetadata_</name></expr></argument>)</argument_list></call>.<call><name>bootstrap</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// handles token update</comment>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isBootstrapMode</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>isBootstrapMode</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>TokenMetadata</name></type> <name>getTokenMetadata</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>tokenMetadata_</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * for a keyspace, return the ranges and corresponding listen addresses.
     * @param keyspace
     * @return
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangeToEndpointMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* All the ranges for the tokens */</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>,<argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getRangeToAddressMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Return the rpc address associated with an endpoint as a string.
     * @param endpoint The endpoint to get rpc address for
     * @return
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getRpcaddress</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcAddress</name></name><argument_list>()</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr>;</return></then>
        <else>else <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>getApplicationState</name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RPC_ADDRESS</name></name></expr></argument>)</argument_list></call> == null</expr>)</condition><then>
            <return>return <expr><call><name><name>endpoint</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr>;</return></then>
        <else>else
            <return>return <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>getApplicationState</name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>RPC_ADDRESS</name></name></expr></argument>)</argument_list></call>.<name>value</name></expr>;</return></else></if></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * for a keyspace, return the ranges and corresponding RPC addresses for a given keyspace.
     * @param keyspace
     * @return
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangeToRpcaddressMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/* All the ranges for the tokens */</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getRangeToAddressMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>rpcaddrs</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name><range>: <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>rpcaddrs</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getRpcaddress</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rpcaddrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getPendingRangeToEndpointMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// some people just want to get a visual representation of things. Allow null and set it to the first</comment>
        <comment type="line">// non-system table.</comment>
        <if>if <condition>(<expr><name>keyspace</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>keyspace</name> = <call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>tokenMetadata_</name>.<name>getPendingRanges</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>l</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>asList</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>stringify</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangeToAddressMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// some people just want to get a visual representation of things. Allow null and set it to the first</comment>
        <comment type="line">// non-system table.</comment>
        <if>if <condition>(<expr><name>keyspace</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>keyspace</name> = <call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name>getAllRanges</name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>constructRangeToEndpointMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * The same as {@code describeRing(String)} but converts TokenRange to the String for JMX compatibility
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) converted to String for the given keyspace
     *
     * @throws InvalidRequestException if there is no ring information available about keyspace
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>describeRingJMX</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name></type> <name>tokenRanges</name> <init>= <expr><call><name>describeRing</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>result</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenRanges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>TokenRange</name></type> <name>tokenRange</name> <range>: <expr><name>tokenRanges</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>result</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>tokenRange</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * The TokenRange for a given keyspace.
     *
     * @param keyspace The keyspace to fetch information about
     *
     * @return a List of TokenRange(s) for the given keyspace
     *
     * @throws InvalidRequestException if there is no ring information available about keyspace
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name></type> <name>describeRing</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>keyspace</name> == null || !<call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"There is no ring for the keyspace: " + <name>keyspace</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>TokenRange</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Token</name>.<name>TokenFactory</name></name></type> <name>tf</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name>getRangeToAddressMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Range</name></type> <name>range</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>addresses</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>addresses</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>rpc_endpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>addresses</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>EndpointDetails</name></argument>&gt;</argument_list></name></type> <name>epDetails</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>EndpointDetails</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>addresses</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>addresses</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>EndpointDetails</name></type> <name>details</name> <init>= <expr>new <call><name>EndpointDetails</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>details</name>.<name>host</name></name> = <call><name><name>endpoint</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>details</name>.<name>datacenter</name></name> = <call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenter</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>details</name>.<name>rack</name></name> = <call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getRack</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>endpoints</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>details</name>.<name>host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rpc_endpoints</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getRpcaddress</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name><name>epDetails</name>.<name>add</name></name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <decl_stmt><decl><type><name>TokenRange</name></type> <name>tr</name> <init>= <expr>new <call><name>TokenRange</name><argument_list>(<argument><expr><call><name><name>tf</name>.<name>toString</name></name><argument_list>(<argument><expr><call><name><name>range</name>.<name>left</name>.<name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>tf</name>.<name>toString</name></name><argument_list>(<argument><expr><call><name><name>range</name>.<name>right</name>.<name>getToken</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>)</argument_list></call>
                                    .<call><name>setEndpoint_details</name><argument_list>(<argument><expr><name>epDetails</name></expr></argument>)</argument_list></call>
                                    .<call><name>setRpc_endpoints</name><argument_list>(<argument><expr><name>rpc_endpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name>tr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>ranges</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getTokenToEndpointMap</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>mapInetAddress</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getNormalAndBootstrappingTokenToEndpointMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// in order to preserve tokens in ascending order, we use LinkedHashMap here</comment>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>mapString</name> <init>= <expr>new <call><name><name>LinkedHashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mapInetAddress</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>mapInetAddress</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>tokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>Token</name></type> <name>token</name> <range>: <expr><name>tokens</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>mapString</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>token</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>mapInetAddress</name>.<name>get</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>mapString</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Construct the range to endpoint mapping based on the true view
     * of the world.
     * @param ranges
     * @return mapping of ranges to the replicas responsible for them.
    */</comment>
    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>constructRangeToEndpointMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangeToEndpointMap</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>rangeToEndpointMap</name>.<name>put</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>rangeToEndpointMap</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>constructEndpointToRangeMap</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>endpointToRangeMap</name> <init>= <expr><call><name><name>Multimaps</name>.<name>newListMultimap</name></name><argument_list>(<argument><expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>new <class><super><name><name>Supplier</name><argument_list>&lt;<argument><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>get</name><parameter_list>()</parameter_list>
            <block>{
                <return>return <expr><call><name><name>Lists</name>.<name>newArrayList</name></name><argument_list>()</argument_list></call></expr>;</return>
            }</block></function>
        }</block></class></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name>getAllRanges</name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>endpointToRangeMap</name>.<name>put</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></for>
        <return>return <expr><call><name><name>endpointToRangeMap</name>.<name>asMap</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * Handle the reception of a new particular ApplicationState for a particular endpoint. Note that the value of the
     * ApplicationState has not necessarily "changed" since the last known value, if we already received the same update
     * from somewhere else.
     *
     * onChange only ever sees one ApplicationState piece change at a time (even if many ApplicationState updates were
     * received at the same time), so we perform a kind of state machine here. We are concerned with two events: knowing
     * the token associated with an endpoint, and knowing its operation mode. Nodes can start in either bootstrap or
     * normal mode, and from bootstrap mode can change mode to normal. A node in bootstrap mode needs to have
     * pendingranges set in TokenMetadata; a node in normal mode should instead be part of the token ring.
     *
     * Normal progression of ApplicationState.STATUS values for a node should be like this:
     * STATUS_BOOTSTRAPPING,token
     *   if bootstrapping. stays this way until all files are received.
     * STATUS_NORMAL,token
     *   ready to serve reads and writes.
     * STATUS_LEAVING,token
     *   get ready to leave the cluster as part of a decommission
     * STATUS_LEFT,token
     *   set after decommission is completed.
     *
     * Other STATUS values that may be seen (possibly anywhere in the normal progression):
     * STATUS_MOVING,newtoken
     *   set if node is currently moving to a new token in the ring
     * REMOVING_TOKEN,deadtoken
     *   set if the node is dead and is being removed by its REMOVAL_COORDINATOR
     * REMOVED_TOKEN,deadtoken
     *   set if the node is dead and has been removed by its REMOVAL_COORDINATOR
     *
     * Note: Any time a node state changes from STATUS_NORMAL, it will not be visible to new nodes. So it follows that
     * you should never bootstrap a new node during a removetoken, decommission or move.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>onChange</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>ApplicationState</name></type> <name>state</name></decl></param>, <param><decl><type><name>VersionedValue</name></type> <name>value</name></decl></param>)</parameter_list>
    <block>{
        <switch>switch <condition>(<expr><name>state</name></expr>)</condition>
        <block>{
            <case>case <expr><name>STATUS</name></expr>:
                <decl_stmt><decl><type><name>String</name></type> <name>apStateValue</name> <init>= <expr><name><name>value</name>.<name>value</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>pieces</name> <init>= <expr><call><name><name>apStateValue</name>.<name>split</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>DELIMITER_STR</name></name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <assert>assert <expr>(<name><name>pieces</name>.<name>length</name></name> &gt; 0)</expr>;</assert>

                <decl_stmt><decl><type><name>String</name></type> <name>moveName</name> <init>= <expr><name><name>pieces</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_BOOTSTRAPPING</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateBootstrap</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_NORMAL</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateNormal</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>REMOVING_TOKEN</name></name></expr></argument>)</argument_list></call> || <call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>REMOVED_TOKEN</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateRemoving</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_LEAVING</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateLeaving</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_LEFT</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateLeft</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr><call><name><name>moveName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>STATUS_MOVING</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name>handleStateMoving</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if>
        </case>}</block></switch>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node bootstrap
     *
     * @param endpoint bootstrapping node
     * @param pieces STATE_BOOTSTRAPPING,bootstrap token as string
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateBootstrap</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state bootstrapping, token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// if this node is present in token metadata, either we have missed intermediate states</comment>
        <comment type="line">// or the node had crashed. Print warning if needed, clear obsolete stuff and</comment>
        <comment type="line">// continue.</comment>
        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// If isLeaving is false, we have missed both LEAVING and LEFT. However, if</comment>
            <comment type="line">// isLeaving is true, we have only missed LEFT. Waiting time between completing</comment>
            <comment type="line">// leave operation and rebootstrapping is relatively short, so the latter is quite</comment>
            <comment type="line">// common (not enough time for gossip to spread). Therefore we report only the</comment>
            <comment type="line">// former in the log.</comment>
            <if>if <condition>(<expr>!<call><name><name>tokenMetadata_</name>.<name>isLeaving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state jump to bootstrap"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>addBootstrapToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node move to normal state. That is, node is entering token ring and participating
     * in reads.
     *
     * @param endpoint node
     * @param pieces STATE_NORMAL,token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateNormal</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state normal, token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state jump to normal"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// we don't want to update if this node is responsible for the token and it has a later startup time than endpoint.</comment>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>currentOwner</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>currentOwner</name> == null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"New node " + <name>endpoint</name> + " at token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateToken</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// set state back to normal, since the node may have tried to leave, but failed and is now back up</comment>
            <comment type="line">// no need to persist, token/ip did not change</comment>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>compareEndpointStartup</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Nodes %s and %s have the same token %s.  %s is the new owner"</expr></argument>,
                                       <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>currentOwner</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>currentOwner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>SystemTable</name>.<name>updateToken</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Nodes %s and %s have the same token %s.  Ignoring %s"</expr></argument>,
                                       <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>currentOwner</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>

        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>isMoving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="line">// if endpoint was moving to a new token</comment>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>removeFromMoving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node preparing to leave the ring
     *
     * @param endpoint node
     * @param pieces STATE_LEAVING,token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateLeaving</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name>String</name></type> <name>moveValue</name> <init>= <expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>moveValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state leaving, token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// If the node is previously unknown or tokens do not match, update tokenmetadata to</comment>
        <comment type="line">// have this node as 'normal' (it must have been using this token before the</comment>
        <comment type="line">// leave). This way we'll get pending ranges right.</comment>
        <if>if <condition>(<expr>!<call><name><name>tokenMetadata_</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state jump to leaving"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " 'leaving' token mismatch. Long network partition?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>updateNormalToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <comment type="line">// at this point the endpoint is certainly a member with this token, so let's proceed</comment>
        <comment type="line">// normally</comment>
        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node leaving the ring. This will happen when a node is decommissioned
     *
     * @param endpoint If reason for leaving is decommission, endpoint is the leaving node.
     * @param pieces STATE_LEFT,token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateLeft</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state left, token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name>extractExpireTime</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle node moving inside the ring.
     *
     * @param endpoint moving endpoint address
     * @param pieces STATE_MOVING, token
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateMoving</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name><name>pieces</name>.<name>length</name></name> &gt;= 2</expr>;</assert>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " state moving, new token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>addMovingEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Handle notification that a node being actively removed from the ring via 'removetoken'
     *
     * @param endpoint node
     * @param pieces either REMOVED_TOKEN (node is gone) or REMOVING_TOKEN (replicas need to be restored)
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>handleStateRemoving</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr>(<name><name>pieces</name>.<name>length</name></name> &gt; 0)</expr>;</assert>

        <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Received removeToken gossip about myself. Is this node rejoining after an explicit removetoken?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name>drain</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
            <return>return;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>state</name> <init>= <expr><name><name>pieces</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Token</name></type> <name>removeToken</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>VersionedValue</name>.<name>REMOVED_TOKEN</name>.<name>equals</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>removeToken</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name>extractExpireTime</name><argument_list>(<argument><expr><name>pieces</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name><name>VersionedValue</name>.<name>REMOVING_TOKEN</name>.<name>equals</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Token " + <name>removeToken</name> + " removed manually (endpoint was " + <name>endpoint</name> + ")"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <comment type="line">// Note that the endpoint is being removed</comment>
                <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// find the endpoint coordinating this removal that we need to notify when we're done</comment>
                <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>coordinator</name> <init>= <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getEndpointStateForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call>.<call><name>getApplicationState</name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>REMOVAL_COORDINATOR</name></name></expr></argument>)</argument_list></call>.<call><name><name>value</name>.<name>split</name></name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>DELIMITER_STR</name></name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Token</name></type> <name>coordtoken</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name><name>coordinator</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// grab any data we are now responsible for and notify responsible node</comment>
                <expr_stmt><expr><call><name>restoreReplicaCount</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>coordtoken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then>
        <else>else <comment type="line">// now that the gossiper has told us about this nonexistent member, notify the gossiper to remove it</comment>
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>excise</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>token</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>deleteHintsForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>removeBootstrapToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>isClientMode</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Removing token " + <name>token</name> + " for " + <name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>SystemTable</name>.<name>removeToken</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>excise</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>token</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>long</name></type> <name>expireTime</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>addExpireTimeIfFound</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>expireTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>protected</specifier> <name>void</name></type> <name>addExpireTimeIfFound</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>long</name></type> <name>expireTime</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>expireTime</name> != 0L</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addExpireTimeForEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>expireTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>protected</specifier> <name>long</name></type> <name>extractExpireTime</name><parameter_list>(<param><decl><type><name><name>String</name><index>[]</index></name></type> <name>pieces</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>expireTime</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>pieces</name>.<name>length</name></name> &gt;= 3</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>expireTime</name> = <call><name><name>Long</name>.<name>parseLong</name></name><argument_list>(<argument><expr><name><name>pieces</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>expireTime</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Finds living endpoints responsible for the given ranges
     *
     * @param table the table ranges belong to
     * @param ranges the ranges to find sources for
     * @return multimap of addresses to ranges the address is responsible for
     */</comment>
    <function><type><specifier>private</specifier> <name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getNewSourceRanges</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>myAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangeAddresses</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getRangeAddresses</name><argument_list>(<argument><expr><name>tokenMetadata_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sourceRanges</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IFailureDetector</name></type> <name>failureDetector</name> <init>= <expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// find alive sources for our new ranges</comment>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>possibleRanges</name> <init>= <expr><call><name><name>rangeAddresses</name>.<name>get</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>sources</name> <init>= <expr><call><name><name>snitch</name>.<name>getSortedListByProximity</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>, <argument><expr><name>possibleRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <assert>assert <expr>(!<call><name><name>sources</name>.<name>contains</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call>)</expr>;</assert>

            <for>for (<init><decl><type><name>InetAddress</name></type> <name>source</name> <range>: <expr><name>sources</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>failureDetector</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>sourceRanges</name>.<name>put</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block></for>
        <return>return <expr><name>sourceRanges</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sends a notification to a node indicating we have finished replicating data.
     *
     * @param local the local address
     * @param remote node to send notification to
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>sendReplicationNotification</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>local</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>remote</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// notify the remote token</comment>
        <decl_stmt><decl><type><name>Message</name></type> <name>msg</name> <init>= <expr>new <call><name>Message</name><argument_list>(<argument><expr><name>local</name></expr></argument>, <argument><expr><name><name>StorageService</name>.<name>Verb</name>.<name>REPLICATION_FINISHED</name></name></expr></argument>, <argument><expr>new <name><name>byte</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>(<argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IFailureDetector</name></type> <name>failureDetector</name> <init>= <expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Notifying " + <call><name><name>remote</name>.<name>toString</name></name><argument_list>()</argument_list></call> + " of replication completion\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <while>while <condition>(<expr><call><name><name>failureDetector</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>IAsyncResult</name></type> <name>iar</name> <init>= <expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>sendRR</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>remote</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>iar</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getRpcTimeout</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MILLISECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return> <comment type="line">// done</comment>
            }</block>
            <catch>catch<parameter_list>(<param><decl><type><name>TimeoutException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <comment type="line">// try again</comment>
            }</block></catch></try>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Called when an endpoint is removed from the ring. This function checks
     * whether this node becomes responsible for new ranges as a
     * consequence and streams data if needed.
     *
     * This is rather ineffective, but it does not matter so much
     * since this is called very seldom
     *
     * @param endpoint the node that left
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>restoreReplicaCount</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>notifyEndpoint</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>fetchSources</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>rangesToFetch</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>myAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>changedRanges</name> <init>= <expr><call><name>getChangedRangesForLeaving</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>myNewRanges</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>changedRanges</name>.<name>entries</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>myNewRanges</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sourceRanges</name> <init>= <expr><call><name>getNewSourceRanges</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>myNewRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>sourceRanges</name>.<name>asMap</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>fetchSources</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rangesToFetch</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>

        <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <range>: <expr><call><name><name>rangesToFetch</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>rangesToFetch</name>.<name>get</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>source</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>IStreamCallback</name></type> <name>callback</name> <init>= <expr>new <class><super><name>IStreamCallback</name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>()</parameter_list>
                    <block>{
                        <synchronized>synchronized (<expr><name>fetchSources</name></expr>)
                        <block>{
                            <expr_stmt><expr><call><name><name>fetchSources</name>.<name>remove</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr><call><name><name>fetchSources</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                                <expr_stmt><expr><call><name>sendReplicationNotification</name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>, <argument><expr><name>notifyEndpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                        }</block></synchronized>
                    }</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Streaming from " + <name>source</name> + " failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>onSuccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// calling onSuccess to send notification</comment>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Requesting from " + <name>source</name> + " ranges " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><call><name><name>StreamIn</name>.<name>requestRanges</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>RESTORE_REPLICA_COUNT</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
    }</block></function>

    <comment type="line">// needs to be modified to accept either a table or ARS.</comment>
    <function><type><specifier>private</specifier> <name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getChangedRangesForLeaving</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// First get all ranges the leaving endpoint is responsible for</comment>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name>getRangesForEndpoint</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " ranges [" + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call> + "]"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>currentReplicaEndpoints</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Find (for each range) all nodes that store replicas for these ranges as well</comment>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>currentReplicaEndpoints</name>.<name>put</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>calculateNaturalEndpoints</name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>, <argument><expr><name>tokenMetadata_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>temp</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>cloneAfterAllLeft</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// endpoint might or might not be 'leaving'. If it was not leaving (that is, removetoken</comment>
        <comment type="line">// command was used), it is still present in temp and must be removed.</comment>
        <if>if <condition>(<expr><call><name><name>temp</name>.<name>isMember</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>temp</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>changedRanges</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Go through the ranges and for each range check who will be</comment>
        <comment type="line">// storing replicas for these ranges when the leaving endpoint</comment>
        <comment type="line">// is gone. Whoever is present in newReplicaEndpoints list, but</comment>
        <comment type="line">// not in the currentReplicaEndpoints list, will be needing the</comment>
        <comment type="line">// range.</comment>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>newReplicaEndpoints</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>calculateNaturalEndpoints</name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>newReplicaEndpoints</name>.<name>removeAll</name></name><argument_list>(<argument><expr><call><name><name>currentReplicaEndpoints</name>.<name>get</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <if>if <condition>(<expr><call><name><name>newReplicaEndpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Range " + <name>range</name> + " already in all replicas"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Range " + <name>range</name> + " will be responsibility of " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>newReplicaEndpoints</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></then></if>
            <expr_stmt><expr><call><name><name>changedRanges</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>newReplicaEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>changedRanges</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onJoin</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>epState</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>ApplicationState</name></argument>, <argument><name>VersionedValue</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>epState</name>.<name>getApplicationStateMap</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name>onChange</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onAlive</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>state</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<name>isClientMode</name> &amp;&amp; <call><name>getTokenMetadata</name><argument_list>()</argument_list></call>.<call><name>isMember</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>scheduleHintDelivery</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onRemove</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onDead</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>state</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>convict</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>onRestart</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>endpoint</name></decl></param>, <param><decl><type><name>EndpointState</name></type> <name>state</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// If we have restarted before the node was even marked down, we need to reset the connection pool</comment>
        <if>if <condition>(<expr><call><name><name>state</name>.<name>isAlive</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>onDead</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/** raw load value */</comment>
    <function><type><specifier>public</specifier> <name>double</name></type> <name>getLoad</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>double</name></type> <name>bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>tableName</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><name>bytes</name> += <call><name><name>cfs</name>.<name>getLiveDiskSpaceUsed</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
        }</block></for>
        <return>return <expr><name>bytes</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getLoadString</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>FileUtils</name>.<name>stringifyFileSize</name></name><argument_list>(<argument><expr><call><name>getLoad</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLoadMap</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name></type> <name>map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>,<argument><name>Double</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>LoadBroadcaster</name>.<name>instance</name>.<name>getLoadInfo</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>FileUtils</name>.<name>stringifyFileSize</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <comment type="line">// gossiper doesn't see its own updates, so we need to special-case the local node</comment>
        <expr_stmt><expr><call><name><name>map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call>.<call><name>getHostAddress</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLoadString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>map</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>final</specifier> <name>void</name></type> <name>deliverHints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>host</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnknownHostException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>HintedHandOffManager</name>.<name>instance</name>.<name>scheduleHintDelivery</name></name><argument_list>(<argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>Token</name></type> <name>getLocalToken</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>SystemTable</name>.<name>getSavedToken</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <assert>assert <expr><name>token</name> != null</expr>;</assert> <comment type="line">// should not be called before initServer sets this</comment>
        <return>return <expr><name>token</name></expr>;</return>
    }</block></function>

    <comment type="block">/* These methods belong to the MBean interface */</comment>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getToken</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getLocalToken</name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getReleaseVersion</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>FBUtilities</name>.<name>getReleaseVersionString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getSchemaVersion</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getVersion</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLeavingNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getLeavingEndpoints</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getMovingNodes</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>node</name> <range>: <expr><call><name><name>tokenMetadata_</name>.<name>getMovingEndpoints</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>endpoints</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>node</name>.<name>right</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <return>return <expr><name>endpoints</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getJoiningNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getBootstrapTokens</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getLiveNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getUnreachableNodes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>stringify</name><argument_list>(<argument><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getUnreachableMembers</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>String</name></type> <name>getCanonicalPath</name><parameter_list>(<param><decl><type><name>String</name></type> <name>filename</name></decl></param>)</parameter_list>
    <block>{
        <try>try
        <block>{
            <return>return <expr>new <call><name>File</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call>.<call><name>getCanonicalPath</name><argument_list>()</argument_list></call></expr>;</return>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name><index>[]</index></type> <name>getAllDataFileLocations</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>String</name><index>[]</index></type> <name>locations</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getAllDataFileLocations</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>locations</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><name><name>locations</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>getCanonicalPath</name><argument_list>(<argument><expr><name><name>locations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>locations</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getCommitLogLocation</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getCanonicalPath</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getCommitLogLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getSavedCachesLocation</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getCanonicalPath</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getSavedCachesLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>stringify</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>stringEndpoints</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>InetAddress</name></type> <name>ep</name> <range>: <expr><name>endpoints</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>stringEndpoints</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>ep</name>.<name>getHostAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>stringEndpoints</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getCurrentGenerationNumber</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getCurrentGenerationNumber</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableCleanup</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>tableName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_TABLE</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Cleanup of the system table is neither necessary nor wise"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>NodeId</name>.<name>OneShotRenewer</name></name></type> <name>nodeIdRenewer</name> <init>= <expr>new <call><name><name>NodeId</name>.<name>OneShotRenewer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>forceCleanup</name></name><argument_list>(<argument><expr><name>nodeIdRenewer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>scrub</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>scrub</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>upgradeSSTables</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>sstablesRewrite</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableCompaction</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>forceMajorCompaction</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Takes the snapshot for the given tables. A snapshot name must be specified.
     *
     * @param tag the tag given to the snapshot; may not be null or empty
     * @param tableNames the name of the tables to snapshot; empty means "all."
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>takeSnapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>tableNames</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>tag</name> == null || <call><name><name>tag</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You must supply a snapshot name."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>tables</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>tableNames</name>.<name>length</name></name> == 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>tables</name> = <call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>t</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>tableNames</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tableNames</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>t</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <expr_stmt><expr><name>tables</name> = <name>t</name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="line">// Do a check to see if this snapshot exists before we actually snapshot</comment>
        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><name>tables</name></expr></range></decl></init>)
            <if>if <condition>(<expr><call><name><name>table</name>.<name>snapshotExists</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Snapshot " + <name>tag</name> + " already exists."</expr></argument>)</argument_list></call></expr>;</throw></then></if></for>


        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><name>tables</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>table</name>.<name>snapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Takes the snapshot of a specific column family. A snapshot name must be specified.
     *
     * @param tableName the keyspace which holds the specified column family
     * @param columnFamilyName the column family to snapshot
     * @param tag the tag given to the snapshot; may not be null or empty
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>takeColumnFamilySnapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamilyName</name></decl></param>, <param><decl><type><name>String</name></type> <name>tag</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>tableName</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You must supply a table name"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><name>columnFamilyName</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You mus supply a column family name"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><name>tag</name> == null || <call><name><name>tag</name>.<name>equals</name></name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"You must supply a snapshot name."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>table</name>.<name>snapshotExists</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Snapshot " + <name>tag</name> + " already exists."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <expr_stmt><expr><call><name><name>table</name>.<name>snapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>columnFamilyName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Table</name></type> <name>getValidTable</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Table " + <name>tableName</name> + " does not exist"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></then></if>
        <return>return <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Remove the snapshot with the given name from the given tables.
     * If no tag is specified we will remove all snapshots.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>clearSnapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>tableNames</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if<condition>(<expr><name>tag</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>tag</name> = ""</expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>tables</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>tableNames</name>.<name>length</name></name> == 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>tables</name> = <call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name></type> <name>tempTables</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Table</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>tableNames</name>.<name>length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for(<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tableNames</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>tempTables</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <expr_stmt><expr><name>tables</name> = <name>tempTables</name></expr>;</expr_stmt>
        }</block></else></if>

        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><name>tables</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>table</name>.<name>clearSnapshot</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Cleared out snapshot directories"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>getValidColumnFamilies</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>cfNames</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name>getValidTable</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>cfNames</name>.<name>length</name></name> == 0</expr>)</condition><then>
            <comment type="line">// all stores are interesting</comment>
            <return>return <expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <comment type="line">// filter out interesting stores</comment>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>valid</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>cfName</name> <range>: <expr><name>cfNames</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <init>= <expr><call><name><name>table</name>.<name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cfStore</name> == null</expr>)</condition><then>
            <block>{
                <comment type="line">// this means there was a cf passed in that is not recognized in the keyspace. report it and continue.</comment>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Invalid column family specified: %s. Proceeding with others."</expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><call><name><name>valid</name>.<name>add</name></name><argument_list>(<argument><expr><name>cfStore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>valid</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Flush all memtables for a table and column families.
     * @param tableName
     * @param columnFamilies
     * @throws IOException
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableFlush</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list>
                <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Forcing flush on keyspace " + <name>tableName</name> + ", CF " + <call><name><name>cfStore</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cfStore</name>.<name>forceBlockingFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Sends JMX notification to subscribers.
     *
     * @param type Message type
     * @param message Message itself
     * @param userObject Arbitrary object to attach to notification
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>sendNotification</name><parameter_list>(<param><decl><type><name>String</name></type> <name>type</name></decl></param>, <param><decl><type><name>String</name></type> <name>message</name></decl></param>, <param><decl><type><name>Object</name></type> <name>userObject</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Notification</name></type> <name>jmxNotification</name> <init>= <expr>new <call><name>Notification</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>jmxObjectName</name></expr></argument>, <argument><expr><call><name><name>notificationSerialNumber</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>jmxNotification</name>.<name>setUserData</name></name><argument_list>(<argument><expr><name>userObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr><name>jmxNotification</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>forceRepairAsync</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>primaryRange</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><name>primaryRange</name> ? <call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> : <call><name>getLocalRanges</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>forceRepairAsync</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>forceRepairAsync</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>Table</name>.<name>SYSTEM_TABLE</name>.<name>equals</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>0</expr>;</return></then></if>

        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>cmd</name> <init>= <expr><call><name><name>nextRepairCommand</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
        <block>{
            <expr_stmt><expr>new <call><name>Thread</name><argument_list>(<argument><expr>new <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>protected</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>Exception</name></expr></argument></throws>
                <block>{
                    <decl_stmt><decl><type><name>String</name></type> <name>message</name> <init>= <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Starting repair command #%d, repairing %d ranges for keyspace %s"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>STARTED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name></decl>;</decl_stmt>
                        <try>try
                        <block>{
                            <expr_stmt><expr><name>future</name> = <call><name>forceTableRepair</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block>
                        <catch>catch <parameter_list>(<param><decl><type><name>IllegalArgumentException</name></type> <name>e</name></decl></param>)</parameter_list>
                        <block>{
                            <expr_stmt><expr><name>message</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair session failed with error: %s"</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_FAILED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <continue>continue;</continue>
                        }</block></catch></try>
                        <if>if <condition>(<expr><name>future</name> == null</expr>)</condition><then>
                            <continue>continue;</continue></then></if>
                        <expr_stmt><expr><call><name><name>futures</name>.<name>add</name></name><argument_list>(<argument><expr><name>future</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <comment type="line">// wait for a session to be done with its differencing before starting the next one</comment>
                        <try>try
                        <block>{
                            <expr_stmt><expr><call><name><name>future</name>.<name>session</name>.<name>differencingDone</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        }</block>
                        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
                        <block>{
                            <expr_stmt><expr><name>message</name> = "Interrupted while waiting for the differencing of repair session " + <name><name>future</name>.<name>session</name></name> + " to be done. Repair may be imprecise."</expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>logger_</name>.<name>error</name></name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_FAILED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></catch></try>
                    }</block></for>
                    <for>for (<init><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name> <range>: <expr><name>futures</name></expr></range></decl></init>)
                    <block>{
                        <try>try
                        <block>{
                            <expr_stmt><expr><call><name><name>future</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>message</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair session %s for range %s finished"</expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getRange</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_SUCCESS</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block>
                        <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>e</name></decl></param>)</parameter_list>
                        <block>{
                            <expr_stmt><expr><name>message</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair session %s for range %s failed with error %s"</expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getRange</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getCause</name></name><argument_list>()</argument_list></call>.<call><name>getMessage</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_FAILED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></catch>
                        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
                        <block>{
                            <expr_stmt><expr><name>message</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair session %s for range %s failed with error %s"</expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>future</name>.<name>session</name>.<name>getRange</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>SESSION_FAILED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></catch></try>
                    }</block></for>
                    <expr_stmt><expr><call><name>sendNotification</name><argument_list>(<argument><expr>"repair"</expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Repair command #%d finished"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>new <name><name>int</name><index>[]</index></name><block>{<expr><name>cmd</name></expr>, <expr><call><name><name>AntiEntropyService</name>.<name>Status</name>.<name>FINISHED</name>.<name>ordinal</name></name><argument_list>()</argument_list></call></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></function>
            }</block></class></expr></argument>)</argument_list></call>.<call><name>start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>cmd</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>forceRepairRangeAsync</name><parameter_list>(<param><decl><type><name>String</name></type> <name>beginToken</name></decl></param>, <param><decl><type><name>String</name></type> <name>endToken</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Token</name></type> <name>parsedBeginToken</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>beginToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>parsedEndToken</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>endToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"starting user-requested repair of range ({}, {}] for keyspace {} and column families {}"</expr></argument>,
                <argument><expr>new <name><name>Object</name><index>[]</index></name> <block>{<expr><name>parsedBeginToken</name></expr>, <expr><name>parsedEndToken</name></expr>, <expr><name>tableName</name></expr>, <expr><name>columnFamilies</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>forceRepairAsync</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>parsedBeginToken</name></expr></argument>, <argument><expr><name>parsedEndToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * Trigger proactive repair for a table and column families.
     * @param tableName
     * @param columnFamilies
     * @throws IOException
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableRepair</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>Table</name>.<name>SYSTEM_TABLE</name>.<name>equals</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name>getLocalRanges</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>cmd</name> <init>= <expr><call><name><name>nextRepairCommand</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Starting repair command #{}, repairing {} ranges."</expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></argument>&gt;</argument_list></name></type> <name>futures</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name> <init>= <expr><call><name>forceTableRepair</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>future</name> == null</expr>)</condition><then>
                <continue>continue;</continue></then></if>
            <expr_stmt><expr><call><name><name>futures</name>.<name>add</name></name><argument_list>(<argument><expr><name>future</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// wait for a session to be done with its differencing before starting the next one</comment>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>future</name>.<name>session</name>.<name>differencingDone</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name><name>logger_</name>.<name>error</name></name><argument_list>(<argument><expr>"Interrupted while waiting for the differencing of repair session " + <name><name>future</name>.<name>session</name></name> + " to be done. Repair may be imprecise."</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
        }</block></for>

        <decl_stmt><decl><type><name>boolean</name></type> <name>failedSession</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

        <comment type="line">// block until all repair sessions have completed</comment>
        <for>for (<init><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name> <range>: <expr><name>futures</name></expr></range></decl></init>)
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>future</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name><name>logger_</name>.<name>error</name></name><argument_list>(<argument><expr>"Repair session " + <call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call> + " failed."</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>failedSession</name> = true</expr>;</expr_stmt>
            }</block></catch></try>
        }</block></for>

        <if>if <condition>(<expr><name>failedSession</name></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Repair command #" + <name>cmd</name> + ": some repair session(s) failed (see log for details)."</expr></argument>)</argument_list></call></expr>;</throw></then>
        <else>else
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Repair command #{} completed successfully"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableRepairPrimaryRange</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>Table</name>.<name>SYSTEM_TABLE</name>.<name>equals</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <decl_stmt><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name> <init>= <expr><call><name>forceTableRepair</name><argument_list>(<argument><expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>future</name> == null</expr>)</condition><then>
            <return>return;</return></then></if>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>future</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>error</name></name><argument_list>(<argument><expr>"Repair session " + <call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call> + " failed."</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Some repair session(s) failed (see log for details)."</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTableRepairRange</name><parameter_list>(<param><decl><type><name>String</name></type> <name>beginToken</name></decl></param>, <param><decl><type><name>String</name></type> <name>endToken</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>Table</name>.<name>SYSTEM_TABLE</name>.<name>equals</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <decl_stmt><decl><type><name>Token</name></type> <name>parsedBeginToken</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>beginToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>parsedEndToken</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>endToken</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"starting user-requested repair of range ({}, {}] for keyspace {} and column families {}"</expr></argument>,
                     <argument><expr>new <name><name>Object</name><index>[]</index></name> <block>{<expr><name>parsedBeginToken</name></expr>, <expr><name>parsedEndToken</name></expr>, <expr><name>tableName</name></expr>, <expr><name>columnFamilies</name></expr>}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>future</name> <init>= <expr><call><name>forceTableRepair</name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>parsedBeginToken</name></expr></argument>, <argument><expr><name>parsedEndToken</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>future</name> == null</expr>)</condition><then>
            <return>return;</return></then></if>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>future</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>error</name></name><argument_list>(<argument><expr>"Repair session " + <call><name><name>future</name>.<name>session</name>.<name>getName</name></name><argument_list>()</argument_list></call> + " failed."</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>AntiEntropyService</name>.<name>RepairFuture</name></name></type> <name>forceTableRepair</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name></type> <name>tableName</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isSequential</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>String</name>...</type> <name>columnFamilies</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>names</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfStore</name> <range>: <expr><call><name>getValidColumnFamilies</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>columnFamilies</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>names</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>cfStore</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>names</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"No column family to repair for keyspace " + <name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>null</expr>;</return>
        }</block></then></if>

        <return>return <expr><call><name><name>AntiEntropyService</name>.<name>instance</name>.<name>submitRepairSession</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><name>isSequential</name></expr></argument>, <argument><expr><call><name><name>names</name>.<name>toArray</name></name><argument_list>(<argument><expr>new <name><name>String</name><index>[<expr><call><name><name>names</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceTerminateAllRepairSessions</name><parameter_list>()</parameter_list> <block>{
        <expr_stmt><expr><call><name><name>AntiEntropyService</name>.<name>instance</name>.<name>terminateSessions</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/* End of MBean interface methods */</comment>

    <comment type="block" format="javadoc">/**
     * This method returns the predecessor of the endpoint ep on the identifier
     * space.
     */</comment>
    <function><type><name>InetAddress</name></type> <name>getPredecessor</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getPredecessor</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * This method returns the successor of the endpoint ep on the identifier
     * space.
     */</comment>
    <function><type><specifier>public</specifier> <name>InetAddress</name></type> <name>getSuccessor</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getSuccessor</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the primary range for the specified endpoint.
     * @param ep endpoint we are interested in.
     * @return range for the specified endpoint.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>getPrimaryRangeForEndpoint</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>tokenMetadata_</name>.<name>getPrimaryRangeFor</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get all ranges an endpoint is responsible for (by table)
     * @param ep endpoint we are interested in.
     * @return ranges for the specified endpoint.
     */</comment>
    <function><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getRangesForEndpoint</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>InetAddress</name></type> <name>ep</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getAddressRanges</name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get all ranges that span the ring given a set
     * of tokens. All ranges are in sorted order of
     * ranges.
     * @return ranges in sorted order
    */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getAllRanges</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"computing ranges for " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>sortedTokens</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>sortedTokens</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>Collections</name>.<name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
        <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><call><name><name>sortedTokens</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>size</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <block>{
            <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name> - 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>size</name> - 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>sortedTokens</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>ranges</name>.<name>add</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>ranges</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param table keyspace name also known as table
     * @param cf Column family name
     * @param key key for which we need to find the endpoint
     * @return the endpoint responsible for this key
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>String</name></type> <name>cf</name></decl></param>, <param><decl><type><name>String</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>CFMetaData</name></type> <name>cfMetaData</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTableDefinition</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>cfMetaData</name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getToken</name><argument_list>(<argument><expr><call><name><name>cfMetaData</name>.<name>getKeyValidator</name></name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getToken</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This method returns the N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param table keyspace name also known as table
     * @param pos position for which we need to find the endpoint
     * @return the endpoint responsible for this token
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>RingPosition</name></type> <name>pos</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * This method attempts to return N endpoints that are responsible for storing the
     * specified key i.e for replication.
     *
     * @param table keyspace name also known as table
     * @param key key for which we need to find the endpoint
     * @return the endpoint responsible for this key
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getLiveNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getLiveNaturalEndpoints</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>decorateKey</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>getLiveNaturalEndpoints</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>RingPosition</name></type> <name>pos</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getNaturalEndpoints</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>liveEps</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>endpoints</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><name>endpoints</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>FailureDetector</name>.<name>instance</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>liveEps</name>.<name>add</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <return>return <expr><name>liveEps</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setLog4jLevel</name><parameter_list>(<param><decl><type><name>String</name></type> <name>classQualifier</name></decl></param>, <param><decl><type><name>String</name></type> <name>rawLevel</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Level</name></type> <name>level</name> <init>= <expr><call><name><name>Level</name>.<name>toLevel</name></name><argument_list>(<argument><expr><name>rawLevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>org</name>.<name>apache</name>.<name>log4j</name>.<name>Logger</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name>classQualifier</name></expr></argument>)</argument_list></call>.<call><name>setLevel</name><argument_list>(<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"set log level to " + <name>level</name> + " for classes under '" + <name>classQualifier</name> + "' (if the level doesn't look like '" + <name>rawLevel</name> + "' then log4j couldn't parse '" + <name>rawLevel</name> + "')"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return list of Token ranges (_not_ keys!) together with estimated key count,
     *      breaking up the data this node is responsible for into pieces of roughly keysPerSplit
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getSplits</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>, <param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name>int</name></type> <name>keysPerSplit</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Table</name></type> <name>t</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <init>= <expr><call><name><name>t</name>.<name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr><call><name>keySamples</name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>long</name></type> <name>totalRowCountEstimate</name> <init>= <expr>(<call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> + 1) * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// splitCount should be much smaller than number of key samples, to avoid huge sampling error</comment>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>minSamplesPerSplit</name> <init>= <expr>4</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>maxSplitCount</name> <init>= <expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> / <name>minSamplesPerSplit</name> + 1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>splitCount</name> <init>= <expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>maxSplitCount</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>totalRowCountEstimate</name> / <name>keysPerSplit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name>keysToTokens</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>getSplits</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>splitCount</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getSplits</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name></decl></param>, <param><decl><type><name>int</name></type> <name>splitCount</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>double</name></type> <name>step</name> <init>= <expr><call>(<name>double</name>) <argument_list>(<argument><expr><call><name><name>tokens</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call> / <name>splitCount</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>prevIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>prevToken</name> <init>= <expr><call><name><name>tokens</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>splits</name> <init>= <expr><call><name><name>Lists</name>.<name>newArrayListWithExpectedSize</name></name><argument_list>(<argument><expr><name>splitCount</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>i</name> &lt;= <name>splitCount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>(<name>int</name>) <call><name><name>Math</name>.<name>round</name></name><argument_list>(<argument><expr><name>i</name> * <name>step</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>tokens</name>.<name>get</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>rowCountEstimate</name> <init>= <expr>(<name>index</name> - <name>prevIndex</name>) * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>splits</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>Pair</name>.<name>create</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>prevToken</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rowCountEstimate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>prevIndex</name> = <name>index</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>prevToken</name> = <name>token</name></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>splits</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>keysToTokens</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>tokens</name> <init>= <expr><call><name><name>Lists</name>.<name>newArrayListWithExpectedSize</name></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> + 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>DecoratedKey</name></type> <name>key</name> <range>: <expr><name>keys</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>key</name>.<name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name><name>tokens</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>tokens</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keySamples</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfses</name></decl></param>, <param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>cfses</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>Iterables</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><call><name><name>cfs</name>.<name>keySamples</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <expr_stmt><expr><call><name><name>FBUtilities</name>.<name>sortSampledKeys</name></name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>keys</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/** return a token to which if a node bootstraps it will get about 1/2 of this node's range */</comment>
    <function><type><specifier>public</specifier> <name>Token</name></type> <name>getBootstrapToken</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr><call><name>keySamples</name><argument_list>(<argument><expr><call><name><name>ColumnFamilyStore</name>.<name>allUserDefined</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Token</name></type> <name>token</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; 3</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>token</name> = <call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>midpoint</name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Used midpoint to assign token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name>token</name> = <call><name><name>keys</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> / 2</expr></argument>)</argument_list></call>.<name>token</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Used key sample of size " + <call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call> + " to assign token " + <name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call> != null &amp;&amp; <call><name><name>tokenMetadata_</name>.<name>isMember</name></name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Chose token " + <name>token</name> + " which is already in use by " + <call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call> + " -- specify one manually with initial_token"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <comment type="line">// Hack to prevent giving nodes tokens with DELIMITER_STR in them (which is fine in a row key/token)</comment>
        <if>if <condition>(<expr><name>token</name> instanceof <name>StringToken</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>token</name> = new <call><name>StringToken</name><argument_list>(<argument><expr>((<name>String</name>)<name><name>token</name>.<name>token</name></name>).<call><name>replaceAll</name><argument_list>(<argument><expr><name><name>VersionedValue</name>.<name>DELIMITER_STR</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>getNormalAndBootstrappingTokenToEndpointMap</name></name><argument_list>()</argument_list></call>.<call><name>containsKey</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Unable to compute unique token for new node -- specify one manually with initial_token"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        }</block></then></if>
        <return>return <expr><name>token</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Broadcast leaving status and update local tokenMetadata_ accordingly
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>startLeaving</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>leaving</name></name><argument_list>(<argument><expr><call><name>getLocalToken</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>decommission</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>tokenMetadata_</name>.<name>isMember</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"local node is not a member of the token ring yet"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>cloneAfterAllLeft</name></name><argument_list>()</argument_list></call>.<call><name>sortedTokens</name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &lt; 2</expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"no other normal nodes in the ring; decommission would be pointless"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>blockUntilFinished</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>getPendingRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"data is currently moving to this node; unable to leave the ring"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"DECOMMISSIONING"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>startLeaving</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>LEAVING</name></name></expr></argument>, <argument><expr>"sleeping " + <name>RING_DELAY</name> + " ms for pending range setup"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Runnable</name></type> <name>finishLeaving</name> <init>= <expr>new <class><super><name>Runnable</name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
            <block>{
                <expr_stmt><expr><call><name>stopRPCServer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>StageManager</name>.<name>shutdownNow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DECOMMISSIONED</name></name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// let op be responsible for killing the process</comment>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>unbootstrap</name><argument_list>(<argument><expr><name>finishLeaving</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>leaveRing</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>SystemTable</name>.<name>setBootstrapState</name></name><argument_list>(<argument><expr><name><name>SystemTable</name>.<name>BootstrapState</name>.<name>NEEDS_BOOTSTRAP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>removeEndpoint</name></name><argument_list>(<argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>left</name></name><argument_list>(<argument><expr><call><name>getLocalToken</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><call><name><name>Gossiper</name>.<name>computeExpireTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>delay</name> <init>= <expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>, <argument><expr><name><name>Gossiper</name>.<name>intervalInMillis</name></name> * 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Announcing that I have left the ring for " + <name>delay</name> + "ms"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>delay</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>unbootstrap</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>Runnable</name></type> <name>onFinish</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToStream</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangesMM</name> <init>= <expr><call><name>getChangedRangesForLeaving</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Ranges needing transfer are [" + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><call><name><name>rangesMM</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call> + "]"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><call><name><name>rangesToStream</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>rangesMM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>LEAVING</name></name></expr></argument>, <argument><expr>"streaming data to other nodes"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>latch</name> <init>= <expr><call><name>streamRanges</name><argument_list>(<argument><expr><name>rangesToStream</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// wait for the transfer runnables to signal the latch.</comment>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"waiting for stream aks."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>latch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"stream acks all received."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leaveRing</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>onFinish</name>.<name>run</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>move</name><parameter_list>(<param><decl><type><name>String</name></type> <name>newToken</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>validate</name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>move</name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * move the node to new token or find a new token to boot to according to load
     *
     * @param newToken new token to boot to, or if null, find balanced token to boot to
     *
     * @throws IOException on any I/O operation error
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>move</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>newToken</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>newToken</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"Can't move to the undefined (null) token."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>sortedTokens</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IOException</name><argument_list>(<argument><expr>"target token " + <name>newToken</name> + " is already owned by another node."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// address of the current node</comment>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>localAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tablesToProcess</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>blockUntilFinished</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// checking if data is moving to this node</comment>
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tablesToProcess</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>getPendingRanges</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>localAddress</name></expr></argument>)</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
                <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"data is currently moving to this node; unable to leave the ring"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        }</block></for>

        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>addLocalApplicationState</name></name><argument_list>(<argument><expr><name><name>ApplicationState</name>.<name>STATUS</name></name></expr></argument>, <argument><expr><call><name><name>valueFactory</name>.<name>moving</name></name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>MOVING</name></name></expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Moving %s from %s to %s."</expr></argument>, <argument><expr><name>localAddress</name></expr></argument>, <argument><expr><call><name>getLocalToken</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>snitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToFetch</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToStreamByTable</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>tokenMetaClone</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>cloneAfterAllSettled</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// for each of the non system tables calculating new ranges</comment>
        <comment type="line">// which current node will handle after move to the new token</comment>
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><name>tablesToProcess</name></expr></range></decl></init>)
        <block>{
            <comment type="line">// replication strategy of the current keyspace (aka table)</comment>
            <decl_stmt><decl><type><name>AbstractReplicationStrategy</name></type> <name>strategy</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// getting collection of the currently used ranges by this keyspace</comment>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>currentRanges</name> <init>= <expr><call><name>getRangesForEndpoint</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// collection of ranges which this node will serve after move to the new token</comment>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>updatedRanges</name> <init>= <expr><call><name><name>strategy</name>.<name>getPendingAddressRanges</name></name><argument_list>(<argument><expr><name>tokenMetadata_</name></expr></argument>, <argument><expr><name>newToken</name></expr></argument>, <argument><expr><name>localAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// ring ranges and endpoints associated with them</comment>
            <comment type="line">// this used to determine what nodes should we ping about range data</comment>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangeAddresses</name> <init>= <expr><call><name><name>strategy</name>.<name>getRangeAddresses</name></name><argument_list>(<argument><expr><name>tokenMetadata_</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// calculated parts of the ranges to request/stream from/to nodes in the ring</comment>
            <decl_stmt><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesPerTable</name> <init>= <expr><call><name>calculateStreamAndFetchRanges</name><argument_list>(<argument><expr><name>currentRanges</name></expr></argument>, <argument><expr><name>updatedRanges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="block" format="javadoc">/**
             * In this loop we are going through all ranges "to fetch" and determining
             * nodes in the ring responsible for data we are interested in
             */</comment>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangesToFetchWithPreferredEndpoints</name> <init>= <expr><call><name><name>ArrayListMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>toFetch</name> <range>: <expr><name><name>rangesPerTable</name>.<name>right</name></name></expr></range></decl></init>)
            <block>{
                <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name><name>rangeAddresses</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>range</name>.<name>contains</name></name><argument_list>(<argument><expr><name>toFetch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>endpoints</name> <init>= <expr><call><name><name>snitch</name>.<name>getSortedListByProximity</name></name><argument_list>(<argument><expr><name>localAddress</name></expr></argument>, <argument><expr><call><name><name>rangeAddresses</name>.<name>get</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <comment type="line">// storing range and preferred endpoint set</comment>
                        <expr_stmt><expr><call><name><name>rangesToFetchWithPreferredEndpoints</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>toFetch</name></expr></argument>, <argument><expr><name>endpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></for>

            <comment type="line">// calculating endpoints to stream current ranges to if needed</comment>
            <comment type="line">// in some situations node will handle current ranges as part of the new ranges</comment>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangeWithEndpoints</name> <init>= <expr><call><name><name>HashMultimap</name>.<name>create</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>toStream</name> <range>: <expr><name><name>rangesPerTable</name>.<name>left</name></name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>currentEndpoints</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>strategy</name>.<name>calculateNaturalEndpoints</name></name><argument_list>(<argument><expr><name><name>toStream</name>.<name>right</name></name></expr></argument>, <argument><expr><name>tokenMetadata_</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>newEndpoints</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>strategy</name>.<name>calculateNaturalEndpoints</name></name><argument_list>(<argument><expr><name><name>toStream</name>.<name>right</name></name></expr></argument>, <argument><expr><name>tokenMetaClone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>rangeWithEndpoints</name>.<name>putAll</name></name><argument_list>(<argument><expr><name>toStream</name></expr></argument>, <argument><expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><name>newEndpoints</name></expr></argument>, <argument><expr><name>currentEndpoints</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// associating table with range-to-endpoints map</comment>
            <expr_stmt><expr><call><name><name>rangesToStreamByTable</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>rangeWithEndpoints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>workMap</name> <init>= <expr><call><name><name>RangeStreamer</name>.<name>getWorkMap</name></name><argument_list>(<argument><expr><name>rangesToFetchWithPreferredEndpoints</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>rangesToFetch</name>.<name>put</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>workMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Table {}: work map {}."</expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>workMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <if>if <condition>(<expr>!<call><name><name>rangesToStreamByTable</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> || !<call><name><name>rangesToFetch</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>MOVING</name></name></expr></argument>, <argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Sleeping %s ms before start streaming/fetching ranges"</expr></argument>, <argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr><name>RING_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Sleep interrupted " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>

            <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>MOVING</name></name></expr></argument>, <argument><expr>"fetching new ranges and streaming old ranges"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"[Move-&gt;STREAMING] Work Map: " + <name>rangesToStreamByTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>streamLatch</name> <init>= <expr><call><name>streamRanges</name><argument_list>(<argument><expr><name>rangesToStreamByTable</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"[Move-&gt;FETCHING] Work Map: " + <name>rangesToFetch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <decl_stmt><decl><type><name>CountDownLatch</name></type> <name>fetchLatch</name> <init>= <expr><call><name>requestRanges</name><argument_list>(<argument><expr><name>rangesToFetch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>streamLatch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>fetchLatch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Interrupted latch while waiting for stream/fetch ranges to finish: " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then></if>

        <expr_stmt><expr><call><name>setToken</name><argument_list>(<argument><expr><name>newToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// setting new token as we have everything settled</comment>

        <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Successfully moved to new token {}"</expr></argument>, <argument><expr><call><name>getLocalToken</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the status of a token removal.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getRemovalStatus</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>removingNode</name> == null</expr>)</condition><then> <block>{
            <return>return <expr>"No token removals in process."</expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Removing token (%s). Waiting for replication confirmation from [%s]."</expr></argument>,
                             <argument><expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>removingNode</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>replicatingNodes</name></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Force a remove operation to complete. This may be necessary if a remove operation
     * blocks forever due to node/stream failure. removeToken() must be called
     * first, this is a last resort measure.  No further attempt will be made to restore replicas.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceRemoveCompletion</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call>  || !<call><name><name>tokenMetadata_</name>.<name>getLeavingEndpoints</name></name><argument_list>()</argument_list></call>.<call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Removal not confirmed for for " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>replicatingNodes</name></name></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><call><name><name>tokenMetadata_</name>.<name>getLeavingEndpoints</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>advertiseTokenRemoved</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>removingNode</name> = null</expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"No tokens to force removal on, call 'removetoken' first"</expr></argument>)</argument_list></call></expr>;</throw>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Remove a node that has died, attempting to restore the replica count.
     * If the node is alive, decommission should be attempted.  If decommission
     * fails, then removeToken should be called.  If we fail while trying to
     * restore the replica count, finally forceRemoveCompleteion should be
     * called to forcibly remove the node without regard to replica count.
     *
     * @param tokenString token for the node
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>removeToken</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tokenString</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>myAddress</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>localToken</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>getTokenFactory</name><argument_list>()</argument_list></call>.<call><name>fromString</name><argument_list>(<argument><expr><name>tokenString</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>InetAddress</name></type> <name>endpoint</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getEndpoint</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>endpoint</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Token not found."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><call><name><name>endpoint</name>.<name>equals</name></name><argument_list>(<argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr>)</condition><then>
             <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Cannot remove node's own token"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>getLiveMembers</name></name><argument_list>()</argument_list></call>.<call><name>contains</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " is alive and owns this token. Use decommission command to remove it from the ring"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// A leaving endpoint that is dead is already being removed.</comment>
        <if>if <condition>(<expr><call><name><name>tokenMetadata_</name>.<name>isLeaving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Node " + <name>endpoint</name> + " is already being removed, continuing removal anyway"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"This node is already processing a removal. Wait for it to complete, or use 'removetoken force' if this has failed."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <comment type="line">// Find the endpoints that are going to become responsible for data</comment>
        <for>for (<init><decl><type><name>String</name></type> <name>table</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <comment type="line">// if the replication factor is 1 the data is lost so we shouldn't wait for confirmation</comment>
            <if>if <condition>(<expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<call><name>getReplicationFactor</name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <comment type="line">// get all ranges that change ownership (that is, a node needs</comment>
            <comment type="line">// to take responsibility for new range)</comment>
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>changedRanges</name> <init>= <expr><call><name>getChangedRangesForLeaving</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>IFailureDetector</name></type> <name>failureDetector</name> <init>= <expr><name><name>FailureDetector</name>.<name>instance</name></name></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>InetAddress</name></type> <name>ep</name> <range>: <expr><call><name><name>changedRanges</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>failureDetector</name>.<name>isAlive</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>add</name></name><argument_list>(<argument><expr><name>ep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Endpoint " + <name>ep</name> + " is down and will not receive data for re-replication of " + <name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></for>
        }</block></for>
        <expr_stmt><expr><name>removingNode</name> = <name>endpoint</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>tokenMetadata_</name>.<name>addLeavingEndpoint</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>PendingRangeCalculatorService</name>.<name>instance</name>.<name>update</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// the gossiper will handle spoofing this node's state to REMOVING_TOKEN for us</comment>
        <comment type="line">// we add our own token so other nodes to let us know when they're done</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>advertiseRemoving</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>localToken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// kick off streaming commands</comment>
        <expr_stmt><expr><call><name>restoreReplicaCount</name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>myAddress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// wait for ReplicationFinishedVerbHandler to signal we're done</comment>
        <while>while <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></while>

        <expr_stmt><expr><call><name>excise</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// gossiper will indicate the token has left</comment>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>advertiseTokenRemoved</name></name><argument_list>(<argument><expr><name>endpoint</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>removingNode</name> = null</expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>confirmReplication</name><parameter_list>(<param><decl><type><name>InetAddress</name></type> <name>node</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// replicatingNodes can be empty in the case where this node used to be a removal coordinator,</comment>
        <comment type="line">// but restarted before all 'replication finished' messages arrived. In that case, we'll</comment>
        <comment type="line">// still go ahead and acknowledge it.</comment>
        <if>if <condition>(<expr>!<call><name><name>replicatingNodes</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>replicatingNodes</name>.<name>remove</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Received unexpected REPLICATION_FINISHED message from " + <name>node</name>
                         + ". Was this node recently a removal coordinator?"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isClientMode</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>isClientMode</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>requestGC</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name>hasUnreclaimedSpace</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"requesting GC to free disk space"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>System</name>.<name>gc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hasUnreclaimedSpace</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>ColumnFamilyStore</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>cfs</name>.<name>hasUnreclaimedSpace</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getOperationMode</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>operationMode</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getDrainProgress</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Drained %s/%s ColumnFamilies"</expr></argument>, <argument><expr><name>remainingCFs</name></expr></argument>, <argument><expr><name>totalCFs</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Shuts node off to writes, empties memtables and the commit log.
     * There are two differences between drain and the normal shutdown hook:
     * - Drain waits for in-progress streaming to complete
     * - Drain flushes *all* columnfamilies (shutdown hook only flushes non-durable CFs)
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>drain</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>ExecutorService</name></type> <name>mutationStage</name> <init>= <expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>MUTATION</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>mutationStage</name>.<name>isTerminated</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Cannot drain node (did it already happen?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"starting drain process"</expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>stopRPCServer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>optionalTasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>Gossiper</name>.<name>instance</name>.<name>stop</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"shutting down MessageService"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"waiting for streaming"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>MessagingService</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>waitForStreaming</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"clearing mutation stage"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mutationStage</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>mutationStage</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>3600</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>SECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>instance</name>.<name>verifyNoHintsInProgress</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINING</name></name></expr></argument>, <argument><expr>"flushing column families"</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfses</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>tableName</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>cfses</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>totalCFs</name> = <name>remainingCFs</name> = <call><name><name>cfses</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>cfses</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>cfs</name>.<name>forceBlockingFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remainingCFs</name>--</expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>postFlushExecutor</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>postFlushExecutor</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>60</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>SECONDS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>shutdownBlocking</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// wait for miscellaneous tasks like sstable and commitlog segment deletion</comment>
        <expr_stmt><expr><call><name><name>tasks</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name><name>tasks</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>MINUTES</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Miscellaneous task executor still busy after one minute; proceeding with shutdown"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>setMode</name><argument_list>(<argument><expr><name><name>Mode</name>.<name>DRAINED</name></name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// Never ever do this at home. Used by tests.</comment>
    <function><type><name>IPartitioner</name></type> <name>setPartitionerUnsafe</name><parameter_list>(<param><decl><type><name>IPartitioner</name></type> <name>newPartitioner</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>IPartitioner</name></type> <name>oldPartitioner</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setPartitioner</name></name><argument_list>(<argument><expr><name>newPartitioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>valueFactory</name> = new <call><name><name>VersionedValue</name>.<name>VersionedValueFactory</name></name><argument_list>(<argument><expr><call><name>getPartitioner</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>oldPartitioner</name></expr>;</return>
    }</block></function>

    <function><type><name>TokenMetadata</name></type> <name>setTokenMetadataUnsafe</name><parameter_list>(<param><decl><type><name>TokenMetadata</name></type> <name>tmd</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>TokenMetadata</name></type> <name>old</name> <init>= <expr><name>tokenMetadata_</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>tokenMetadata_</name> = <name>tmd</name></expr>;</expr_stmt>
        <return>return <expr><name>old</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>truncate</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>TimeoutException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>truncateBlocking</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>getOwnership</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getTokenToEndpointMapForReading</name></name><argument_list>()</argument_list></call>.<call><name>keySet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>sortedTokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>token_map</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>describeOwnership</name><argument_list>(<argument><expr><name>sortedTokens</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>string_map</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for(<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>token_map</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>string_map</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>string_map</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>effectiveOwnership</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>effective</name> <init>= <expr><call><name><name>Maps</name>.<name>newHashMap</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &lt;= 0</expr>)</condition><then>
            <throw>throw <expr>new <call><name>ConfigurationException</name><argument_list>(<argument><expr>"Couldn't find any Non System Keyspaces to infer replication topology"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <if>if <condition>(<expr><name>keyspace</name> == null &amp;&amp; !<call><name>hasSameReplication</name><argument_list>(<argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>ConfigurationException</name><argument_list>(<argument><expr>"Non System keyspaces doesnt have the same topology"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <if>if <condition>(<expr><name>keyspace</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>keyspace</name> = <call><name><name>Schema</name>.<name>instance</name>.<name>getNonSystemTables</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>sortedTokens</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>tokenMetadata_</name>.<name>getTokenToEndpointMapForReading</name></name><argument_list>()</argument_list></call>.<call><name>keySet</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>sortedTokens</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Token</name></argument>, <argument><name>Float</name></argument>&gt;</argument_list></name></type> <name>ownership</name> <init>= <expr><call><name>getPartitioner</name><argument_list>()</argument_list></call>.<call><name>describeOwnership</name><argument_list>(<argument><expr><name>sortedTokens</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name><name>Entry</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <range>: <expr><call><name>constructEndpointToRangeMap</name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Token</name></type> <name>token</name> <init>= <expr><call><name><name>tokenMetadata_</name>.<name>getToken</name></name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name><range>: <expr><call><name><name>ranges</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><call><name><name>effective</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>token</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == null ? 0.0F : <call><name><name>effective</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>token</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>effective</name>.<name>put</name></name><argument_list>(<argument><expr><call><name><name>token</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>value</name> + <call><name><name>ownership</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>effective</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>hasSameReplication</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>list</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>list</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>list</name>.<name>size</name></name><argument_list>()</argument_list></call> -1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <decl_stmt><decl><type><name>KSMetaData</name></type> <name>ksm1</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getKSMetaData</name></name><argument_list>(<argument><expr><call><name><name>list</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>KSMetaData</name></type> <name>ksm2</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getKSMetaData</name></name><argument_list>(<argument><expr><call><name><name>list</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name><name>ksm1</name>.<name>strategyClass</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>ksm2</name>.<name>strategyClass</name></name></expr></argument>)</argument_list></call> ||
                    !<call><name><name>Iterators</name>.<name>elementsEqual</name></name><argument_list>(<argument><expr><call><name><name>ksm1</name>.<name>strategyOptions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></argument>,
                                             <argument><expr><call><name><name>ksm2</name>.<name>strategyOptions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getKeyspaces</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>tableslist</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>Collections</name>.<name>unmodifiableList</name></name><argument_list>(<argument><expr><name>tableslist</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateSnitch</name><parameter_list>(<param><decl><type><name>String</name></type> <name>epSnitchClassName</name></decl></param>, <param><decl><type><name>Boolean</name></type> <name>dynamic</name></decl></param>, <param><decl><type><name>Integer</name></type> <name>dynamicUpdateInterval</name></decl></param>, <param><decl><type><name>Integer</name></type> <name>dynamicResetInterval</name></decl></param>, <param><decl><type><name>Double</name></type> <name>dynamicBadnessThreshold</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>oldSnitch</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// new snitch registers mbean during construction</comment>
        <decl_stmt><decl><type><name>IEndpointSnitch</name></type> <name>newSnitch</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>construct</name></name><argument_list>(<argument><expr><name>epSnitchClassName</name></expr></argument>, <argument><expr>"snitch"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>dynamic</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setDynamicUpdateInterval</name></name><argument_list>(<argument><expr><name>dynamicUpdateInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setDynamicResetInterval</name></name><argument_list>(<argument><expr><name>dynamicResetInterval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setDynamicBadnessThreshold</name></name><argument_list>(<argument><expr><name>dynamicBadnessThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>newSnitch</name> = new <call><name>DynamicEndpointSnitch</name><argument_list>(<argument><expr><name>newSnitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// point snitch references to the new instance</comment>
        <expr_stmt><expr><call><name><name>DatabaseDescriptor</name>.<name>setEndpointSnitch</name></name><argument_list>(<argument><expr><name>newSnitch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>String</name></type> <name>ks</name> <range>: <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>ks</name></expr></argument>)</argument_list></call>.<call><name>getReplicationStrategy</name><argument_list>()</argument_list></call>.<name>snitch</name> = <name>newSnitch</name></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><name>oldSnitch</name> instanceof <name>DynamicEndpointSnitch</name></expr>)</condition><then>
            <expr_stmt><expr>((<name>DynamicEndpointSnitch</name>)<name>oldSnitch</name>).<call><name>unregisterMBean</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Flushes the two largest memtables by ops and by throughput
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>flushLargestMemtables</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>largest</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>ColumnFamilyStore</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>total</name> <init>= <expr><call><name><name>cfs</name>.<name>getTotalMemtableLiveSize</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>total</name> &gt; 0 &amp;&amp; (<name>largest</name> == null || <name>total</name> &gt; <call><name><name>largest</name>.<name>getTotalMemtableLiveSize</name></name><argument_list>()</argument_list></call>)</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr><name>total</name> + " estimated memtable size for " + <name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>largest</name> = <name>cfs</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>largest</name> == null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger_</name>.<name>info</name></name><argument_list>(<argument><expr>"Unable to reduce heap usage since there are no dirty column families"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Flushing " + <name>largest</name> + " to relieve memory pressure"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>largest</name>.<name>forceFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Seed data to the endpoints that will be responsible for it at the future
     *
     * @param rangesToStreamByTable tables and data ranges with endpoints included for each
     * @return latch to count down
     */</comment>
    <function><type><specifier>private</specifier> <name>CountDownLatch</name></type> <name>streamRanges</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangesToStreamByTable</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name> <init>= <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr><call><name><name>rangesToStreamByTable</name>.<name>keySet</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>rangesToStreamByTable</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>rangesWithEndpoints</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>rangesWithEndpoints</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>pending</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>rangesWithEndpoints</name>.<name>entries</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><specifier>final</specifier> <name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name>InetAddress</name></argument>&gt;</argument_list></name></name></type> <name>endPointEntry</name> <range>: <expr><call><name><name>rangesWithEndpoints</name>.<name>entries</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><specifier>final</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name><name>endPointEntry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>newEndpoint</name> <init>= <expr><call><name><name>endPointEntry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>IStreamCallback</name></type> <name>callback</name> <init>= <expr>new <class><super><name>IStreamCallback</name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>()</parameter_list>
                    <block>{
                        <synchronized>synchronized (<expr><name>pending</name></expr>)
                        <block>{
                            <expr_stmt><expr><call><name><name>pending</name>.<name>remove</name></name><argument_list>(<argument><expr><name>endPointEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <if>if <condition>(<expr><call><name><name>pending</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                                <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                        }</block></synchronized>
                    }</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Streaming to " + <name>endPointEntry</name> + " failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>onSuccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// calling onSuccess for latch countdown</comment>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name><name>StageManager</name>.<name>getStage</name></name><argument_list>(<argument><expr><name><name>Stage</name>.<name>STREAM</name></name></expr></argument>)</argument_list></call>.<call><name>execute</name><argument_list>(<argument><expr>new <class><super><name>Runnable</name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
                    <block>{
                        <comment type="line">// TODO each call to transferRanges re-flushes, this is potentially a lot of waste</comment>
                        <expr_stmt><expr><call><name><name>StreamOut</name>.<name>transferRanges</name></name><argument_list>(<argument><expr><name>newEndpoint</name></expr></argument>, <argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>UNBOOTSTRAP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></function>
                }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>latch</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Used to request ranges from endpoints in the ring (will block until all data is fetched and ready)
     * @param ranges ranges to fetch as map of the preferred address and range collection
     * @return latch to count down
     */</comment>
    <function><type><specifier>private</specifier> <name>CountDownLatch</name></type> <name>requestRanges</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name> <init>= <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>keySet</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>String</name></argument>, <argument><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>ranges</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Multimap</name><argument_list>&lt;<argument><name>InetAddress</name></argument>, <argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>endpointWithRanges</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>endpointWithRanges</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <decl_stmt><decl><type><specifier>final</specifier> <name>String</name></type> <name>table</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>pending</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>endpointWithRanges</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Send messages to respective folks to stream data over to me</comment>
            <for>for (<init><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>source</name><range>: <expr><call><name><name>endpointWithRanges</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>toFetch</name> <init>= <expr><call><name><name>endpointWithRanges</name>.<name>get</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><specifier>final</specifier> <name>IStreamCallback</name></type> <name>callback</name> <init>= <expr>new <class><super><name>IStreamCallback</name></super><argument_list>()</argument_list>
                <block>{
                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onSuccess</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>pending</name>.<name>remove</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <if>if <condition>(<expr><call><name><name>pending</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <expr_stmt><expr><call><name><name>latch</name>.<name>countDown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                    }</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>onFailure</name><parameter_list>()</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger_</name>.<name>warn</name></name><argument_list>(<argument><expr>"Streaming from " + <name>source</name> + " failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>onSuccess</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// calling onSuccess for latch countdown</comment>
                    }</block></function>
                }</block></class></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><call><name><name>logger_</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>logger_</name>.<name>debug</name></name><argument_list>(<argument><expr>"Requesting from " + <name>source</name> + " ranges " + <call><name><name>StringUtils</name>.<name>join</name></name><argument_list>(<argument><expr><name>toFetch</name></expr></argument>, <argument><expr>", "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                <comment type="line">// sending actual request</comment>
                <expr_stmt><expr><call><name><name>StreamIn</name>.<name>requestRanges</name></name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>toFetch</name></expr></argument>, <argument><expr><name>callback</name></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>BOOTSTRAP</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></for>
        <return>return <expr><name>latch</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Calculate pair of ranges to stream/fetch for given two range collections
     * (current ranges for table and ranges after move to new token)
     *
     * @param current collection of the ranges by current token
     * @param updated collection of the ranges after token is changed
     * @return pair of ranges to stream/fetch for given current and updated range collections
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>calculateStreamAndFetchRanges</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>current</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>updated</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>toStream</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>toFetch</name>  <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


        <for>for (<init><decl><type><name>Range</name></type> <name>r1</name> <range>: <expr><name>current</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>intersect</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>Range</name></type> <name>r2</name> <range>: <expr><name>updated</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>r1</name>.<name>intersects</name></name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// adding difference ranges to fetch from a ring</comment>
                    <expr_stmt><expr><call><name><name>toStream</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>r1</name>.<name>subtract</name></name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intersect</name> = true</expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr>!<name>intersect</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>toStream</name>.<name>add</name></name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// should seed whole old range</comment>
            }</block></then></if>
        }</block></for>

        <for>for (<init><decl><type><name>Range</name></type> <name>r2</name> <range>: <expr><name>updated</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>boolean</name></type> <name>intersect</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>Range</name></type> <name>r1</name> <range>: <expr><name>current</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr><call><name><name>r2</name>.<name>intersects</name></name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// adding difference ranges to fetch from a ring</comment>
                    <expr_stmt><expr><call><name><name>toFetch</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>r2</name>.<name>subtract</name></name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>intersect</name> = true</expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr>!<name>intersect</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>toFetch</name>.<name>add</name></name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// should fetch whole old range</comment>
            }</block></then></if>
        }</block></for>

        <return>return <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>toStream</name></expr></argument>, <argument><expr><name>toFetch</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>bulkLoad</name><parameter_list>(<param><decl><type><name>String</name></type> <name>directory</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>File</name></type> <name>dir</name> <init>= <expr>new <call><name>File</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name><name>dir</name>.<name>exists</name></name><argument_list>()</argument_list></call> || !<call><name><name>dir</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr>"Invalid directory " + <name>directory</name></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name><name>SSTableLoader</name>.<name>Client</name></name></type> <name>client</name> <init>= <expr>new <class><super><name><name>SSTableLoader</name>.<name>Client</name></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>void</name></type> <name>init</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>)</parameter_list>
            <block>{
                <try>try
                <block>{
                    <expr_stmt><expr><call><name>setPartitioner</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>List</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getRangeToAddressMap</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>)</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                        <for>for (<init><decl><type><name>InetAddress</name></type> <name>endpoint</name> <range>: <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                            <expr_stmt><expr><call><name>addRangeForEndpoint</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>endpoint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
                    }</block></for>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></function>

            <function><type><annotation>@<name>Override</name></annotation>
            <specifier>public</specifier> <name>boolean</name></type> <name>validateColumnFamily</name><parameter_list>(<param><decl><type><name>String</name></type> <name>keyspace</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>)</parameter_list>
            <block>{
                <return>return <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getCFMetaData</name></name><argument_list>(<argument><expr><name>keyspace</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call> != null</expr>;</return>
            }</block></function>
        }</block></class></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>SSTableLoader</name></type> <name>loader</name> <init>= <expr>new <call><name>SSTableLoader</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>client</name></expr></argument>, <argument><expr>new <call><name><name>OutputHandler</name>.<name>LogOutput</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>loader</name>.<name>stream</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getExceptionCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>AbstractCassandraDaemon</name>.<name>exceptions</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>rescheduleFailedDeletions</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>SSTableDeletingTask</name>.<name>rescheduleFailedTasks</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * #{@inheritDoc}
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>loadNewSSTables</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ksName</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>loadNewSSTables</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * #{@inheritDoc}
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>sampleKeyRange</name><parameter_list>()</parameter_list> <comment type="line">// do not rename to getter - see CASSANDRA-4452 for details</comment>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr><call><name>keySamples</name><argument_list>(<argument><expr><call><name><name>ColumnFamilyStore</name>.<name>allUserDefined</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLocalPrimaryRange</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>sampledKeys</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>DecoratedKey</name></type> <name>key</name> <range>: <expr><name>keys</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>sampledKeys</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>key</name>.<name>getToken</name></name><argument_list>()</argument_list></call>.<call><name>toString</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>sampledKeys</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>rebuildSecondaryIndex</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ksName</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>idxNames</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>ColumnFamilyStore</name>.<name>rebuildSecondaryIndex</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>, <argument><expr><name>idxNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>resetLocalSchema</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>MigrationManager</name>.<name>resetLocalSchema</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>
}</block></class>
</unit>
