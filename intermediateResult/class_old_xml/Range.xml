<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\dht\Range.java"><comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>Serializable</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>commons</name>.<name>lang</name>.<name>ObjectUtils</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>RowPosition</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>Pair</name></name>;</import>

<comment type="block" format="javadoc">/**
 * A representation of the range that a node is responsible for on the DHT ring.
 *
 * A Range is responsible for the tokens between (left, right].
 *
 * Used by the partitioner and by map/reduce by-token range scans.
 */</comment>
<class><specifier>public</specifier> class <name><name>Range</name><argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list></name> <super><extends>extends <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></extends> <implements>implements <name><name>Comparable</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name>, <name>Serializable</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>long</name></type> <name>serialVersionUID</name> <init>= <expr>1L</expr></init></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>Range</name><parameter_list>(<param><decl><type><name>T</name></type> <name>left</name></decl></param>, <param><decl><type><name>T</name></type> <name>right</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>Range</name><parameter_list>(<param><decl><type><name>T</name></type> <name>left</name></decl></param>, <param><decl><type><name>T</name></type> <name>right</name></decl></param>, <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name>boolean</name></type> <name>contains</name><parameter_list>(<param><decl><type><name>T</name></type> <name>left</name></decl></param>, <param><decl><type><name>T</name></type> <name>right</name></decl></param>, <param><decl><type><name>T</name></type> <name>point</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="block">/*
             * We are wrapping around, so the interval is (a,b] where a &gt;= b,
             * then we have 3 cases which hold for any given token k:
             * (1) a &lt; k -- return true
             * (2) k &lt;= b -- return true
             * (3) b &lt; k &lt;= a -- return false
             */</comment>
            <if>if <condition>(<expr><call><name><name>point</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then>
            <else>else
                <return>return <expr><call><name><name>right</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return></else></if>
        }</block></then>
        <else>else
        <block>{
            <comment type="block">/*
             * This is the range (a, b] where a &lt; b.
             */</comment>
            <return>return <expr><call><name><name>point</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> &gt; 0 &amp;&amp; <call><name><name>right</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>point</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>this</name>.<name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// full ring always contains all other ranges</comment>
            <return>return <expr>true</expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>boolean</name></type> <name>thiswraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>thatwraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>that</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>thiswraps</name> == <name>thatwraps</name></expr>)</condition><then>
        <block>{
            <return>return <expr><call><name><name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>)</argument_list></call> &lt;= 0 &amp;&amp; <call><name><name>that</name>.<name>right</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> &lt;= 0</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>thiswraps</name></expr>)</condition><then>
        <block>{
            <comment type="line">// wrapping might contain non-wrapping</comment>
            <comment type="line">// that is contained if both its tokens are in one of our wrap segments</comment>
            <return>return <expr><call><name><name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>)</argument_list></call> &lt;= 0 || <call><name><name>that</name>.<name>right</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> &lt;= 0</expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// (thatwraps)</comment>
            <comment type="line">// non-wrapping cannot contain wrapping</comment>
            <return>return <expr>false</expr>;</return>
        }</block></else></if></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Helps determine if a given point on the DHT ring is contained
     * in the range in question.
     * @param point point in question
     * @return true if the point contains within the range else false.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>contains</name><parameter_list>(<param><decl><type><name>T</name></type> <name>point</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>contains</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>point</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param that range to check for intersection
     * @return true if the given range intersects with this range.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>intersects</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>intersectionWith</name><argument_list>(<argument><expr><name>that</name></expr></argument>)</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>intersects</name><parameter_list>(<param><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// implemented for cleanup compaction membership test, so only Range + Bounds are supported for now</comment>
        <if>if <condition>(<expr><name>that</name> instanceof <name>Range</name></expr>)</condition><then>
            <return>return <expr><call><name>intersects</name><argument_list>(<argument><expr>(<name>Range</name>) <name>that</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><name>that</name> instanceof <name>Bounds</name></expr>)</condition><then>
            <return>return <expr><call><name>intersects</name><argument_list>(<argument><expr>(<name>Bounds</name>) <name>that</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>(<argument><expr>"Intersection is only supported for Bounds and Range objects; found " + <call><name><name>that</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param that range to check for intersection
     * @return true if the given range intersects with this range.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>intersects</name><parameter_list>(<param><decl><type><name><name>Bounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>intersects</name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>that</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> || <call><name>contains</name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangeSet</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name> ...</type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Collections</name>.<name>unmodifiableSet</name></name><argument_list>(<argument><expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangeSet</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param that
     * @return the intersection of the two Ranges.  this can be two disjoint Ranges if one is wrapping and one is not.
     * say you have nodes G and M, with query range (D,T]; the intersection is (M-T] and (D-G].
     * If there is no intersection, an empty list is returned.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionWith</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>that</name>.<name>contains</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name>rangeSet</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <if>if <condition>(<expr><call><name><name>this</name>.<name>contains</name></name><argument_list>(<argument><expr><name>that</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name>rangeSet</name><argument_list>(<argument><expr><name>that</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <decl_stmt><decl><type><name>boolean</name></type> <name>thiswraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>thatwraps</name> <init>= <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>that</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name>thiswraps</name> &amp;&amp; !<name>thatwraps</name></expr>)</condition><then>
        <block>{
            <comment type="line">// neither wraps.  the straightforward case.</comment>
            <if>if <condition>(<expr>!(<call><name><name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name>.<name>right</name></name></expr></argument>)</argument_list></call> &lt; 0 &amp;&amp; <call><name><name>that</name>.<name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> &lt; 0)</expr>)</condition><then>
                <return>return <expr><call><name><name>Collections</name>.<name>emptySet</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
            <return>return <expr><call><name>rangeSet</name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>(<name>T</name>)<call><name><name>ObjectUtils</name>.<name>max</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr>(<name>T</name>)<call><name><name>ObjectUtils</name>.<name>min</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>that</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>thiswraps</name> &amp;&amp; <name>thatwraps</name></expr>)</condition><then>
        <block>{
            <comment type="line">// if the starts are the same, one contains the other, which we have already ruled out.</comment>
            <assert>assert <expr>!<call><name><name>this</name>.<name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</assert>
            <comment type="line">// two wrapping ranges always intersect.</comment>
            <comment type="line">// since we have already determined that neither this nor that contains the other, we have 2 cases,</comment>
            <comment type="line">// and mirror images of those case.</comment>
            <comment type="line">// (1) both of that's (1, 2] endpoints lie in this's (A, B] right segment:</comment>
            <comment type="line">//  ---------B--------A--1----2------&gt;</comment>
            <comment type="line">// (2) only that's start endpoint lies in this's right segment:</comment>
            <comment type="line">//  ---------B----1---A-------2------&gt;</comment>
            <comment type="line">// or, we have the same cases on the left segement, which we can handle by swapping this and that.</comment>
            <return>return <expr><call><name><name>this</name>.<name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>)</argument_list></call> &lt; 0
                   ? <call><name>intersectionBothWrapping</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>that</name></expr></argument>)</argument_list></call>
                   : <call><name>intersectionBothWrapping</name><argument_list>(<argument><expr><name>that</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>thiswraps</name> &amp;&amp; !<name>thatwraps</name></expr>)</condition><then>
            <return>return <expr><call><name>intersectionOneWrapping</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>that</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <assert>assert <expr>(!<name>thiswraps</name> &amp;&amp; <name>thatwraps</name>)</expr>;</assert>
        <return>return <expr><call><name>intersectionOneWrapping</name><argument_list>(<argument><expr><name>that</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionBothWrapping</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>first</name></decl></param>, <param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>that</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersection</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>that</name>.<name>right</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>first</name>.<name>left</name></name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>intersection</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>first</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>that</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>first</name>.<name>partitioner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name><name>intersection</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>that</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>first</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>first</name>.<name>partitioner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>Collections</name>.<name>unmodifiableSet</name></name><argument_list>(<argument><expr><name>intersection</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionOneWrapping</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>wrapping</name></decl></param>, <param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>other</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersection</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>other</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>wrapping</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>intersection</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>other</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>wrapping</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>wrapping</name>.<name>partitioner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <comment type="line">// need the extra compareto here because ranges are asymmetrical; wrapping.left _is not_ contained by the wrapping range</comment>
        <if>if <condition>(<expr><call><name><name>other</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>wrapping</name>.<name>left</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>wrapping</name>.<name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>other</name>.<name>right</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>intersection</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>wrapping</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>other</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>wrapping</name>.<name>partitioner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><call><name><name>Collections</name>.<name>unmodifiableSet</name></name><argument_list>(<argument><expr><name>intersection</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>split</name><parameter_list>(<param><decl><type><name>T</name></type> <name>position</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><call><name>contains</name><argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></call> || <call><name><name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</assert>
        <comment type="line">// Check if the split would have no effect on the range</comment>
        <if>if <condition>(<expr><call><name><name>position</name>.<name>equals</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> || <call><name><name>position</name>.<name>equals</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>lb</name> <init>= <expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>position</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rb</name> <init>= <expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr>new <call><name><name>Pair</name><argument_list>&lt;<argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>, <argument><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>lb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>unwrap</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>T</name></type> <name>minValue</name> <init>= <expr>(<name>T</name>) <call><name><name>partitioner</name>.<name>minValue</name></name><argument_list>(<argument><expr><call><name><name>right</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>isWrapAround</name><argument_list>()</argument_list></call> || <call><name><name>right</name>.<name>equals</name></name><argument_list>(<argument><expr><name>minValue</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>unwrapped</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>unwrapped</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>unwrapped</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>minValue</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>unwrapped</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Tells if the given range is a wrap around.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name>boolean</name></type> <name>isWrapAround</name><parameter_list>(<param><decl><type><name>T</name></type> <name>left</name></decl></param>, <param><decl><type><name>T</name></type> <name>right</name></decl></param>)</parameter_list>
    <block>{
       <return>return <expr><call><name><name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call> &gt;= 0</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>compareTo</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rhs</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block">/*
         * If the range represented by the "this" pointer
         * is a wrap around then it is the smaller one.
         */</comment>
        <if>if <condition>( <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr> )</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>

        <if>if <condition>( <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name><name>rhs</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>rhs</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr> )</condition><then>
            <return>return <expr>1</expr>;</return></then></if>

        <return>return <expr><call><name><name>right</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>rhs</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Subtracts a portion of this range.
     * @param contained The range to subtract from this. It must be totally
     * contained by this range.
     * @return An ArrayList of the Ranges left after subtracting contained
     * from this.
     */</comment>
    <function><type><specifier>private</specifier> <name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subtractContained</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>contained</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>difference</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name><name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>contained</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>difference</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name><name>contained</name>.<name>left</name></name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr>!<call><name><name>right</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>contained</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>difference</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>contained</name>.<name>right</name></name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>difference</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>subtract</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rhs</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>rhs</name>.<name>differenceToFetch</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * Calculate set of the difference ranges of given two ranges
     * (as current (A, B] and rhs is (C, D])
     * which node will need to fetch when moving to a given new token
     *
     * @param rhs range to calculate difference
     * @return set of difference ranges
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>differenceToFetch</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rhs</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>result</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>intersectionSet</name> <init>= <expr><call><name><name>this</name>.<name>intersectionWith</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>intersectionSet</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>result</name> = new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>result</name>.<name>add</name></name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name>Range</name><index>[]</index></type> <name>intersections</name> <init>= <expr>new <name><name>Range</name><index>[<expr><call><name><name>intersectionSet</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>intersectionSet</name>.<name>toArray</name></name><argument_list>(<argument><expr><name>intersections</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>intersections</name>.<name>length</name></name> == 1</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>result</name> = new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>rhs</name>.<name>subtractContained</name></name><argument_list>(<argument><expr><name><name>intersections</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <comment type="line">// intersections.length must be 2</comment>
                <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>first</name> <init>= <expr><name><name>intersections</name><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>second</name> <init>= <expr><name><name>intersections</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>temp</name> <init>= <expr><call><name><name>rhs</name>.<name>subtractContained</name></name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <comment type="line">// Because there are two intersections, subtracting only one of them</comment>
                <comment type="line">// will yield a single Range.</comment>
                <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>single</name> <init>= <expr><call><name><name>temp</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>result</name> = new <call><name><name>HashSet</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>single</name>.<name>subtractContained</name></name><argument_list>(<argument><expr><name>second</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name>boolean</name></type> <name>isInRanges</name><parameter_list>(<param><decl><type><name>T</name></type> <name>token</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name>ranges</name> != null</expr>;</assert>

        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>range</name>.<name>contains</name></name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <return>return <expr>true</expr>;</return>
            }</block></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr>!(<name>o</name> instanceof <name>Range</name>)</expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>
        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>rhs</name> <init>= <expr>(<name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>)<name>o</name></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>rhs</name>.<name>left</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>right</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>rhs</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>"(" + <name>left</name> + "," + <name>right</name> + "]"</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>asList</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>ret</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>ret</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>left</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>ret</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>right</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isWrapAround</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>isWrapAround</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return A copy of the given list of with all ranges unwrapped, sorted by left bound and with overlapping bounds merged.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>normalize</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// unwrap all</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>output</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ranges</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><name>ranges</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>output</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>range</name>.<name>unwrap</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <comment type="line">// sort by left</comment>
        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr>new <class><super><name><name>Comparator</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>b1</name></decl></param>, <param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>b2</name></decl></param>)</parameter_list>
            <block>{
                <return>return <expr><call><name><name>b1</name>.<name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>b2</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></function>
        }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// deoverlap</comment>
        <return>return <expr><call><name>deoverlap</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Given a list of unwrapped ranges sorted by left position, return an
     * equivalent list of ranges but with no overlapping ranges.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <argument_list>&lt;<argument><name>T</name> <extends>extends <name>RingPosition</name></extends></argument>&gt;</argument_list> <name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>deoverlap</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>ranges</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>ranges</name></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>output</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>ranges</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>current</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>T</name></type> <name>min</name> <init>= <expr>(<name>T</name>) <call><name><name>current</name>.<name>partitioner</name>.<name>minValue</name></name><argument_list>(<argument><expr><call><name><name>current</name>.<name>left</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <comment type="line">// If current goes to the end of the ring, we're done</comment>
            <if>if <condition>(<expr><call><name><name>current</name>.<name>right</name>.<name>equals</name></name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <comment type="line">// If one range is the full range, we return only that</comment>
                <if>if <condition>(<expr><call><name><name>current</name>.<name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <return>return <expr><name><name>Collections</name>.</name>&lt;<name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name>&gt;<call><name>singletonList</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

                <expr_stmt><expr><call><name><name>output</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>current</name>.<name>left</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>output</name></expr>;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name></type> <name>next</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// if next left is equal to current right, we do not intersect per se, but replacing (A, B] and (B, C] by (A, C] is</comment>
            <comment type="line">// legit, and since this avoid special casing and will result in more "optimal" ranges, we do the transformation</comment>
            <if>if <condition>(<expr><call><name><name>next</name>.<name>left</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>current</name>.<name>right</name></name></expr></argument>)</argument_list></call> &lt;= 0</expr>)</condition><then>
            <block>{
                <comment type="line">// We do overlap</comment>
                <comment type="line">// (we've handled current.right.equals(min) already)</comment>
                <if>if <condition>(<expr><call><name><name>next</name>.<name>right</name>.<name>equals</name></name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call> || <call><name><name>current</name>.<name>right</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>next</name>.<name>right</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                    <expr_stmt><expr><name>current</name> = new <call><name><name>Range</name><argument_list>&lt;<argument><name>T</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>current</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>next</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>output</name>.<name>add</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>current</name> = <name>next</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>
        <expr_stmt><expr><call><name><name>output</name>.<name>add</name></name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>output</name></expr>;</return>
    }</block></function>


    <comment type="block" format="javadoc">/**
     * Compute a range of keys corresponding to a given range of token.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>makeRowRange</name><parameter_list>(<param><decl><type><name>Token</name></type> <name>left</name></decl></param>, <param><decl><type><name>Token</name></type> <name>right</name></decl></param>, <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr>new <call><name><name>Range</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>left</name>.<name>maxKeyBound</name></name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>right</name>.<name>maxKeyBound</name></name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>toRowBounds</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>(<name>left</name> instanceof <name>Token</name>) ? <call><name>makeRowRange</name><argument_list>(<argument><expr>(<name>Token</name>)<name>left</name></expr></argument>, <argument><expr>(<name>Token</name>)<name>right</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call> : (<name><name>Range</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name>)<name>this</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>toTokenBounds</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>(<name>left</name> instanceof <name>RowPosition</name>) ? new <call><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr>((<name>RowPosition</name>)<name>left</name>).<call><name>getToken</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>((<name>RowPosition</name>)<name>right</name>).<call><name>getToken</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call> : (<name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name>)<name>this</name></expr>;</return>
    }</block></function>
}</block></class>
</unit>
