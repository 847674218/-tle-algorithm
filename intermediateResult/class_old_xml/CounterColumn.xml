<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\db\CounterColumn.java"><comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>net</name>.<name>InetAddress</name></name>;</import>
<import>import <name><name>java</name>.<name>security</name>.<name>MessageDigest</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>TimeoutException</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>Collection</name></name>;</import>

<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>context</name>.<name>CounterContext</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>context</name>.<name>IContext</name>.<name>ContextRelationship</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>AbstractType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>MarshalException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>IColumnSerializer</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>util</name>.<name>DataOutputBuffer</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>Allocator</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>IWriteResponseHandler</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageProxy</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>ConsistencyLevel</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>UnavailableException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name></name>.*;</import>

<comment type="block" format="javadoc">/**
 * A column that represents a partitioned counter.
 */</comment>
<class><specifier>public</specifier> class <name>CounterColumn</name> <super><extends>extends <name>Column</name></extends></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>CounterColumn</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>protected</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>CounterContext</name></type> <name>contextManager</name> <init>= <expr><call><name><name>CounterContext</name>.<name>instance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>long</name></type> <name>timestampOfLastDelete</name></decl>;</decl_stmt>

    <constructor><specifier>public</specifier> <name>CounterColumn</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestamp</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>contextManager</name>.<name>create</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>HeapAllocator</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>CounterColumn</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>, <param><decl><type><name>long</name></type> <name>value</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestamp</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestampOfLastDelete</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>contextManager</name>.<name>create</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>HeapAllocator</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>CounterColumn</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>value</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestamp</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name><name>Long</name>.<name>MIN_VALUE</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <constructor><specifier>public</specifier> <name>CounterColumn</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>value</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestamp</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestampOfLastDelete</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>timestampOfLastDelete</name></name> = <name>timestampOfLastDelete</name></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>CounterColumn</name></type> <name>create</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>value</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestamp</name></decl></param>, <param><decl><type><name>long</name></type> <name>timestampOfLastDelete</name></decl></param>, <param><decl><type><name><name>IColumnSerializer</name>.<name>Flag</name></name></type> <name>flag</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// #elt being negative means we have to clean delta</comment>
        <decl_stmt><decl><type><name>short</name></type> <name>count</name> <init>= <expr><call><name><name>value</name>.<name>getShort</name></name><argument_list>(<argument><expr><call><name><name>value</name>.<name>position</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>flag</name> == <name><name>IColumnSerializer</name>.<name>Flag</name>.<name>FROM_REMOTE</name></name> || (<name>flag</name> == <name><name>IColumnSerializer</name>.<name>Flag</name>.<name>LOCAL</name></name> &amp;&amp; <name>count</name> &lt; 0)</expr>)</condition><then>
            <expr_stmt><expr><name>value</name> = <call><name><name>CounterContext</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>clearAllDelta</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>timestampOfLastDelete</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>timestampOfLastDelete</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>total</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>contextManager</name>.<name>total</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>int</name></type> <name>size</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="block">/*
         * A counter column adds to a Column :
         *  + 8 bytes for timestampOfLastDelete
         */</comment>
        <return>return <expr><call><name><name>super</name>.<name>size</name></name><argument_list>()</argument_list></call> + <name><name>DBConstants</name>.<name>tsSize</name></name></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>IColumn</name></type> <name>diff</name><parameter_list>(<param><decl><type><name>IColumn</name></type> <name>column</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr>(<name>column</name> instanceof <name>CounterColumn</name>) || (<name>column</name> instanceof <name>DeletedColumn</name>) : "Wrong class type: " + <call><name><name>column</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <if>if <condition>(<expr><call><name>timestamp</name><argument_list>()</argument_list></call> &lt; <call><name><name>column</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>column</name></expr>;</return></then></if>

        <comment type="line">// Note that if at that point, column can't be a tombstone. Indeed,</comment>
        <comment type="line">// column is the result of merging us with other nodes results, and</comment>
        <comment type="line">// merging a CounterColumn with a tombstone never return a tombstone</comment>
        <comment type="line">// unless that tombstone timestamp is greater that the CounterColumn</comment>
        <comment type="line">// one.</comment>
        <assert>assert <expr>!(<name>column</name> instanceof <name>DeletedColumn</name>) : "Wrong class type: " + <call><name><name>column</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <if>if <condition>(<expr><call><name>timestampOfLastDelete</name><argument_list>()</argument_list></call> &lt; ((<name>CounterColumn</name>)<name>column</name>).<call><name>timestampOfLastDelete</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>column</name></expr>;</return></then></if>
        <decl_stmt><decl><type><name>ContextRelationship</name></type> <name>rel</name> <init>= <expr><call><name><name>contextManager</name>.<name>diff</name></name><argument_list>(<argument><expr><call><name><name>column</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>ContextRelationship</name>.<name>GREATER_THAN</name></name> == <name>rel</name> || <name><name>ContextRelationship</name>.<name>DISJOINT</name></name> == <name>rel</name></expr>)</condition><then>
            <return>return <expr><name>column</name></expr>;</return></then></if>
        <return>return <expr>null</expr>;</return>
    }</block></function>

    <comment type="block">/*
     * We have to special case digest creation for counter column because
     * we don't want to include the information about which shard of the
     * context is a delta or not, since this information differs from node to
     * node.
     */</comment>
    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>updateDigest</name><parameter_list>(<param><decl><type><name>MessageDigest</name></type> <name>digest</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>digest</name>.<name>update</name></name><argument_list>(<argument><expr><call><name><name>name</name>.<name>duplicate</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// We don't take the deltas into account in a digest</comment>
        <expr_stmt><expr><call><name><name>contextManager</name>.<name>updateDigest</name></name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>DataOutputBuffer</name></type> <name>buffer</name> <init>= <expr>new <call><name>DataOutputBuffer</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>buffer</name>.<name>writeLong</name></name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name>.<name>writeByte</name></name><argument_list>(<argument><expr><call><name>serializationFlags</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>buffer</name>.<name>writeLong</name></name><argument_list>(<argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <expr_stmt><expr><call><name><name>digest</name>.<name>update</name></name><argument_list>(<argument><expr><call><name><name>buffer</name>.<name>getData</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name><name>buffer</name>.<name>getLength</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>IColumn</name></type> <name>reconcile</name><parameter_list>(<param><decl><type><name>IColumn</name></type> <name>column</name></decl></param>, <param><decl><type><name>Allocator</name></type> <name>allocator</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr>(<name>column</name> instanceof <name>CounterColumn</name>) || (<name>column</name> instanceof <name>DeletedColumn</name>) : "Wrong class type: " + <call><name><name>column</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <if>if <condition>(<expr><call><name><name>column</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <comment type="line">// live + tombstone: track last tombstone</comment>
        <block>{
            <if>if <condition>(<expr><call><name>timestamp</name><argument_list>()</argument_list></call> &lt; <call><name><name>column</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <comment type="line">// live &lt; tombstone</comment>
            <block>{
                <return>return <expr><name>column</name></expr>;</return>
            }</block></then></if>
            <comment type="line">// live last delete &gt;= tombstone</comment>
            <if>if <condition>(<expr><call><name>timestampOfLastDelete</name><argument_list>()</argument_list></call> &gt;= <call><name><name>column</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <return>return <expr><name>this</name></expr>;</return>
            }</block></then></if>
            <comment type="line">// live last delete &lt; tombstone</comment>
            <return>return <expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><call><name>name</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>timestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>column</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <comment type="line">// live &lt; live last delete</comment>
        <if>if <condition>(<expr><call><name>timestamp</name><argument_list>()</argument_list></call> &lt; ((<name>CounterColumn</name>)<name>column</name>).<call><name>timestampOfLastDelete</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>column</name></expr>;</return></then></if>
        <comment type="line">// live last delete &gt; live</comment>
        <if>if <condition>(<expr><call><name>timestampOfLastDelete</name><argument_list>()</argument_list></call> &gt; <call><name><name>column</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>this</name></expr>;</return></then></if>
        <comment type="line">// live + live: merge clocks; update value</comment>
        <return>return <expr>new <call><name>CounterColumn</name><argument_list>(
            <argument><expr><call><name>name</name><argument_list>()</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>contextManager</name>.<name>merge</name></name><argument_list>(<argument><expr><call><name>value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>column</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><call><name>timestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>column</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><call><name>timestampOfLastDelete</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>((<name>CounterColumn</name>)<name>column</name>).<call><name>timestampOfLastDelete</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>boolean</name></type> <name>equals</name><parameter_list>(<param><decl><type><name>Object</name></type> <name>o</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// super.equals() returns false if o is not a CounterColumn</comment>
        <return>return <expr><call><name><name>super</name>.<name>equals</name></name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> &amp;&amp; <name>timestampOfLastDelete</name> == ((<name>CounterColumn</name>)<name>o</name>).<name>timestampOfLastDelete</name></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>int</name></type> <name>hashCode</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><call><name><name>super</name>.<name>hashCode</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>result</name> = 31 * <name>result</name> + <call>(<name>int</name>)<argument_list>(<argument><expr><name>timestampOfLastDelete</name> ^ (<name>timestampOfLastDelete</name> &gt;&gt;&gt; 32)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>IColumn</name></type> <name>localCopy</name><parameter_list>(<param><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><call><name><name>cfs</name>.<name>internOrCopy</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>HeapAllocator</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>ByteBufferUtil</name>.<name>clone</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>IColumn</name></type> <name>localCopy</name><parameter_list>(<param><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name></decl></param>, <param><decl><type><name>Allocator</name></type> <name>allocator</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><call><name><name>cfs</name>.<name>internOrCopy</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>allocator</name>.<name>clone</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>String</name></type> <name>getString</name><parameter_list>(<param><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>comparator</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>StringBuilder</name></type> <name>sb</name> <init>= <expr>new <call><name>StringBuilder</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>comparator</name>.<name>getString</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name>isMarkedForDelete</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name><name>contextManager</name>.<name>toString</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"@"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><call><name>timestamp</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr>"!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sb</name>.<name>append</name></name><argument_list>(<argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name><name>sb</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>int</name></type> <name>serializationFlags</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>ColumnSerializer</name>.<name>COUNTER_MASK</name></name></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>void</name></type> <name>validateFields</name><parameter_list>(<param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>MarshalException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>validateName</name><argument_list>(<argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// We cannot use the value validator as for other columns as the CounterColumnType validate a long,</comment>
        <comment type="line">// which is not the internal representation of counters</comment>
        <expr_stmt><expr><call><name><name>contextManager</name>.<name>validateContext</name></name><argument_list>(<argument><expr><call><name>value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Check if a given nodeId is found in this CounterColumn context.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasNodeId</name><parameter_list>(<param><decl><type><name>NodeId</name></type> <name>id</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>contextManager</name>.<name>hasNodeId</name></name><argument_list>(<argument><expr><call><name>value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>CounterColumn</name></type> <name>computeOldShardMerger</name><parameter_list>(<param><decl><type><name>int</name></type> <name>mergeBefore</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>bb</name> <init>= <expr><call><name><name>contextManager</name>.<name>computeOldShardMerger</name></name><argument_list>(<argument><expr><call><name>value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>NodeId</name>.<name>getOldLocalNodeIds</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>mergeBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>bb</name> == null</expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then>
        <else>else
            <return>return <expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><call><name>name</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>timestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>CounterColumn</name></type> <name>removeOldShards</name><parameter_list>(<param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>bb</name> <init>= <expr><call><name><name>contextManager</name>.<name>removeOldShards</name></name><argument_list>(<argument><expr><call><name>value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>bb</name> == <call><name>value</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>this</name></expr>;</return></then>
        <else>else
        <block>{
            <return>return <expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><call><name>name</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>timestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>mergeAndRemoveOldShards</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>, <param><decl><type><name>int</name></type> <name>mergeBefore</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>mergeAndRemoveOldShards</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>, <argument><expr><name>mergeBefore</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * There is two phase to the removal of old shards.
     * First phase: we merge the old shard value to the current shard and
     * 'nulify' the old one. We then send the counter context with the old
     * shard nulified to all other replica.
     * Second phase: once an old shard has been nulified for longer than
     * gc_grace (to be sure all other replica had been aware of the merge), we
     * simply remove that old shard from the context (it's value is 0).
     * This method does both phases.
     * (Note that the sendToOtherReplica flag is here only to facilitate
     * testing. It should be true in real code so use the method above
     * preferably)
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>mergeAndRemoveOldShards</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>, <param><decl><type><name>int</name></type> <name>mergeBefore</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>sendToOtherReplica</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>remoteMerger</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name><name>cf</name>.<name>isSuper</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <for>for (<init><decl><type><name>IColumn</name></type> <name>c</name> <range>: <expr><name>cf</name></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr>!(<name>c</name> instanceof <name>CounterColumn</name>)</expr>)</condition><then>
                    <continue>continue;</continue></then></if>
                <decl_stmt><decl><type><name>CounterColumn</name></type> <name>cc</name> <init>= <expr>(<name>CounterColumn</name>) <name>c</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CounterColumn</name></type> <name>shardMerger</name> <init>= <expr><call><name><name>cc</name>.<name>computeOldShardMerger</name></name><argument_list>(<argument><expr><name>mergeBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>CounterColumn</name></type> <name>merged</name> <init>= <expr><name>cc</name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>shardMerger</name> != null</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>merged</name> = (<name>CounterColumn</name>) <call><name><name>cc</name>.<name>reconcile</name></name><argument_list>(<argument><expr><name>shardMerger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>remoteMerger</name> == null</expr>)</condition><then>
                        <expr_stmt><expr><name>remoteMerger</name> = <call><name><name>cf</name>.<name>cloneMeShallow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><call><name><name>remoteMerger</name>.<name>addColumn</name></name><argument_list>(<argument><expr><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <decl_stmt><decl><type><name>CounterColumn</name></type> <name>cleaned</name> <init>= <expr><call><name><name>merged</name>.<name>removeOldShards</name></name><argument_list>(<argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>cleaned</name> != <name>cc</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>cf</name>.<name>replace</name></name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>cleaned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then>
        <else>else
        <block>{
            <for>for (<init><decl><type><name>IColumn</name></type> <name>col</name> <range>: <expr><name>cf</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>SuperColumn</name></type> <name>c</name> <init>= <expr>(<name>SuperColumn</name>)<name>col</name></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>IColumn</name></type> <name>subColumn</name> <range>: <expr><call><name><name>c</name>.<name>getSubColumns</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr>!(<name>subColumn</name> instanceof <name>CounterColumn</name>)</expr>)</condition><then>
                        <continue>continue;</continue></then></if>
                    <decl_stmt><decl><type><name>CounterColumn</name></type> <name>cc</name> <init>= <expr>(<name>CounterColumn</name>) <name>subColumn</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CounterColumn</name></type> <name>shardMerger</name> <init>= <expr><call><name><name>cc</name>.<name>computeOldShardMerger</name></name><argument_list>(<argument><expr><name>mergeBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>CounterColumn</name></type> <name>merged</name> <init>= <expr><name>cc</name></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>shardMerger</name> != null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>merged</name> = (<name>CounterColumn</name>) <call><name><name>cc</name>.<name>reconcile</name></name><argument_list>(<argument><expr><name>shardMerger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>remoteMerger</name> == null</expr>)</condition><then>
                            <expr_stmt><expr><name>remoteMerger</name> = <call><name><name>cf</name>.<name>cloneMeShallow</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                        <expr_stmt><expr><call><name><name>remoteMerger</name>.<name>addColumn</name></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <decl_stmt><decl><type><name>CounterColumn</name></type> <name>cleaned</name> <init>= <expr><call><name><name>merged</name>.<name>removeOldShards</name></name><argument_list>(<argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>cleaned</name> != <name>subColumn</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>c</name>.<name>replace</name></name><argument_list>(<argument><expr><name>subColumn</name></expr></argument>, <argument><expr><name>cleaned</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></for>
            }</block></for>
        }</block></else></if>

        <if>if <condition>(<expr><name>remoteMerger</name> != null &amp;&amp; <name>sendToOtherReplica</name></expr>)</condition><then>
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><call><name>sendToOtherReplica</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>remoteMerger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr>"Error while sending shard merger mutation to remote endpoints"</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
        }</block></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>IColumn</name></type> <name>markDeltaToBeCleared</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>new <call><name>CounterColumn</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>contextManager</name>.<name>markDeltaToBeCleared</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>timestampOfLastDelete</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>sendToOtherReplica</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>TimeoutException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>RowMutation</name></type> <name>rm</name> <init>= <expr>new <call><name>RowMutation</name><argument_list>(<argument><expr><call><name><name>cf</name>.<name>metadata</name></name><argument_list>()</argument_list></call>.<name>ksName</name></expr></argument>, <argument><expr><name><name>key</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>rm</name>.<name>add</name></name><argument_list>(<argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>InetAddress</name></type> <name>local</name> <init>= <expr><call><name><name>FBUtilities</name>.<name>getBroadcastAddress</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>String</name></type> <name>localDataCenter</name> <init>= <expr><call><name><name>DatabaseDescriptor</name>.<name>getEndpointSnitch</name></name><argument_list>()</argument_list></call>.<call><name>getDatacenter</name><argument_list>(<argument><expr><name>local</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>performWrite</name></name><argument_list>(<argument><expr><name>rm</name></expr></argument>, <argument><expr><name><name>ConsistencyLevel</name>.<name>ANY</name></name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr>new <class><super><name><name>StorageProxy</name>.<name>WritePerformer</name></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>IMutation</name></type> <name>mutation</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>InetAddress</name></argument>&gt;</argument_list></name></type> <name>targets</name></decl></param>, <param><decl><type><name>IWriteResponseHandler</name></type> <name>responseHandler</name></decl></param>, <param><decl><type><name>String</name></type> <name>localDataCenter</name></decl></param>, <param><decl><type><name>ConsistencyLevel</name></type> <name>consistency_level</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>TimeoutException</name></expr></argument></throws>
            <block>{
                <comment type="line">// We should only send to the remote replica, not the local one</comment>
                <expr_stmt><expr><call><name><name>targets</name>.<name>remove</name></name><argument_list>(<argument><expr><name>local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// Fake local response to be a good lad but we won't wait on the responseHandler</comment>
                <expr_stmt><expr><call><name><name>responseHandler</name>.<name>response</name></name><argument_list>(<argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>StorageProxy</name>.<name>sendToHintedEndpoints</name></name><argument_list>(<argument><expr>(<name>RowMutation</name>) <name>mutation</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>responseHandler</name></expr></argument>, <argument><expr><name>localDataCenter</name></expr></argument>, <argument><expr><name>consistency_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></function>
        }</block></class></expr></argument>, <argument><expr>null</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// we don't wait for answers</comment>
    }</block></function>
}</block></class>
</unit>
