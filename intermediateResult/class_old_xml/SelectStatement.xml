<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\cql3\statements\SelectStatement.java"><comment type="block">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>
<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cql3</name>.<name>statements</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>TimeoutException</name></name>;</import>

<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>collect</name>.<name>AbstractIterator</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>auth</name>.<name>Permission</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cql3</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>context</name>.<name>CounterContext</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>QueryPath</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>AbstractType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>CompositeType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>Int32Type</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>LongType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>ReversedType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>TypeParser</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>ClientState</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageProxy</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>Column</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>ConsistencyLevel</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>CqlMetadata</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>CqlResult</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>CqlResultType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>CqlRow</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>IndexExpression</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>IndexOperator</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>InvalidRequestException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>RequestType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>SlicePredicate</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>SliceRange</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>ThriftValidation</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>TimedOutException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>UnavailableException</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>ByteBufferUtil</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>Pair</name></name>;</import>

<comment type="block" format="javadoc">/**
 * Encapsulates a completely parsed SELECT query, including the target
 * column family, expression, result count, and ordering clause.
 *
 */</comment>
<class><specifier>public</specifier> class <name>SelectStatement</name> <super><implements>implements <name>CQLStatement</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>SelectStatement</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <specifier>static</specifier> <name>ByteBuffer</name></type> <name>countColumn</name> <init>= <expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr>"count"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>boundTerms</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>CFDefinition</name></type> <name>cfDef</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Parameters</name></type> <name>parameters</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selectedNames</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// empty =&gt; wildcard</comment>

    <decl_stmt><decl><type><specifier>private</specifier> <name>Restriction</name></type> <name>keyRestriction</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Restriction</name><index>[]</index></type> <name>columnRestrictions</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name></type> <name>metadataRestrictions</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Restriction</name></type> <name>sliceRestriction</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>boolean</name></type> <name>isReversed</name></decl>;</decl_stmt>

    <enum><specifier>private</specifier> <specifier>static</specifier> enum <name>Bound</name>
    <block>{
        <decl><name>START</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></decl>, <decl><name>END</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></decl>;

        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>int</name></type> <name>idx</name></decl>;</decl_stmt>

        <constructor><name>Bound</name><parameter_list>(<param><decl><type><name>int</name></type> <name>idx</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>idx</name></name> = <name>idx</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <specifier>static</specifier> <name>Bound</name></type> <name>reverse</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><name>b</name> == <name>START</name> ? <name>END</name> : <name>START</name></expr>;</return>
        }</block></function>
    }</block></enum><empty_stmt>;</empty_stmt>

    <constructor><specifier>public</specifier> <name>SelectStatement</name><parameter_list>(<param><decl><type><name>CFDefinition</name></type> <name>cfDef</name></decl></param>, <param><decl><type><name>int</name></type> <name>boundTerms</name></decl></param>, <param><decl><type><name>Parameters</name></type> <name>parameters</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name><name>this</name>.<name>cfDef</name></name> = <name>cfDef</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>boundTerms</name></name> = <name>boundTerms</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>columnRestrictions</name></name> = new <name><name>Restriction</name><index>[<expr><call><name><name>cfDef</name>.<name>columns</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>parameters</name></name> = <name>parameters</name></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getBoundsTerms</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>boundTerms</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>checkAccess</name><parameter_list>(<param><decl><type><name>ClientState</name></type> <name>state</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>state</name>.<name>hasColumnFamilyAccess</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Permission</name>.<name>READ</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>validate</name><parameter_list>(<param><decl><type><name>ClientState</name></type> <name>state</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <comment type="line">// Nothing to do, all validation has been done by RawStatement.prepare()</comment>
    }</block></function>

    <function><type><specifier>public</specifier> <name>CqlResult</name></type> <name>execute</name><parameter_list>(<param><decl><type><name>ClientState</name></type> <name>state</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument>, <argument><expr><name>UnavailableException</name></expr></argument>, <argument><expr><name>TimedOutException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>isKeyRange</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>rows</name> = <call><name>multiRangeSlice</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name>rows</name> = <call><name>getSlice</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <decl_stmt><decl><type><name>CqlResult</name></type> <name>result</name> <init>= <expr>new <call><name>CqlResult</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>type</name></name> = <name><name>CqlResultType</name>.<name>ROWS</name></name></expr>;</expr_stmt>

        <comment type="line">// Even for count, we need to process the result as it'll group some column together in sparse column families</comment>
        <decl_stmt><decl><type><name>CqlMetadata</name></type> <name>schema</name> <init>= <expr><call><name>createSchema</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name></type> <name>cqlRows</name> <init>= <expr><call><name>process</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// count resultset is a single column named "count"</comment>
        <if>if <condition>(<expr><name><name>parameters</name>.<name>isCount</name></name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name><name>result</name>.<name>schema</name></name> = new <call><name>CqlMetadata</name><argument_list>(<argument><expr><name><name>Collections</name>.</name>&lt;<name>ByteBuffer</name></expr></argument>, <argument><expr><name>String</name>&gt;<call><name>emptyMap</name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr><name><name>Collections</name>.</name>&lt;<name>ByteBuffer</name></expr></argument>, <argument><expr><name>String</name>&gt;<call><name>emptyMap</name><argument_list>()</argument_list></call></expr></argument>,
                                            <argument><expr>"AsciiType"</expr></argument>,
                                            <argument><expr>"LongType"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Column</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr>new <call><name>Column</name><argument_list>(<argument><expr><name>countColumn</name></expr></argument>)</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr>(<name>long</name>) <call><name><name>cqlRows</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>result</name>.<name>rows</name></name> = <call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr>new <call><name>CqlRow</name><argument_list>(<argument><expr><name>countColumn</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// otherwise create resultset from query results</comment>
            <expr_stmt><expr><name><name>result</name>.<name>schema</name></name> = <name>schema</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>.<name>rows</name></name> = <name>cqlRows</name></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name></type> <name>process</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr>!<name><name>parameters</name>.<name>isCount</name></name></expr>;</assert> <comment type="line">// not yet needed</comment>
        <return>return <expr><call><name>process</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><call><name>createSchema</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>ByteBuffer</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>String</name></type> <name>getShortTypeName</name><parameter_list>(<param><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>type</name> instanceof <name>ReversedType</name></expr>)</condition><then>
            <expr_stmt><expr><name>type</name> = ((<name>ReversedType</name>)<name>type</name>).<name>baseType</name></expr>;</expr_stmt></then></if>
        <return>return <expr><call><name><name>TypeParser</name>.<name>getShortName</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>CqlMetadata</name></type> <name>createSchema</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>new <call><name>CqlMetadata</name><argument_list>(<argument><expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><call><name>getShortTypeName</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>getShortTypeName</name><argument_list>(<argument><expr><call><name><name>cfDef</name>.<name>cfm</name>.<name>getDefaultValidator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>keyspace</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>cfDef</name>.<name>cfm</name>.<name>ksName</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>columnFamily</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>cfDef</name>.<name>cfm</name>.<name>cfName</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>getSlice</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument>, <argument><expr><name>TimedOutException</name></expr></argument>, <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>QueryPath</name></type> <name>queryPath</name> <init>= <expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr><call><name>getKeys</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name></type> <name>commands</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ReadCommand</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>keys</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// ...a range (slice) of column names</comment>
        <if>if <condition>(<expr><call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>start</name> <init>= <expr><call><name>getRequestedBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>finish</name> <init>= <expr><call><name>getRequestedBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// Note that we use the total limit for every key. This is</comment>
            <comment type="line">// potentially inefficient, but then again, IN + LIMIT is not a</comment>
            <comment type="line">// very sensible choice</comment>
            <for>for (<init><decl><type><name>ByteBuffer</name></type> <name>key</name> <range>: <expr><name>keys</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateSliceRange</name></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>finish</name></expr></argument>, <argument><expr><name>isReversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>commands</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>SliceFromReadCommand</name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>,
                                                      <argument><expr><name>key</name></expr></argument>,
                                                      <argument><expr><name>queryPath</name></expr></argument>,
                                                      <argument><expr><name>start</name></expr></argument>,
                                                      <argument><expr><name>finish</name></expr></argument>,
                                                      <argument><expr><name>isReversed</name></expr></argument>,
                                                      <argument><expr><call><name>getLimit</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then>
        <comment type="line">// ...of a list of column names</comment>
        <else>else
        <block>{
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>columnNames</name> <init>= <expr><call><name>getRequestedColumns</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateColumnNames</name></name><argument_list>(<argument><expr><name>columnNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <for>for (<init><decl><type><name>ByteBuffer</name></type> <name>key</name><range>: <expr><name>keys</name></expr></range></decl></init>)
            <block>{
                <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateKey</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>commands</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>SliceByNamesReadCommand</name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>queryPath</name></expr></argument>, <argument><expr><name>columnNames</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>

        <try>try
        <block>{
            <return>return <expr><call><name><name>StorageProxy</name>.<name>read</name></name><argument_list>(<argument><expr><name>commands</name></expr></argument>, <argument><expr><name><name>parameters</name>.<name>consistencyLevel</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>TimeoutException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>TimedOutException</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>multiRangeSlice</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument>, <argument><expr><name>TimedOutException</name></expr></argument>, <argument><expr><name>UnavailableException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl>;</decl_stmt>

        <comment type="line">// XXX: Our use of Thrift structs internally makes me Sad. :(</comment>
        <decl_stmt><decl><type><name>SlicePredicate</name></type> <name>thriftSlicePredicate</name> <init>= <expr><call><name>makeSlicePredicate</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>QueryProcessor</name>.<name>validateSlicePredicate</name></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name></name></expr></argument>, <argument><expr><name>thriftSlicePredicate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>expressions</name> <init>= <expr><call><name>getIndexExpressions</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{
            <expr_stmt><expr><name>rows</name> = <call><name><name>StorageProxy</name>.<name>getRangeSlice</name></name><argument_list>(<argument><expr>new <call><name>RangeSliceCommand</name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>,
                                                                    <argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>,
                                                                    <argument><expr>null</expr></argument>,
                                                                    <argument><expr><name>thriftSlicePredicate</name></expr></argument>,
                                                                    <argument><expr><call><name>getKeyBounds</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>,
                                                                    <argument><expr><name>expressions</name></expr></argument>,
                                                                    <argument><expr><call><name>getLimit</name><argument_list>()</argument_list></call></expr></argument>,
                                                                    <argument><expr>true</expr></argument>, <comment type="line">// limit by columns, not keys</comment>
                                                                    <argument><expr>false</expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name><name>parameters</name>.<name>consistencyLevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>TimeoutException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>TimedOutException</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <return>return <expr><name>rows</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>getKeyBounds</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>IPartitioner</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>p</name> <init>= <expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>bounds</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>keyRestriction</name> != null &amp;&amp; <name><name>keyRestriction</name>.<name>onToken</name></name></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>Token</name></type> <name>startToken</name> <init>= <expr><call><name>getTokenBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Token</name></type> <name>endToken</name> <init>= <expr><call><name>getTokenBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>RowPosition</name></type> <name>start</name> <init>= <expr><call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> ? <call><name><name>startToken</name>.<name>minKeyBound</name></name><argument_list>()</argument_list></call> : <call><name><name>startToken</name>.<name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RowPosition</name></type> <name>end</name> <init>= <expr><call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call> ? <call><name><name>endToken</name>.<name>maxKeyBound</name></name><argument_list>()</argument_list></call> : <call><name><name>endToken</name>.<name>minKeyBound</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>bounds</name> = new <call><name><name>Range</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>startKeyBytes</name> <init>= <expr><call><name>getKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>finishKeyBytes</name> <init>= <expr><call><name>getKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>RowPosition</name></type> <name>startKey</name> <init>= <expr><call><name><name>RowPosition</name>.<name>forKey</name></name><argument_list>(<argument><expr><name>startKeyBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RowPosition</name></type> <name>finishKey</name> <init>= <expr><call><name><name>RowPosition</name>.<name>forKey</name></name><argument_list>(<argument><expr><name>finishKeyBytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>startKey</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>finishKey</name></expr></argument>)</argument_list></call> &gt; 0 &amp;&amp; !<call><name><name>finishKey</name>.<name>isMinimum</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr><name>p</name> instanceof <name>RandomPartitioner</name></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Start key sorts after end key. This is not allowed; you probably should not specify end key at all, under RandomPartitioner"</expr></argument>)</argument_list></call></expr>;</throw></then>
                <else>else
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Start key must sort before (or equal to) finish key in your partitioner!"</expr></argument>)</argument_list></call></expr>;</throw></else></if>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>bounds</name> = <call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>
                    ? new <call><name><name>Bounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call>
                    : new <call><name><name>IncludingExcludingBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>bounds</name> = <call><name>includeKeyBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>
                    ? new <call><name><name>Range</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call>
                    : new <call><name><name>ExcludingBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>startKey</name></expr></argument>, <argument><expr><name>finishKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
        <return>return <expr><name>bounds</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>SlicePredicate</name></type> <name>makeSlicePredicate</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>SlicePredicate</name></type> <name>thriftSlicePredicate</name> <init>= <expr>new <call><name>SlicePredicate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>SliceRange</name></type> <name>sliceRange</name> <init>= <expr>new <call><name>SliceRange</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>sliceRange</name>.<name>start</name></name> = <call><name>getRequestedBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sliceRange</name>.<name>finish</name></name> = <call><name>getRequestedBound</name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sliceRange</name>.<name>reversed</name></name> = <name>isReversed</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sliceRange</name>.<name>count</name></name> = -1</expr>;</expr_stmt> <comment type="line">// We use this for range slices, where the count is ignored in favor of the global column count</comment>
            <expr_stmt><expr><name><name>thriftSlicePredicate</name>.<name>slice_range</name></name> = <name>sliceRange</name></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name><name>thriftSlicePredicate</name>.<name>column_names</name></name> = <call><name>getRequestedColumns</name><argument_list>(<argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>thriftSlicePredicate</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>int</name></type> <name>getLimit</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// Internally, we don't support exclusive bounds for slices. Instead,</comment>
        <comment type="line">// we query one more element if necessary and exclude</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>limit</name> <init>= <expr><name>sliceRestriction</name> != null &amp;&amp; !<call><name><name>sliceRestriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> ? <name><name>parameters</name>.<name>limit</name></name> + 1 : <name><name>parameters</name>.<name>limit</name></name></expr></init></decl>;</decl_stmt>
        <comment type="line">// For sparse, we'll end up merging all defined colums into the same CqlRow. Thus we should query up</comment>
        <comment type="line">// to 'defined columns' * 'asked limit' to be sure to have enough columns. We'll trim after query if</comment>
        <comment type="line">// this end being too much.</comment>
        <return>return <expr><name><name>cfDef</name>.<name>isCompact</name></name> ? <name>limit</name> : <call><name><name>cfDef</name>.<name>metadata</name>.<name>size</name></name><argument_list>()</argument_list></call> * <name>limit</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isKeyRange</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// If indexed columns or a token range, they always use getRangeSlices</comment>
        <if>if <condition>(<expr>!<call><name><name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>

        <return>return <expr><name>keyRestriction</name> == null || !<call><name><name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> || <name><name>keyRestriction</name>.<name>onToken</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>getKeys</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr><name>keyRestriction</name> != null &amp;&amp; <call><name><name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>keys</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>keyRestriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Term</name></type> <name>t</name> <range>: <expr><name><name>keyRestriction</name>.<name>eqValues</name></name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>keys</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>t</name>.<name>getByteBuffer</name></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>key</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>keys</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>getKeyBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name>keyRestriction</name> == null</expr>)</condition><then>
        <block>{
            <return>return <expr><name><name>ByteBufferUtil</name>.<name>EMPTY_BYTE_BUFFER</name></name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name><name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <assert>assert <expr><call><name><name>keyRestriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>;</assert>
            <return>return <expr><call><name><name>keyRestriction</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>.<call><name>getByteBuffer</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>key</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name>Term</name></type> <name>bound</name> <init>= <expr><call><name><name>keyRestriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>bound</name> == null ? <name><name>ByteBufferUtil</name>.<name>EMPTY_BYTE_BUFFER</name></name> : <call><name><name>bound</name>.<name>getByteBuffer</name></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>key</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Token</name></type> <name>getTokenBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>, <param><decl><type><name><name>IPartitioner</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>p</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr><name>keyRestriction</name> != null</expr>;</assert>
        <if>if <condition>(<expr><call><name><name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <assert>assert <expr><call><name><name>keyRestriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>;</assert>
            <return>return <expr><call><name><name>keyRestriction</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>.<call><name>getAsToken</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>key</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name>Term</name></type> <name>bound</name> <init>= <expr><call><name><name>keyRestriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <return>return <expr><name>bound</name> == null ? <call><name><name>p</name>.<name>getMinimumToken</name></name><argument_list>()</argument_list></call> : <call><name><name>bound</name>.<name>getAsToken</name></name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>key</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>includeKeyBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>keyRestriction</name> == null || <call><name><name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then>
        <else>else
            <return>return <expr><call><name><name>keyRestriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isColumnRange</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// Static CF never entails a column slice</comment>
        <if>if <condition>(<expr>!<name><name>cfDef</name>.<name>isCompact</name></name> &amp;&amp; !<name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
            <return>return <expr>false</expr>;</return></then></if>

        <comment type="line">// Otherwise, it is a range query if it has at least one the column alias</comment>
        <comment type="line">// for which no relation is defined or is not EQ.</comment>
        <for>for (<init><decl><type><name>Restriction</name></type> <name>r</name> <range>: <expr><name>columnRestrictions</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><name>r</name> == null || !<call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isWildcard</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>selectedNames</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>getRequestedColumns</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr>!<call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>cfDef</name>.<name>getColumnNameBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Restriction</name></type> <name>r</name> <range>: <expr><name>columnRestrictions</name></expr></range></decl></init>)
        <block>{
            <assert>assert <expr><name>r</name> != null &amp;&amp; <call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <if>if <condition>(<expr><call><name><name>r</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
            <block>{
                <comment type="line">// We have a IN. We only support this for the last column, so just create all columns and return.</comment>
                <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>r</name>.<name>eqValues</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{
                    <decl_stmt><decl><type><name>Term</name></type> <name>v</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>b</name> <init>= <expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call> : <name>builder</name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>cname</name> <init>= <expr><call><name><name>b</name>.<name>add</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>columns</name>.<name>add</name></name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></while>
                <return>return <expr><name>columns</name></expr>;</return>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <if>if <condition>(<expr><name><name>cfDef</name>.<name>isCompact</name></name></expr>)</condition><then>
        <block>{
            <return>return <expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><call><name><name>builder</name>.<name>build</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// Adds all columns (even if the user selected a few columns, we</comment>
            <comment type="line">// need to query all columns to know if the row exists or not).</comment>
            <comment type="line">// Note that when we allow IS NOT NULL in queries and if all</comment>
            <comment type="line">// selected name are request 'not null', we will allow to only</comment>
            <comment type="line">// query those.</comment>
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>columns</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>cfDef</name>.<name>columns</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>cfDef</name>.<name>metadata</name>.<name>keySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <decl_stmt><decl><type><name>ColumnIdentifier</name></type> <name>name</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>b</name> <init>= <expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call> : <name>builder</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>cname</name> <init>= <expr><call><name><name>b</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>columns</name>.<name>add</name></name><argument_list>(<argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <return>return <expr><name>columns</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>getRequestedBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>bound</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr><call><name>isColumnRange</name><argument_list>()</argument_list></call></expr>;</assert>

        <comment type="line">// The end-of-component of composite doesn't depend on whether the</comment>
        <comment type="line">// component type is reversed or not (i.e. the ReversedType is applied</comment>
        <comment type="line">// to the component comparator but not to the end-of-component itself),</comment>
        <comment type="line">// it only depends on whether the slice is reversed</comment>
        <decl_stmt><decl><type><name>Bound</name></type> <name>eocBound</name> <init>= <expr><name>isReversed</name> ? <call><name><name>Bound</name>.<name>reverse</name></name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call> : <name>bound</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>cfDef</name>.<name>getColumnNameBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <range>: <expr><call><name><name>cfDef</name>.<name>columns</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <comment type="line">// In a restriction, we always have Bound.START &lt; Bound.END for the "base" comparator.</comment>
            <comment type="line">// So if we're doing a reverse slice, we must inverse the bounds when giving them as start and end of the slice filter.</comment>
            <comment type="line">// But if the actual comparator itself is reversed, we must inversed the bounds too.</comment>
            <decl_stmt><decl><type><name>Bound</name></type> <name>b</name> <init>= <expr><name>isReversed</name> == <call><name>isReversedType</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> ? <name>bound</name> : <call><name><name>Bound</name>.<name>reverse</name></name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Restriction</name></type> <name>r</name> <init>= <expr><name><name>columnRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>r</name> == null || (!<call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>r</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> == null)</expr>)</condition><then>
            <block>{
                <comment type="line">// There wasn't any non EQ relation on that key, we select all records having the preceding component as prefix.</comment>
                <comment type="line">// For composites, if there was preceding component and we're computing the end, we must change the last component</comment>
                <comment type="line">// End-Of-Component, otherwise we would be selecting only one record.</comment>
                <if>if <condition>(<expr><call><name><name>builder</name>.<name>componentCount</name></name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp; <name>eocBound</name> == <name><name>Bound</name>.<name>END</name></name></expr>)</condition><then>
                    <return>return <expr><call><name><name>builder</name>.<name>buildAsEndOfRange</name></name><argument_list>()</argument_list></call></expr>;</return></then>
                <else>else
                    <return>return <expr><call><name><name>builder</name>.<name>build</name></name><argument_list>()</argument_list></call></expr>;</return></else></if>
            }</block></then></if>

            <if>if <condition>(<expr><call><name><name>r</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <assert>assert <expr><call><name><name>r</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>;</assert>
                <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>r</name>.<name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><call><name><name>r</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <assert>assert <expr><name>t</name> != null</expr>;</assert>
                <return>return <expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><call><name><name>r</name>.<name>getRelation</name></name><argument_list>(<argument><expr><name>eocBound</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></for>
        <comment type="line">// Means no relation at all or everything was an equal</comment>
        <return>return <expr><call><name><name>builder</name>.<name>build</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>getIndexExpressions</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><call><name><name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name><name>Collections</name>.</name>&lt;<name>IndexExpression</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>expressions</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>metadataRestrictions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <for>for (<init><decl><type><name>Term</name></type> <name>t</name> <range>: <expr><name><name>restriction</name>.<name>eqValues</name></name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>value</name> <init>= <expr><call><name><name>t</name>.<name>getByteBuffer</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>expressions</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>IndexExpression</name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>, <argument><expr><name><name>IndexOperator</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></then>
            <else>else
            <block>{
                <for>for (<init><decl><type><name>Bound</name></type> <name>b</name> <range>: <expr><call><name><name>Bound</name>.<name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>restriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> != null</expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>value</name> <init>= <expr><call><name><name>restriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>.<call><name>getByteBuffer</name><argument_list>(<argument><expr><name><name>name</name>.<name>type</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>expressions</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>IndexExpression</name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>, <argument><expr><call><name><name>restriction</name>.<name>getIndexOperator</name></name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></else></if>
        }</block></for>
        <return>return <expr><name>expressions</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getExpandedSelection</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>selectedNames</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <range>: <expr><name>cfDef</name></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>selection</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>Pair</name>.</name>&lt;<name><name>CFDefinition</name>.<name>Name</name></name></expr></argument>, <argument><expr><name>Selector</name>&gt;<call><name>create</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>name</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
            <return>return <expr><name>selection</name></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <return>return <expr><name>selectedNames</name></expr>;</return>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>value</name><parameter_list>(<param><decl><type><name>IColumn</name></type> <name>c</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr>(<name>c</name> instanceof <name>CounterColumn</name>)
             ? <call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><call><name><name>CounterContext</name>.<name>instance</name></name><argument_list>()</argument_list></call>.<call><name>total</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
             : <call><name><name>c</name>.<name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Column</name></type> <name>makeReturnColumn</name><parameter_list>(<param><decl><type><name>Selector</name></type> <name>s</name></decl></param>, <param><decl><type><name>IColumn</name></type> <name>c</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Column</name></type> <name>cqlCol</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>s</name>.<name>hasFunction</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>cqlCol</name> = new <call><name>Column</name><argument_list>(<argument><expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><call><name><name>s</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>c</name> == null || <call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>cqlCol</name></expr>;</return></then></if>

            <switch>switch <condition>(<expr><call><name><name>s</name>.<name>function</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <case>case <expr><name>WRITE_TIME</name></expr>:
                    <expr_stmt><expr><call><name><name>cqlCol</name>.<name>setValue</name></name><argument_list>(<argument><expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>TTL</name></expr>:
                    <if>if <condition>(<expr><name>c</name> instanceof <name>ExpiringColumn</name></expr>)</condition><then>
                    <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>ttl</name> <init>= <expr>((<name>ExpiringColumn</name>)<name>c</name>).<call><name>getLocalDeletionTime</name><argument_list>()</argument_list></call> - <call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <expr_stmt><expr><call><name><name>cqlCol</name>.<name>setValue</name></name><argument_list>(<argument><expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><name>ttl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <break>break;</break>
            </case>}</block></switch>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name>cqlCol</name> = new <call><name>Column</name><argument_list>(<argument><expr><call><name><name>s</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>c</name> == null || <call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>cqlCol</name></expr>;</return></then></if>
            <expr_stmt><expr><call><name><name>cqlCol</name>.<name>setValue</name></name><argument_list>(<argument><expr><call><name>value</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<call><name>setTimestamp</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><name>cqlCol</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>addToSchema</name><parameter_list>(<param><decl><type><name>CqlMetadata</name></type> <name>schema</name></decl></param>, <param><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>p</name>.<name>right</name>.<name>hasFunction</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>nameAsRequested</name> <init>= <expr><call><name><name>ByteBufferUtil</name>.<name>bytes</name></name><argument_list>(<argument><expr><call><name><name>p</name>.<name>right</name>.<name>toString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>schema</name>.<name>name_types</name>.<name>put</name></name><argument_list>(<argument><expr><name>nameAsRequested</name></expr></argument>, <argument><expr><call><name>getShortTypeName</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>definitionType</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <switch>switch <condition>(<expr><call><name><name>p</name>.<name>right</name>.<name>function</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <case>case <expr><name>WRITE_TIME</name></expr>:
                    <expr_stmt><expr><call><name><name>schema</name>.<name>value_types</name>.<name>put</name></name><argument_list>(<argument><expr><name>nameAsRequested</name></expr></argument>, <argument><expr><call><name>getShortTypeName</name><argument_list>(<argument><expr><name><name>LongType</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>TTL</name></expr>:
                    <expr_stmt><expr><call><name><name>schema</name>.<name>value_types</name>.<name>put</name></name><argument_list>(<argument><expr><name>nameAsRequested</name></expr></argument>, <argument><expr><call><name>getShortTypeName</name><argument_list>(<argument><expr><name><name>Int32Type</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </case>}</block></switch>
        }</block></then>
        <else>else
        <block>{
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>nameAsRequested</name> <init>= <expr><call><name><name>p</name>.<name>right</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>schema</name>.<name>name_types</name>.<name>put</name></name><argument_list>(<argument><expr><name>nameAsRequested</name></expr></argument>, <argument><expr><call><name>getShortTypeName</name><argument_list>(<argument><expr><call><name><name>cfDef</name>.<name>getNameComparatorForResultSet</name></name><argument_list>(<argument><expr><name><name>p</name>.<name>left</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>schema</name>.<name>value_types</name>.<name>put</name></name><argument_list>(<argument><expr><name>nameAsRequested</name></expr></argument>, <argument><expr><call><name>getShortTypeName</name><argument_list>(<argument><expr><name><name>p</name>.<name>left</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>columnsInOrder</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <comment type="line">// If the restriction for the last column alias is an IN, respect</comment>
        <comment type="line">// requested order</comment>
        <decl_stmt><decl><type><name>Restriction</name></type> <name>last</name> <init>= <expr><name><name>columnRestrictions</name><index>[<expr><name><name>columnRestrictions</name>.<name>length</name></name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>last</name> == null || !<call><name><name>last</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>cf</name>.<name>getSortedColumns</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>builder</name> <init>= <expr><call><name><name>cfDef</name>.<name>getColumnNameBuilder</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>columnRestrictions</name>.<name>length</name></name> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <expr_stmt><expr><call><name><name>builder</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>columnRestrictions</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name><name>eqValues</name>.<name>get</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>requested</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>last</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>last</name>.<name>eqValues</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>Term</name></type> <name>t</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnNameBuilder</name></type> <name>b</name> <init>= <expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> ? <call><name><name>builder</name>.<name>copy</name></name><argument_list>()</argument_list></call> : <name>builder</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>requested</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>b</name>.<name>add</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call>.<call><name>build</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <return>return <expr>new <class><super><name><name>Iterable</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list>
            <block>{
                <return>return <expr>new <class><super><name><name>AbstractIterator</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
                <block>{
                    <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>requested</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <function><type><specifier>public</specifier> <name>IColumn</name></type> <name>computeNext</name><parameter_list>()</parameter_list>
                    <block>{
                        <if>if <condition>(<expr>!<call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <return>return <expr><call><name>endOfData</name><argument_list>()</argument_list></call></expr>;</return></then></if>
                        <decl_stmt><decl><type><name>IColumn</name></type> <name>column</name> <init>= <expr><call><name><name>cf</name>.<name>getColumn</name></name><argument_list>(<argument><expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <return>return <expr><name>column</name> == null ? <call><name>computeNext</name><argument_list>()</argument_list></call> : <name>column</name></expr>;</return>
                    }</block></function>
                }</block></class></expr>;</return>
            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name><name>List</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name></type> <name>process</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl></param>, <param><decl><type><name>CqlMetadata</name></type> <name>schema</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>variables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name></type> <name>cqlRows</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name> <init>= <expr><call><name>getExpandedSelection</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Column</name></argument>&gt;</argument_list></name></type> <name>thriftColumns</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>

        <comment type="line">// Add schema only once</comment>
        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name>addToSchema</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <for>for (<init><decl><type><name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>Row</name></name></type> <name>row</name> <range>: <expr><name>rows</name></expr></range></decl></init>)
        <block>{
            <comment type="line">// Not columns match the query, skip</comment>
            <if>if <condition>(<expr><name><name>row</name>.<name>cf</name></name> == null</expr>)</condition><then>
                <continue>continue;</continue></then></if>

            <if>if <condition>(<expr><name><name>cfDef</name>.<name>isCompact</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// One cqlRow per column</comment>
                <for>for (<init><decl><type><name>IColumn</name></type> <name>c</name> <range>: <expr><call><name>columnsInOrder</name><argument_list>(<argument><expr><name><name>row</name>.<name>cf</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <expr_stmt><expr><name>thriftColumns</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Column</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>selection</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <decl_stmt><decl><type><name>ByteBuffer</name><index>[]</index></type> <name>components</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>components</name> = ((<name>CompositeType</name>)<name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name>).<call><name>split</name><argument_list>(<argument><expr><call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name>sliceRestriction</name> != null</expr>)</condition><then>
                    <block>{
                        <comment type="line">// For dynamic CF, the column could be out of the requested bounds, filter here</comment>
                        <if>if <condition>(<expr>!<call><name><name>sliceRestriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name><name>sliceRestriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call>.<call><name>getByteBuffer</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <continue>continue;</continue></then></if>
                        <if>if <condition>(<expr>!<call><name><name>sliceRestriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><call><name><name>sliceRestriction</name>.<name>bound</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>.<call><name>getByteBuffer</name><argument_list>(<argument><expr><name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></argument>, <argument><expr><name>variables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <continue>continue;</continue></then></if>
                    }</block></then></if></else></if>

                    <comment type="line">// Respect selection order</comment>
                    <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><name><name>p</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>Selector</name></type> <name>selector</name> <init>= <expr><name><name>p</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>addToSchema</name><argument_list>(<argument><expr><name>schema</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <decl_stmt><decl><type><name>Column</name></type> <name>col</name></decl>;</decl_stmt>
                        <switch>switch <condition>(<expr><name><name>name</name>.<name>kind</name></name></expr>)</condition>
                        <block>{
                            <case>case <expr><name>KEY_ALIAS</name></expr>:
                                <expr_stmt><expr><name>col</name> = new <call><name>Column</name><argument_list>(<argument><expr><call><name><name>selector</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>col</name>.<name>setValue</name></name><argument_list>(<argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>)</argument_list></call>.<call><name>setTimestamp</name><argument_list>(<argument><expr>-1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </case><case>case <expr><name>COLUMN_ALIAS</name></expr>:
                                <expr_stmt><expr><name>col</name> = new <call><name>Column</name><argument_list>(<argument><expr><call><name><name>selector</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><call><name><name>col</name>.<name>setTimestamp</name></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>timestamp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <if>if <condition>(<expr><name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
                                <block>{
                                    <if>if <condition>(<expr><name><name>name</name>.<name>position</name></name> &lt; <name><name>components</name>.<name>length</name></name></expr>)</condition><then>
                                        <expr_stmt><expr><call><name><name>col</name>.<name>setValue</name></name><argument_list>(<argument><expr><name><name>components</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                                    <else>else
                                        <expr_stmt><expr><call><name><name>col</name>.<name>setValue</name></name><argument_list>(<argument><expr><name><name>ByteBufferUtil</name>.<name>EMPTY_BYTE_BUFFER</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                                }</block></then>
                                <else>else
                                <block>{
                                    <expr_stmt><expr><call><name><name>col</name>.<name>setValue</name></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                }</block></else></if>
                                <break>break;</break>
                            </case><case>case <expr><name>VALUE_ALIAS</name></expr>:
                                <expr_stmt><expr><name>col</name> = <call><name>makeReturnColumn</name><argument_list>(<argument><expr><name>selector</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <break>break;</break>
                            </case><case>case <expr><name>COLUMN_METADATA</name></expr>:
                                <comment type="line">// This should not happen for compact CF</comment>
                                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
                            </case><default>default:
                                <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
                        </default>}</block></switch>
                        <expr_stmt><expr><call><name><name>thriftColumns</name>.<name>add</name></name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></for>
                    <expr_stmt><expr><call><name><name>cqlRows</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>CqlRow</name><argument_list>(<argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>, <argument><expr><name>thriftColumns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>cfDef</name>.<name>isComposite</name></name></expr>)</condition><then>
            <block>{
                <comment type="line">// Sparse case: group column in cqlRow when composite prefix is equal</comment>
                <decl_stmt><decl><type><name>CompositeType</name></type> <name>composite</name> <init>= <expr>(<name>CompositeType</name>)<name><name>cfDef</name>.<name>cfm</name>.<name>comparator</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><call><name><name>composite</name>.<name>types</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>ByteBuffer</name><index>[]</index></type> <name>previous</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>group</name> <init>= <expr>new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>IColumn</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>IColumn</name></type> <name>c</name> <range>: <expr><name><name>row</name>.<name>cf</name></name></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <decl_stmt><decl><type><name>ByteBuffer</name><index>[]</index></type> <name>current</name> <init>= <expr><call><name><name>composite</name>.<name>split</name></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <comment type="line">// If current differs from previous, we've just finished a group</comment>
                    <if>if <condition>(<expr><name>previous</name> != null &amp;&amp; !<call><name>isSameRow</name><argument_list>(<argument><expr><name>previous</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>cqlRows</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>handleGroup</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>group</name> = new <call><name><name>HashMap</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>IColumn</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <comment type="line">// Accumulate the current column</comment>
                    <expr_stmt><expr><call><name><name>group</name>.<name>put</name></name><argument_list>(<argument><expr><name><name>current</name><index>[<expr><name>last</name></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>previous</name> = <name>current</name></expr>;</expr_stmt>
                }</block></for>
                <comment type="line">// Handle the last group</comment>
                <if>if <condition>(<expr><name>previous</name> != null</expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>cqlRows</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>handleGroup</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>, <argument><expr><name>previous</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>schema</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else
            <block>{
                <if>if <condition>(<expr><call><name><name>row</name>.<name>cf</name>.<name>getLiveColumnCount</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
                    <continue>continue;</continue></then></if>

                <comment type="line">// Static case: One cqlRow for all columns</comment>
                <expr_stmt><expr><name>thriftColumns</name> = new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Column</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>selection</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="line">// Respect selection order</comment>
                <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><name><name>p</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>Selector</name></type> <name>selector</name> <init>= <expr><name><name>p</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><name><name>name</name>.<name>kind</name></name> == <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>KEY_ALIAS</name></name></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>thriftColumns</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>Column</name><argument_list>(<argument><expr><call><name><name>selector</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>)</argument_list></call>.<call><name>setValue</name><argument_list>(<argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>)</argument_list></call>.<call><name>setTimestamp</name><argument_list>(<argument><expr>-1L</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>

                    <decl_stmt><decl><type><name>IColumn</name></type> <name>c</name> <init>= <expr><call><name><name>row</name>.<name>cf</name>.<name>getColumn</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><call><name><name>thriftColumns</name>.<name>add</name></name><argument_list>(<argument><expr><call><name>makeReturnColumn</name><argument_list>(<argument><expr><name>selector</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
                <expr_stmt><expr><call><name><name>cqlRows</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>CqlRow</name><argument_list>(<argument><expr><name><name>row</name>.<name>key</name>.<name>key</name></name></expr></argument>, <argument><expr><name>thriftColumns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></for>

        <expr_stmt><expr><call><name>orderResults</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name>cqlRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// Internal calls always return columns in the comparator order, even when reverse was set</comment>
        <if>if <condition>(<expr><name>isReversed</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>Collections</name>.<name>reverse</name></name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// Trim result if needed to respect the limit</comment>
        <expr_stmt><expr><name>cqlRows</name> = <call><name><name>cqlRows</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; <name><name>parameters</name>.<name>limit</name></name> ? <call><name><name>cqlRows</name>.<name>subList</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>parameters</name>.<name>limit</name></name></expr></argument>)</argument_list></call> : <name>cqlRows</name></expr>;</expr_stmt>

        <return>return <expr><name>cqlRows</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Orders results when multiple keys are selected (using IN)
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>orderResults</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name></type> <name>cqlRows</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// There is nothing to do if</comment>
        <comment type="line">//   a. there are no results,</comment>
        <comment type="line">//   b. no ordering information where given,</comment>
        <comment type="line">//   c. key restriction wasn't given or it's not an IN expression</comment>
        <if>if <condition>(<expr><call><name><name>cqlRows</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> || <call><name><name>parameters</name>.<name>orderings</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> || <name>keyRestriction</name> == null || <call><name><name>keyRestriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; 2</expr>)</condition><then>
            <return>return;</return></then></if>


        <comment type="line">// optimization when only *one* order condition was given</comment>
        <comment type="line">// because there is no point of using composite comparator if there is only one order condition</comment>
        <if>if <condition>(<expr><call><name><name>parameters</name>.<name>orderings</name>.<name>size</name></name><argument_list>()</argument_list></call> == 1</expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>ordering</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>parameters</name>.<name>orderings</name>.<name>keySet</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call>.<call><name>next</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr>new <call><name>SingleColumnComparator</name><argument_list>(<argument><expr><call><name>getColumnPositionInSelect</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name>ordering</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ordering</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <comment type="line">// builds a 'composite' type for multi-column comparison from the comparators of the ordering components</comment>
        <comment type="line">// and passes collected position information and built composite comparator to CompositeComparator to do</comment>
        <comment type="line">// an actual comparison of the CQL rows.</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>types</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>parameters</name>.<name>orderings</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name><index>[]</index></type> <name>positions</name> <init>= <expr>new <name><name>int</name><index>[<expr><call><name><name>parameters</name>.<name>orderings</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnIdentifier</name></type> <name>identifier</name> <range>: <expr><call><name><name>parameters</name>.<name>orderings</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>orderingColumn</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>types</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>orderingColumn</name>.<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>positions</name><index>[<expr><name>idx</name>++</expr>]</index></name> = <call><name>getColumnPositionInSelect</name><argument_list>(<argument><expr><name>selection</name></expr></argument>, <argument><expr><name>orderingColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>cqlRows</name></expr></argument>, <argument><expr>new <call><name>CompositeComparator</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>positions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="line">// determine position of column in the select clause</comment>
    <function><type><specifier>private</specifier> <name>int</name></type> <name>getColumnPositionInSelect</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name></decl></param>, <param><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>columnName</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call><name><name>selection</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <if>if <condition>(<expr><call><name><name>selection</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<call><name><name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>i</name></expr>;</return></then></if>
        }</block></for>

        <throw>throw <expr>new <call><name>IllegalArgumentException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Column %s wasn't found in select clause."</expr></argument>, <argument><expr><name>columnName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * For sparse composite, returns wheter two columns belong to the same
     * cqlRow base on the full list of component in the name.
     * Two columns do belong together if they differ only by the last
     * component.
     */</comment>
    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isSameRow</name><parameter_list>(<param><decl><type><name><name>ByteBuffer</name><index>[]</index></name></type> <name>c1</name></decl></param>, <param><decl><type><name><name>ByteBuffer</name><index>[]</index></name></type> <name>c2</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// Cql don't allow to insert columns who doesn't have all component of</comment>
        <comment type="line">// the composite set for sparse composite. Someone coming from thrift</comment>
        <comment type="line">// could hit that though. But since we have no way to handle this</comment>
        <comment type="line">// correctly, better fail here and tell whomever may hit that (if</comment>
        <comment type="line">// someone ever do) to change the definition to a dense composite</comment>
        <assert>assert <expr><name><name>c1</name>.<name>length</name></name> == <name><name>c2</name>.<name>length</name></name> : "Sparse composite should not have partial column names"</expr>;</assert>
        <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>c1</name>.<name>length</name></name> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
            <if>if <condition>(<expr>!<name><name>c1</name><index>[<expr><name>i</name></expr>]</index></name>.<call><name>equals</name><argument_list>(<argument><expr><name><name>c2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
        }</block></for>
        <return>return <expr>true</expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>CqlRow</name></type> <name>handleGroup</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>selection</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>key</name></decl></param>, <param><decl><type><name><name>ByteBuffer</name><index>[]</index></name></type> <name>components</name></decl></param>, <param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>columns</name></decl></param>, <param><decl><type><name>CqlMetadata</name></type> <name>schema</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Column</name></argument>&gt;</argument_list></name></type> <name>thriftColumns</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Column</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>selection</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Respect requested order</comment>
        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>p</name> <range>: <expr><name>selection</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><name><name>p</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Selector</name></type> <name>selector</name> <init>= <expr><name><name>p</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>Column</name></type> <name>col</name></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name><name>name</name>.<name>kind</name></name></expr>)</condition>
            <block>{
                <case>case <expr><name>KEY_ALIAS</name></expr>:
                    <expr_stmt><expr><name>col</name> = new <call><name>Column</name><argument_list>(<argument><expr><call><name><name>selector</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>col</name>.<name>setValue</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call>.<call><name>setTimestamp</name><argument_list>(<argument><expr>-1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>COLUMN_ALIAS</name></expr>:
                    <expr_stmt><expr><name>col</name> = new <call><name>Column</name><argument_list>(<argument><expr><call><name><name>selector</name>.<name>id</name></name><argument_list>()</argument_list></call>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>col</name>.<name>setValue</name></name><argument_list>(<argument><expr><name><name>components</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>col</name>.<name>setTimestamp</name></name><argument_list>(<argument><expr>-1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>VALUE_ALIAS</name></expr>:
                    <comment type="line">// This should not happen for SPARSE</comment>
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
                </case><case>case <expr><name>COLUMN_METADATA</name></expr>:
                    <decl_stmt><decl><type><name>IColumn</name></type> <name>c</name> <init>= <expr><call><name><name>columns</name>.<name>get</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>col</name> = <call><name>makeReturnColumn</name><argument_list>(<argument><expr><name>selector</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><default>default:
                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
            </default>}</block></switch>
            <expr_stmt><expr><call><name><name>thriftColumns</name>.<name>add</name></name><argument_list>(<argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>new <call><name>CqlRow</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>thriftColumns</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>isReversedType</name><parameter_list>(<param><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name><name>name</name>.<name>type</name></name> instanceof <name>ReversedType</name></expr>;</return>
    }</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>RawStatement</name> <super><extends>extends <name>CFStatement</name></extends></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Parameters</name></type> <name>parameters</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>selectClause</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Relation</name></argument>&gt;</argument_list></name></type> <name>whereClause</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>RawStatement</name><parameter_list>(<param><decl><type><name>CFName</name></type> <name>cfName</name></decl></param>, <param><decl><type><name>Parameters</name></type> <name>parameters</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>selectClause</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Relation</name></argument>&gt;</argument_list></name></type> <name>whereClause</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>parameters</name></name> = <name>parameters</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>selectClause</name></name> = <name>selectClause</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>whereClause</name></name> = <name>whereClause</name> == null ? <name><name>Collections</name>.</name>&lt;<name>Relation</name>&gt;<call><name>emptyList</name><argument_list>()</argument_list></call> : <name>whereClause</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name><name>ParsedStatement</name>.<name>Prepared</name></name></type> <name>prepare</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
        <block>{
            <decl_stmt><decl><type><name>CFMetaData</name></type> <name>cfm</name> <init>= <expr><call><name><name>ThriftValidation</name>.<name>validateColumnFamily</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>ThriftValidation</name>.<name>validateConsistencyLevel</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>parameters</name>.<name>consistencyLevel</name></name></expr></argument>, <argument><expr><name><name>RequestType</name>.<name>READ</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name><name>parameters</name>.<name>limit</name></name> &lt;= 0</expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"LIMIT must be strictly positive"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name>CFDefinition</name></type> <name>cfDef</name> <init>= <expr><call><name><name>cfm</name>.<name>getCfDef</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>SelectStatement</name></type> <name>stmt</name> <init>= <expr>new <call><name>SelectStatement</name><argument_list>(<argument><expr><name>cfDef</name></expr></argument>, <argument><expr><call><name>getBoundsTerms</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name><index>[]</index></type> <name>names</name> <init>= <expr>new <name><name>CFDefinition</name>.<name>Name</name><index>[<expr><call><name>getBoundsTerms</name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="line">// Select clause</comment>
            <if>if <condition>(<expr><name><name>parameters</name>.<name>isCount</name></name></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr>!<call><name><name>selectClause</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Only COUNT(*) and COUNT(1) operations are currently supported."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            }</block></then>
            <else>else
            <block>{
                <for>for (<init><decl><type><name>Selector</name></type> <name>t</name> <range>: <expr><name>selectClause</name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>t</name>.<name>id</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>name</name> == null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Undefined name %s in selection clause"</expr></argument>, <argument><expr><call><name><name>t</name>.<name>id</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    <if>if <condition>(<expr><call><name><name>t</name>.<name>hasFunction</name></name><argument_list>()</argument_list></call> &amp;&amp; <name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>COLUMN_METADATA</name></name> &amp;&amp; <name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>VALUE_ALIAS</name></name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Cannot use function %s on PRIMARY KEY part %s"</expr></argument>, <argument><expr><call><name><name>t</name>.<name>function</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <expr_stmt><expr><call><name><name>stmt</name>.<name>selectedNames</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>Pair</name>.<name>create</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></for>
            }</block></else></if>

            <comment type="block">/*
             * WHERE clause. For a given entity, rules are:
             *   - EQ relation conflicts with anything else (including a 2nd EQ)
             *   - Can't have more than one LT(E) relation (resp. GT(E) relation)
             *   - IN relation are restricted to row keys (for now) and conflics with anything else
             *     (we could allow two IN for the same entity but that doesn't seem very useful)
             *   - The value_alias cannot be restricted in any way (we don't support wide rows with indexed value in CQL so far)
             */</comment>
            <for>for (<init><decl><type><name>Relation</name></type> <name>rel</name> <range>: <expr><name>whereClause</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>rel</name>.<name>getEntity</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>name</name> == null</expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Undefined name %s in where clause ('%s')"</expr></argument>, <argument><expr><call><name><name>rel</name>.<name>getEntity</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <if>if <condition>(<expr><call><name><name>rel</name>.<name>operator</name></name><argument_list>()</argument_list></call> == <name><name>Relation</name>.<name>Type</name>.<name>IN</name></name></expr>)</condition><then>
                <block>{
                    <for>for (<init><decl><type><name>Term</name></type> <name>value</name> <range>: <expr><call><name><name>rel</name>.<name>getInValues</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                        <if>if <condition>(<expr><call><name><name>value</name>.<name>isBindMarker</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <expr_stmt><expr><name><name>names</name><index>[<expr><name><name>value</name>.<name>bindIndex</name></name></expr>]</index></name> = <name>name</name></expr>;</expr_stmt></then></if></for>
                }</block></then>
                <else>else
                <block>{
                    <decl_stmt><decl><type><name>Term</name></type> <name>value</name> <init>= <expr><call><name><name>rel</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><call><name><name>value</name>.<name>isBindMarker</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><name><name>names</name><index>[<expr><name><name>value</name>.<name>bindIndex</name></name></expr>]</index></name> = <name>name</name></expr>;</expr_stmt></then></if>
                }</block></else></if>

                <switch>switch <condition>(<expr><name><name>name</name>.<name>kind</name></name></expr>)</condition>
                <block>{
                    <case>case <expr><name>KEY_ALIAS</name></expr>:
                        <if>if <condition>(<expr><call><name><name>rel</name>.<name>operator</name></name><argument_list>()</argument_list></call> != <name><name>Relation</name>.<name>Type</name>.<name>EQ</name></name> &amp;&amp; <call><name><name>rel</name>.<name>operator</name></name><argument_list>()</argument_list></call> != <name><name>Relation</name>.<name>Type</name>.<name>IN</name></name> &amp;&amp; !<name><name>rel</name>.<name>onToken</name></name> &amp;&amp; !<call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call>.<call><name>preservesOrder</name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Only EQ and IN relation are supported on first component of the PRIMARY KEY for RandomPartitioner (unless you use the token() function)"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                        <expr_stmt><expr><name><name>stmt</name>.<name>keyRestriction</name></name> = <call><name>updateRestriction</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stmt</name>.<name>keyRestriction</name></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </case><case>case <expr><name>COLUMN_ALIAS</name></expr>:
                        <expr_stmt><expr><name><name>stmt</name>.<name>columnRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name> = <call><name>updateRestriction</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stmt</name>.<name>columnRestrictions</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    </case><case>case <expr><name>VALUE_ALIAS</name></expr>:
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Restricting the value of a compact CF (%s) is not supported"</expr></argument>, <argument><expr><name><name>name</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                    </case><case>case <expr><name>COLUMN_METADATA</name></expr>:
                        <expr_stmt><expr><call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>put</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>updateRestriction</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                </case>}</block></switch>
            }</block></for>

            <decl_stmt><decl><type><name>boolean</name></type> <name>keyIsInRelation</name> <init>= <expr><name><name>stmt</name>.<name>keyRestriction</name></name> != null &amp;&amp; <call><name><name>stmt</name>.<name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>stmt</name>.<name>keyRestriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr></init></decl>;</decl_stmt>

            <comment type="block">/*
             * At this point, the select statement if fully constructed, but we still have a few things to validate
             */</comment>

            <comment type="line">// If a component of the PRIMARY KEY is restricted by a non-EQ relation, all preceding</comment>
            <comment type="line">// components must have a EQ, and all following must have no restriction</comment>
            <decl_stmt><decl><type><name>boolean</name></type> <name>shouldBeDone</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>previous</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>cfDef</name>.<name>columns</name>.<name>values</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>stmt</name>.<name>columnRestrictions</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>cname</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><name><name>stmt</name>.<name>columnRestrictions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>restriction</name> == null</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>shouldBeDone</name> = true</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>shouldBeDone</name></expr>)</condition><then>
                <block>{
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"PRIMARY KEY part %s cannot be restricted (preceding part %s is either not restricted or by a non-EQ relation)"</expr></argument>, <argument><expr><name>cname</name></expr></argument>, <argument><expr><name>previous</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>shouldBeDone</name> = true</expr>;</expr_stmt>
                    <comment type="line">// For non-composite slices, we don't support internally the difference between exclusive and</comment>
                    <comment type="line">// inclusive bounds, so we deal with it manually.</comment>
                    <if>if <condition>(<expr>!<name><name>cfDef</name>.<name>isComposite</name></name> &amp;&amp; (!<call><name><name>restriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>START</name></name></expr></argument>)</argument_list></call> || !<call><name><name>restriction</name>.<name>isInclusive</name></name><argument_list>(<argument><expr><name><name>Bound</name>.<name>END</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                        <expr_stmt><expr><name><name>stmt</name>.<name>sliceRestriction</name></name> = <name>restriction</name></expr>;</expr_stmt></then></if>
                }</block></then>
                <comment type="line">// We only support IN for the last name so far</comment>
                <else>else <if>if <condition>(<expr><call><name><name>restriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1 &amp;&amp; <name>i</name> != <name><name>stmt</name>.<name>columnRestrictions</name>.<name>length</name></name> - 1</expr>)</condition><then>
                <block>{
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"PRIMARY KEY part %s cannot be restricted by IN relation (only the first and last parts can)"</expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></then></if></else></if></else></if></else></if>

                <expr_stmt><expr><name>previous</name> = <name>cname</name></expr>;</expr_stmt>
            }</block></for>

            <comment type="line">// Deal with indexed columns</comment>
            <if>if <condition>(<expr>!<call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>boolean</name></type> <name>hasEq</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>indexed</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><call><name>keyspace</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><call><name>columnFamily</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name><name>indexManager</name>.<name>getIndexedColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Restriction</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>Restriction</name></type> <name>restriction</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name><name>restriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <comment type="line">// We don't support IN for indexed values (basically this would require supporting a form of OR)</comment>
                    <if>if <condition>(<expr><call><name><name>restriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Cannot use IN operator on column not part of the PRIMARY KEY"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <if>if <condition>(<expr><call><name><name>indexed</name>.<name>contains</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call>.<name><name>name</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>hasEq</name> = true</expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                }</block></for>
                <if>if <condition>(<expr>!<name>hasEq</name></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"No indexed columns present in by-columns clause with Equal operator"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <comment type="line">// If we have indexed columns and the key = X clause, we will do a range query, but if it's a IN relation, we don't know how to handle it.</comment>
                <if>if <condition>(<expr><name><name>stmt</name>.<name>keyRestriction</name></name> != null &amp;&amp; <call><name><name>stmt</name>.<name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>stmt</name>.<name>keyRestriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Select on indexed columns and with IN clause for the PRIMARY KEY are not supported"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name><name>stmt</name>.<name>parameters</name>.<name>orderings</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <if>if <condition>(<expr>!<call><name><name>stmt</name>.<name>metadataRestrictions</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"ORDER BY with 2ndary indexes is not supported."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <if>if <condition>(<expr><call><name><name>stmt</name>.<name>isKeyRange</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"ORDER BY is only supported when the partition key is restricted by an EQ or an IN."</expr></argument>)</argument_list></call></expr>;</throw></then></if>

                <comment type="line">// If we order an IN query, we'll have to do a manual sort post-query. Currently, this sorting requires that we</comment>
                <comment type="line">// have queried the column on which we sort (TODO: we should update it to add the column on which we sort to the one</comment>
                <comment type="line">// queried automatically, and then removing it from the resultSet afterwards if needed)</comment>
                <if>if <condition>(<expr><name>keyIsInRelation</name> &amp;&amp; !<call><name><name>stmt</name>.<name>selectedNames</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then> <comment type="line">// empty means wildcard was used</comment>
                <block>{
                    <for>for (<init><decl><type><name>ColumnIdentifier</name></type> <name>column</name> <range>: <expr><call><name><name>stmt</name>.<name>parameters</name>.<name>orderings</name>.<name>keySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                    <block>{
                        <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <decl_stmt><decl><type><name>boolean</name></type> <name>hasColumn</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
                        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name><name>CFDefinition</name>.<name>Name</name></name></argument>, <argument><name>Selector</name></argument>&gt;</argument_list></name></type> <name>selectPair</name> <range>: <expr><name><name>stmt</name>.<name>selectedNames</name></name></expr></range></decl></init>)
                        <block>{
                            <if>if <condition>(<expr><call><name><name>selectPair</name>.<name>left</name>.<name>equals</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>hasColumn</name> = true</expr>;</expr_stmt>
                                <break>break;</break>
                            }</block></then></if>
                        }</block></for>

                        <if>if <condition>(<expr>!<name>hasColumn</name></expr>)</condition><then>
                            <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"ORDER BY could not be used on columns missing in select clause."</expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    }</block></for>
                }</block></then></if>

                <decl_stmt><decl><type><name>Boolean</name><index>[]</index></type> <name>reversedMap</name> <init>= <expr>new <name><name>Boolean</name><index>[<expr><call><name><name>cfDef</name>.<name>columns</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>stmt</name>.<name>parameters</name>.<name>orderings</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>ColumnIdentifier</name></type> <name>column</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>boolean</name></type> <name>reversed</name> <init>= <expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name> <init>= <expr><call><name><name>cfDef</name>.<name>get</name></name><argument_list>(<argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>name</name> == null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Order by on unknown column %s"</expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <if>if <condition>(<expr><name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>COLUMN_ALIAS</name></name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Order by is currently only supported on the clustered columns of the PRIMARY KEY, got %s"</expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <if>if <condition>(<expr><name>i</name>++ != <name><name>name</name>.<name>position</name></name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Order by currently only support the ordering of columns following their declared order in the PRIMARY KEY"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

                    <expr_stmt><expr><name><name>reversedMap</name><index>[<expr><name><name>name</name>.<name>position</name></name></expr>]</index></name> = (<name>reversed</name> != <call><name>isReversedType</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                }</block></for>

                <comment type="line">// Check that all boolean in reversedMap, if set, agrees</comment>
                <decl_stmt><decl><type><name>Boolean</name></type> <name>isReversed</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>Boolean</name></type> <name>b</name> <range>: <expr><name>reversedMap</name></expr></range></decl></init>)
                <block>{
                    <comment type="line">// Column on which order is specified can be in any order</comment>
                    <if>if <condition>(<expr><name>b</name> == null</expr>)</condition><then>
                        <continue>continue;</continue></then></if>

                    <if>if <condition>(<expr><name>isReversed</name> == null</expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><name>isReversed</name> = <name>b</name></expr>;</expr_stmt>
                        <continue>continue;</continue>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>isReversed</name> != <name>b</name></expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Unsupported order by relation"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                }</block></for>
                <assert>assert <expr><name>isReversed</name> != null</expr>;</assert>
                <expr_stmt><expr><name><name>stmt</name>.<name>isReversed</name></name> = <name>isReversed</name></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="line">// If this is a query on tokens, it's necessary a range query (there can be more than one key per token), so reject IN queries (as we don't know how to do them)</comment>
            <if>if <condition>(<expr><name><name>stmt</name>.<name>keyRestriction</name></name> != null &amp;&amp; <name><name>stmt</name>.<name>keyRestriction</name>.<name>onToken</name></name> &amp;&amp; <call><name><name>stmt</name>.<name>keyRestriction</name>.<name>isEquality</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>stmt</name>.<name>keyRestriction</name>.<name>eqValues</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 1</expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr>"Select using the token() function don't support IN clause"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <return>return <expr>new <call><name><name>ParsedStatement</name>.<name>Prepared</name></name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>Arrays</name>.</name>&lt;<name><name>CFDefinition</name>.<name>Name</name></name>&gt;<call><name>asList</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>

        <function><type><name>Restriction</name></type> <name>updateRestriction</name><parameter_list>(<param><decl><type><name><name>CFDefinition</name>.<name>Name</name></name></type> <name>name</name></decl></param>, <param><decl><type><name>Restriction</name></type> <name>restriction</name></decl></param>, <param><decl><type><name>Relation</name></type> <name>newRel</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
        <block>{
            <if>if <condition>(<expr><name><name>newRel</name>.<name>onToken</name></name> &amp;&amp; <name><name>name</name>.<name>kind</name></name> != <name><name>CFDefinition</name>.<name>Name</name>.<name>Kind</name>.<name>KEY_ALIAS</name></name></expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"The token() function is only supported on the partition key, found on %s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <switch>switch <condition>(<expr><call><name><name>newRel</name>.<name>operator</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <case>case <expr><name>EQ</name></expr>:
                    <if>if <condition>(<expr><name>restriction</name> != null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s cannot be restricted by more than one relation if it includes an Equal"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    <expr_stmt><expr><name>restriction</name> = new <call><name>Restriction</name><argument_list>(<argument><expr><call><name><name>newRel</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>newRel</name>.<name>onToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>IN</name></expr>:
                    <if>if <condition>(<expr><name>restriction</name> != null</expr>)</condition><then>
                        <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s cannot be restricted by more than one reation if it includes a IN"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                    <expr_stmt><expr><name>restriction</name> = new <call><name>Restriction</name><argument_list>(<argument><expr><call><name><name>newRel</name>.<name>getInValues</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>GT</name></expr>:
                </case><case>case <expr><name>GTE</name></expr>:
                </case><case>case <expr><name>LT</name></expr>:
                </case><case>case <expr><name>LTE</name></expr>:
                    <if>if <condition>(<expr><name>restriction</name> == null</expr>)</condition><then>
                        <expr_stmt><expr><name>restriction</name> = new <call><name>Restriction</name><argument_list>(<argument><expr><name><name>newRel</name>.<name>onToken</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <expr_stmt><expr><call><name><name>restriction</name>.<name>setBound</name></name><argument_list>(<argument><expr><name><name>name</name>.<name>name</name></name></expr></argument>, <argument><expr><call><name><name>newRel</name>.<name>operator</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>newRel</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
            </case>}</block></switch>
            <return>return <expr><name>restriction</name></expr>;</return>
        }</block></function>

        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"SelectRawStatement[name=%s, selectClause=%s, whereClause=%s, isCount=%s, cLevel=%s, limit=%s]"</expr></argument>,
                    <argument><expr><name>cfName</name></expr></argument>,
                    <argument><expr><name>selectClause</name></expr></argument>,
                    <argument><expr><name>whereClause</name></expr></argument>,
                    <argument><expr><name><name>parameters</name>.<name>isCount</name></name></expr></argument>,
                    <argument><expr><name><name>parameters</name>.<name>consistencyLevel</name></name></expr></argument>,
                    <argument><expr><name><name>parameters</name>.<name>limit</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="line">// A rather raw class that simplify validation and query for select</comment>
    <comment type="line">// Don't made public as this can be easily badly used</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>Restriction</name>
    <block>{
        <comment type="line">// for equality</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>eqValues</name></decl>;</decl_stmt> <comment type="line">// if null, it's a restriction by bounds</comment>

        <comment type="line">// for bounds</comment>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>Term</name><index>[]</index></type> <name>bounds</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name><index>[]</index></type> <name>boundInclusive</name></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>onToken</name></decl>;</decl_stmt>

        <constructor><name>Restriction</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Term</name></argument>&gt;</argument_list></name></type> <name>values</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>eqValues</name></name> = <name>values</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>bounds</name></name> = null</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>boundInclusive</name></name> = null</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>onToken</name></name> = false</expr>;</expr_stmt>
        }</block></constructor>

        <constructor><name>Restriction</name><parameter_list>(<param><decl><type><name>Term</name></type> <name>value</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>onToken</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><call><name>this</name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></constructor>

        <constructor><name>Restriction</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>onToken</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>eqValues</name></name> = null</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>bounds</name></name> = new <name><name>Term</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>boundInclusive</name></name> = new <name><name>boolean</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>onToken</name></name> = <name>onToken</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><name>boolean</name></type> <name>isEquality</name><parameter_list>()</parameter_list>
        <block>{
            <return>return <expr><name>eqValues</name> != null</expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setBound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>, <param><decl><type><name>Term</name></type> <name>t</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setInclusive</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = true</expr>;</expr_stmt>
        }</block></function>

        <function><type><specifier>public</specifier> <name>Term</name></type> <name>bound</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isInclusive</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <return>return <expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> == null || <name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name></expr>;</return>
        }</block></function>

        <function><type><specifier>public</specifier> <name><name>Relation</name>.<name>Type</name></name></type> <name>getRelation</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>eocBound</name></decl></param>, <param><decl><type><name>Bound</name></type> <name>inclusiveBound</name></decl></param>)</parameter_list>
        <block>{
            <switch>switch <condition>(<expr><name>eocBound</name></expr>)</condition>
            <block>{
                <case>case <expr><name>START</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>inclusiveBound</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>Relation</name>.<name>Type</name>.<name>GTE</name></name> : <name><name>Relation</name>.<name>Type</name>.<name>GT</name></name></expr>;</return>
                </case><case>case <expr><name>END</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>inclusiveBound</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>Relation</name>.<name>Type</name>.<name>LTE</name></name> : <name><name>Relation</name>.<name>Type</name>.<name>LT</name></name></expr>;</return>
            </case>}</block></switch>
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></function>

        <function><type><specifier>public</specifier> <name>IndexOperator</name></type> <name>getIndexOperator</name><parameter_list>(<param><decl><type><name>Bound</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <switch>switch <condition>(<expr><name>b</name></expr>)</condition>
            <block>{
                <case>case <expr><name>START</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>IndexOperator</name>.<name>GTE</name></name> : <name><name>IndexOperator</name>.<name>GT</name></name></expr>;</return>
                </case><case>case <expr><name>END</name></expr>:
                    <return>return <expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> ? <name><name>IndexOperator</name>.<name>LTE</name></name> : <name><name>IndexOperator</name>.<name>LT</name></name></expr>;</return>
            </case>}</block></switch>
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>()</argument_list></call></expr>;</throw>
        }</block></function>

        <function><type><specifier>public</specifier> <name>void</name></type> <name>setBound</name><parameter_list>(<param><decl><type><name>ColumnIdentifier</name></type> <name>name</name></decl></param>, <param><decl><type><name><name>Relation</name>.<name>Type</name></name></type> <name>type</name></decl></param>, <param><decl><type><name>Term</name></type> <name>t</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>InvalidRequestException</name></expr></argument></throws>
        <block>{
            <decl_stmt><decl><type><name>Bound</name></type> <name>b</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>boolean</name></type> <name>inclusive</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
            <switch>switch <condition>(<expr><name>type</name></expr>)</condition>
            <block>{
                <case>case <expr><name>GT</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>START</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = false</expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>GTE</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>START</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = true</expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>LT</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>END</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = false</expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>LTE</name></expr>:
                    <expr_stmt><expr><name>b</name> = <name><name>Bound</name>.<name>END</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>inclusive</name> = true</expr>;</expr_stmt>
                    <break>break;</break>
            </case>}</block></switch>

            <if>if <condition>(<expr><name>bounds</name> == null</expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s cannot be restricted by both an equal and an inequal relation"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <if>if <condition>(<expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> != null</expr>)</condition><then>
                <throw>throw <expr>new <call><name>InvalidRequestException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Invalid restrictions found on %s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
            <expr_stmt><expr><name><name>bounds</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = <name>t</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>boundInclusive</name><index>[<expr><name><name>b</name>.<name>idx</name></name></expr>]</index></name> = <name>inclusive</name></expr>;</expr_stmt>
        }</block></function>

        <function><type><annotation>@<name>Override</name></annotation>
        <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>String</name></type> <name>s</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>eqValues</name> == null</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>s</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"SLICE(%s %s, %s %s)"</expr></argument>, <argument><expr><name><name>boundInclusive</name><index>[<expr>0</expr>]</index></name> ? "&gt;=" : "&gt;"</expr></argument>,
                                                            <argument><expr><name><name>bounds</name><index>[<expr>0</expr>]</index></name></expr></argument>,
                                                            <argument><expr><name><name>boundInclusive</name><index>[<expr>1</expr>]</index></name> ? "&lt;=" : "&lt;"</expr></argument>,
                                                            <argument><expr><name><name>bounds</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>s</name> = <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"EQ(%s)"</expr></argument>, <argument><expr><name>eqValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <return>return <expr><name>onToken</name> ? <name>s</name> + "*" : <name>s</name></expr>;</return>
        }</block></function>
    }</block></class>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>Parameters</name>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>limit</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>ConsistencyLevel</name></type> <name>consistencyLevel</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>orderings</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>boolean</name></type> <name>isCount</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>Parameters</name><parameter_list>(<param><decl><type><name>ConsistencyLevel</name></type> <name>consistency</name></decl></param>, <param><decl><type><name>int</name></type> <name>limit</name></decl></param>, <param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>ColumnIdentifier</name></argument>, <argument><name>Boolean</name></argument>&gt;</argument_list></name></type> <name>orderings</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isCount</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>consistencyLevel</name></name> = <name>consistency</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>limit</name></name> = <name>limit</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>orderings</name></name> = <name>orderings</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>isCount</name></name> = <name>isCount</name></expr>;</expr_stmt>
        }</block></constructor>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Used in orderResults(...) method when single 'ORDER BY' condition where given
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>SingleColumnComparator</name> <super><implements>implements <name><name>Comparator</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name></type> <name>index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>comparator</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>SingleColumnComparator</name><parameter_list>(<param><decl><type><name>int</name></type> <name>columnIndex</name></decl></param>, <param><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>orderer</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name>index</name> = <name>columnIndex</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>comparator</name> = <name>orderer</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<param><decl><type><name>CqlRow</name></type> <name>a</name></decl></param>, <param><decl><type><name>CqlRow</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <decl_stmt><decl><type><name>Column</name></type> <name>columnA</name> <init>= <expr><call><name><name>a</name>.<name>getColumns</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Column</name></type> <name>columnB</name> <init>= <expr><call><name><name>b</name>.<name>getColumns</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr><call><name><name>comparator</name>.<name>compare</name></name><argument_list>(<argument><expr><call><name><name>columnA</name>.<name>bufferForValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>columnB</name>.<name>bufferForValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></function>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Used in orderResults(...) method when multiple 'ORDER BY' conditions where given
     */</comment>
    <class><specifier>private</specifier> <specifier>static</specifier> class <name>CompositeComparator</name> <super><implements>implements <name><name>Comparator</name><argument_list>&lt;<argument><name>CqlRow</name></argument>&gt;</argument_list></name></implements></super>
    <block>{
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>orderTypes</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>int</name><index>[]</index></type> <name>positions</name></decl>;</decl_stmt>

        <constructor><specifier>private</specifier> <name>CompositeComparator</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>orderTypes</name></decl></param>, <param><decl><type><name><name>int</name><index>[]</index></name></type> <name>positions</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>orderTypes</name></name> = <name>orderTypes</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>positions</name></name> = <name>positions</name></expr>;</expr_stmt>
        }</block></constructor>

        <function><type><specifier>public</specifier> <name>int</name></type> <name>compare</name><parameter_list>(<param><decl><type><name>CqlRow</name></type> <name>a</name></decl></param>, <param><decl><type><name>CqlRow</name></type> <name>b</name></decl></param>)</parameter_list>
        <block>{
            <for>for (<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name><name>positions</name>.<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
                <decl_stmt><decl><type><name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>type</name> <init>= <expr><call><name><name>orderTypes</name>.<name>get</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>columnPos</name> <init>= <expr><name><name>positions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>aValue</name> <init>= <expr><call><name><name>a</name>.<name>getColumns</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>columnPos</name></expr></argument>)</argument_list></call>.<call><name>bufferForValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>bValue</name> <init>= <expr><call><name><name>b</name>.<name>getColumns</name></name><argument_list>()</argument_list></call>.<call><name>get</name><argument_list>(<argument><expr><name>columnPos</name></expr></argument>)</argument_list></call>.<call><name>bufferForValue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>int</name></type> <name>comparison</name> <init>= <expr><call><name><name>type</name>.<name>compare</name></name><argument_list>(<argument><expr><name>aValue</name></expr></argument>, <argument><expr><name>bValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>comparison</name> != 0</expr>)</condition><then>
                    <return>return <expr><name>comparison</name></expr>;</return></then></if>
            }</block></for>

            <return>return <expr>0</expr>;</return>
        }</block></function>
    }</block></class>
}</block></class>
</unit>
