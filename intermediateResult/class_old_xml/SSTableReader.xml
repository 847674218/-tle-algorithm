<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\io\sstable\SSTableReader.java"><comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name></name>.*;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicBoolean</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name></name>.*;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cache</name>.<name>KeyCacheKey</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>DebuggableThreadPoolExecutor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>ColumnDefinition</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>Schema</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>index</name>.<name>keys</name>.<name>KeysIndex</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>LocalPartitioner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>compress</name>.<name>CompressedRandomAccessReader</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>CacheService</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cache</name>.<name>InstrumentingCache</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>DatabaseDescriptor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>commitlog</name>.<name>ReplayPosition</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>QueryFilter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>AbstractBounds</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>IPartitioner</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>Range</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>Token</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>compress</name>.<name>CompressionMetadata</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>util</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name></name>.*;</import>

<comment type="block" format="javadoc">/**
 * SSTableReaders are open()ed by Table.onStart; after that they are created by SSTableWriter.renameAndOpen.
 * Do not re-call open() on existing SSTable files; use the references kept by ColumnFamilyStore post-start instead.
 */</comment>
<class><specifier>public</specifier> class <name>SSTableReader</name> <super><extends>extends <name>SSTable</name></extends></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>SSTableReader</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// guesstimated size of INDEX_INTERVAL index entries</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INDEX_FILE_BUFFER_BYTES</name> <init>= <expr>16 * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/**
     * maxDataAge is a timestamp in local server time (e.g. System.currentTimeMilli) which represents an uppper bound
     * to the newest piece of data stored in the sstable. In other words, this sstable does not contain items created
     * later than maxDataAge.
     *
     * The field is not serialized to disk, so relying on it for more than what truncate does is not advised.
     *
     * When a new sstable is flushed, maxDataAge is set to the time of creation.
     * When a sstable is created from compaction, maxDataAge is set to max of all merged tables.
     *
     * The age is in milliseconds since epoc and is local to this host.
     */</comment>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>long</name></type> <name>maxDataAge</name></decl>;</decl_stmt>

    <comment type="line">// indexfile and datafile: might be null before a call to load()</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>SegmentedFile</name></type> <name>ifile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>SegmentedFile</name></type> <name>dfile</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>IndexSummary</name></type> <name>indexSummary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>Filter</name></type> <name>bf</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name><name>InstrumentingCache</name><argument_list>&lt;<argument><name>KeyCacheKey</name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>keyCache</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>BloomFilterTracker</name></type> <name>bloomFilterTracker</name> <init>= <expr>new <call><name>BloomFilterTracker</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicInteger</name></type> <name>references</name> <init>= <expr>new <call><name>AtomicInteger</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="line">// technically isCompacted is not necessary since it should never be unreferenced unless it is also compacted,</comment>
    <comment type="line">// but it seems like a good extra layer of protection against reference counting bugs to not delete data based on that alone</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicBoolean</name></type> <name>isCompacted</name> <init>= <expr>new <call><name>AtomicBoolean</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicBoolean</name></type> <name>isSuspect</name> <init>= <expr>new <call><name>AtomicBoolean</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>SSTableDeletingTask</name></type> <name>deletingTask</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>SSTableMetadata</name></type> <name>sstableMetadata</name></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>getApproximateKeyCount</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>indexKeyCount</name> <init>= <expr><call><name><name>sstable</name>.<name>getKeySamples</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>count</name> = <name>count</name> + (<name>indexKeyCount</name> + 1) * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"index size for bloom filter calc for file  : " + <call><name><name>sstable</name>.<name>getFilename</name></name><argument_list>()</argument_list></call> + "   : " + <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <return>return <expr><name>count</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SSTableReader</name></type> <name>open</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>descriptor</name>.<name>cfname</name>.<name>contains</name></name><argument_list>(<argument><expr>"."</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name><name>descriptor</name>.<name>cfname</name>.<name>indexOf</name></name><argument_list>(<argument><expr>"."</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>String</name></type> <name>parentName</name> <init>= <expr><call><name><name>descriptor</name>.<name>cfname</name>.<name>substring</name></name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>CFMetaData</name></type> <name>parent</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getCFMetaData</name></name><argument_list>(<argument><expr><name><name>descriptor</name>.<name>ksname</name></name></expr></argument>, <argument><expr><name>parentName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ColumnDefinition</name></type> <name>def</name> <init>= <expr><call><name><name>parent</name>.<name>getColumnDefinitionForIndex</name></name><argument_list>(<argument><expr><call><name><name>descriptor</name>.<name>cfname</name>.<name>substring</name></name><argument_list>(<argument><expr><name>i</name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>metadata</name> = <call><name><name>CFMetaData</name>.<name>newIndexMetadata</name></name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>def</name></expr></argument>, <argument><expr><call><name><name>KeysIndex</name>.<name>indexComparator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><name>metadata</name> = <call><name><name>Schema</name>.<name>instance</name>.<name>getCFMetaData</name></name><argument_list>(<argument><expr><name><name>descriptor</name>.<name>ksname</name></name></expr></argument>, <argument><expr><name><name>descriptor</name>.<name>cfname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr><call><name>open</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SSTableReader</name></type> <name>open</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>desc</name></decl></param>, <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>IPartitioner</name></type> <name>p</name> <init>= <expr><call><name><name>desc</name>.<name>cfname</name>.<name>contains</name></name><argument_list>(<argument><expr>"."</expr></argument>)</argument_list></call>
                       ? new <call><name>LocalPartitioner</name><argument_list>(<argument><expr><call><name><name>metadata</name>.<name>getKeyValidator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
                       : <call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name>open</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>componentsFor</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SSTableReader</name></type> <name>openNoValidation</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name></decl></param>, <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name>open</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>components</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>DecoratedKey</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SSTableReader</name></type> <name>open</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name></decl></param>, <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>, <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name>open</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>components</name></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>DecoratedKey</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>SSTableReader</name></type> <name>open</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>savedKeys</name></decl></param>, <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>, <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <return>return <expr><call><name>open</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>components</name></expr></argument>, <argument><expr><name>savedKeys</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>SSTableReader</name></type> <name>open</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></param>,
                                      <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name></decl></param>,
                                      <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>savedKeys</name></decl></param>,
                                      <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>,
                                      <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>,
                                      <param><decl><type><name>boolean</name></type> <name>validate</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr><name>partitioner</name> != null</expr>;</assert>
        <comment type="line">// Minimum components without which we can't do anything</comment>
        <assert>assert <expr><call><name><name>components</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>DATA</name></name></expr></argument>)</argument_list></call> : "Data component is missing for sstable" + <name>descriptor</name></expr>;</assert>
        <assert>assert <expr><call><name><name>components</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>PRIMARY_INDEX</name></name></expr></argument>)</argument_list></call> : "Primary index component is missing for sstable " + <name>descriptor</name></expr>;</assert>

        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Opening {} ({} bytes)"</expr></argument>, <argument><expr><name>descriptor</name></expr></argument>, <argument><expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name>COMPONENT_DATA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<call><name>length</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>SSTableMetadata</name></type> <name>sstableMetadata</name> <init>= <expr><call><name><name>components</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>STATS</name></name></expr></argument>)</argument_list></call>
                                        ? <call><name><name>SSTableMetadata</name>.<name>serializer</name>.<name>deserialize</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>)</argument_list></call>
                                        : <call><name><name>SSTableMetadata</name>.<name>createDefaultInstance</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Check if sstable is created using same partitioner.</comment>
        <comment type="line">// Partitioner can be null, which indicates older version of sstable or no stats available.</comment>
        <comment type="line">// In that case, we skip the check.</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>partitionerName</name> <init>= <expr><call><name><name>partitioner</name>.<name>getClass</name></name><argument_list>()</argument_list></call>.<call><name>getCanonicalName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>sstableMetadata</name>.<name>partitioner</name></name> != null &amp;&amp; !<call><name><name>partitionerName</name>.<name>equals</name></name><argument_list>(<argument><expr><name><name>sstableMetadata</name>.<name>partitioner</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Cannot open %s because partitioner does not match %s"</expr></argument>,
                                                     <argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>partitionerName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name> <init>= <expr>new <call><name>SSTableReader</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>,
                                                  <argument><expr><name>components</name></expr></argument>,
                                                  <argument><expr><name>metadata</name></expr></argument>,
                                                  <argument><expr><name>partitioner</name></expr></argument>,
                                                  <argument><expr>null</expr></argument>,
                                                  <argument><expr>null</expr></argument>,
                                                  <argument><expr>null</expr></argument>,
                                                  <argument><expr>null</expr></argument>,
                                                  <argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                  <argument><expr><name>sstableMetadata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="line">// versions before 'c' encoded keys as utf-16 before hashing to the filter</comment>
        <if>if <condition>(<expr><name><name>descriptor</name>.<name>hasStringsInBloomFilter</name></name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>sstable</name>.<name>load</name></name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr><name>savedKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name><name>sstable</name>.<name>load</name></name><argument_list>(<argument><expr>false</expr></argument>, <argument><expr><name>savedKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sstable</name>.<name>loadBloomFilter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>validate</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>sstable</name>.<name>validate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"INDEX LOAD TIME for " + <name>descriptor</name> + ": " + (<call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> - <name>start</name>) + " ms."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>sstable</name>.<name>getKeyCache</name></name><argument_list>()</argument_list></call> != null</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"key cache contains %s/%s keys"</expr></argument>, <argument><expr><call><name><name>sstable</name>.<name>getKeyCache</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>sstable</name>.<name>getKeyCache</name></name><argument_list>()</argument_list></call>.<call><name>getCapacity</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <return>return <expr><name>sstable</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>logOpenException</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>descriptor</name></decl></param>, <param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>e</name> instanceof <name>FileNotFoundException</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr>"Missing sstable component in " + <name>descriptor</name> + "; skipped because of " + <call><name><name>e</name>.<name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr>"Corrupt sstable " + <name>descriptor</name> + "; skipped"</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>batchOpen</name><parameter_list>(<param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></argument>&gt;</argument_list></name></type> <name>entries</name></decl></param>,
                                                      <param><decl><type><specifier>final</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>savedKeys</name></decl></param>,
                                                      <param><decl><type><specifier>final</specifier> <name>DataTracker</name></type> <name>tracker</name></decl></param>,
                                                      <param><decl><type><specifier>final</specifier> <name>CFMetaData</name></type> <name>metadata</name></decl></param>,
                                                      <param><decl><type><specifier>final</specifier> <name>IPartitioner</name></type> <name>partitioner</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr>new <call><name><name>LinkedBlockingQueue</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>ExecutorService</name></type> <name>executor</name> <init>= <expr><call><name><name>DebuggableThreadPoolExecutor</name>.<name>createWithFixedPoolSize</name></name><argument_list>(<argument><expr>"SSTableBatchOpen"</expr></argument>, <argument><expr><call><name><name>FBUtilities</name>.<name>getAvailableProcessors</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><specifier>final</specifier> <name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><name>entries</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Runnable</name></type> <name>runnable</name> <init>= <expr>new <class><super><name>Runnable</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list>
                <block>{
                    <decl_stmt><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl>;</decl_stmt>
                    <try>try
                    <block>{
                        <expr_stmt><expr><name>sstable</name> = <call><name>open</name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>savedKeys</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>ex</name></decl></param>)</parameter_list>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr>"Corrupt sstable " + <name>entry</name> + "; skipped"</expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return;</return>
                    }</block></catch></try>
                    <expr_stmt><expr><call><name><name>sstables</name>.<name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></function>
            }</block></class></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>executor</name>.<name>submit</name></name><argument_list>(<argument><expr><name>runnable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name><name>executor</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>executor</name>.<name>awaitTermination</name></name><argument_list>(<argument><expr>7</expr></argument>, <argument><expr><name><name>TimeUnit</name>.<name>DAYS</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <return>return <expr><name>sstables</name></expr>;</return>

    }</block></function>

    <comment type="block" format="javadoc">/**
     * Open a RowIndexedReader which already has its state initialized (by SSTableWriter).
     */</comment>
    <function><type><specifier>static</specifier> <name>SSTableReader</name></type> <name>internalOpen</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>desc</name></decl></param>,
                                      <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name></decl></param>,
                                      <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>,
                                      <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>,
                                      <param><decl><type><name>SegmentedFile</name></type> <name>ifile</name></decl></param>,
                                      <param><decl><type><name>SegmentedFile</name></type> <name>dfile</name></decl></param>,
                                      <param><decl><type><name>IndexSummary</name></type> <name>isummary</name></decl></param>,
                                      <param><decl><type><name>Filter</name></type> <name>bf</name></decl></param>,
                                      <param><decl><type><name>long</name></type> <name>maxDataAge</name></decl></param>,
                                      <param><decl><type><name>SSTableMetadata</name></type> <name>sstableMetadata</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <assert>assert <expr><name>desc</name> != null &amp;&amp; <name>partitioner</name> != null &amp;&amp; <name>ifile</name> != null &amp;&amp; <name>dfile</name> != null &amp;&amp; <name>isummary</name> != null &amp;&amp; <name>bf</name> != null &amp;&amp; <name>sstableMetadata</name> != null</expr>;</assert>
        <return>return <expr>new <call><name>SSTableReader</name><argument_list>(<argument><expr><name>desc</name></expr></argument>,
                                 <argument><expr><name>components</name></expr></argument>,
                                 <argument><expr><name>metadata</name></expr></argument>,
                                 <argument><expr><name>partitioner</name></expr></argument>,
                                 <argument><expr><name>ifile</name></expr></argument>, <argument><expr><name>dfile</name></expr></argument>,
                                 <argument><expr><name>isummary</name></expr></argument>,
                                 <argument><expr><name>bf</name></expr></argument>,
                                 <argument><expr><name>maxDataAge</name></expr></argument>,
                                 <argument><expr><name>sstableMetadata</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <constructor><specifier>private</specifier> <name>SSTableReader</name><parameter_list>(<param><decl><type><name>Descriptor</name></type> <name>desc</name></decl></param>,
                          <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name></decl></param>,
                          <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>,
                          <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>,
                          <param><decl><type><name>SegmentedFile</name></type> <name>ifile</name></decl></param>,
                          <param><decl><type><name>SegmentedFile</name></type> <name>dfile</name></decl></param>,
                          <param><decl><type><name>IndexSummary</name></type> <name>indexSummary</name></decl></param>,
                          <param><decl><type><name>Filter</name></type> <name>bloomFilter</name></decl></param>,
                          <param><decl><type><name>long</name></type> <name>maxDataAge</name></decl></param>,
                          <param><decl><type><name>SSTableMetadata</name></type> <name>sstableMetadata</name></decl></param>)</parameter_list>
    <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>super</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>components</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>sstableMetadata</name></name> = <name>sstableMetadata</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>maxDataAge</name></name> = <name>maxDataAge</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>this</name>.<name>ifile</name></name> = <name>ifile</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>dfile</name></name> = <name>dfile</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>indexSummary</name></name> = <name>indexSummary</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>bf</name></name> = <name>bloomFilter</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>deletingTask</name></name> = new <call><name>SSTableDeletingTask</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></constructor>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setTrackedBy</name><parameter_list>(<param><decl><type><name>DataTracker</name></type> <name>tracker</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><name>keyCache</name> = <name><name>CacheService</name>.<name>instance</name>.<name>keyCache</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>deletingTask</name>.<name>setTracker</name></name><argument_list>(<argument><expr><name>tracker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>loadBloomFilter</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr>!<call><name><name>components</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>FILTER</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>bf</name> = <call><name><name>BloomFilter</name>.<name>emptyFilter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>DataInputStream</name></type> <name>stream</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>stream</name> = new <call><name>DataInputStream</name><argument_list>(<argument><expr>new <call><name>BufferedInputStream</name><argument_list>(<argument><expr>new <call><name>FileInputStream</name><argument_list>(<argument><expr><call><name><name>descriptor</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>FILTER</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>descriptor</name>.<name>usesOldBloomFilter</name></name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>bf</name> = <call><name><name>LegacyBloomFilter</name>.<name>serializer</name></name><argument_list>()</argument_list></call>.<call><name>deserialize</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><name>bf</name> = <call><name><name>BloomFilter</name>.<name>serializer</name></name><argument_list>()</argument_list></call>.<call><name>deserialize</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>FileUtils</name>.<name>closeQuietly</name></name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Loads ifile, dfile and indexSummary, and optionally recreates the bloom filter.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>load</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>recreatebloom</name></decl></param>, <param><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>keysToLoadInCache</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>boolean</name></type> <name>cacheLoading</name> <init>= <expr>!<call><name><name>keysToLoadInCache</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cacheLoading</name> &amp;&amp; <name>keyCache</name> == null</expr>)</condition><then>
            <expr_stmt><expr><name>keyCache</name> = <name><name>CacheService</name>.<name>instance</name>.<name>keyCache</name></name></expr>;</expr_stmt></then></if>

        <decl_stmt><decl><type><name><name>SegmentedFile</name>.<name>Builder</name></name></type> <name>ibuilder</name> <init>= <expr><call><name><name>SegmentedFile</name>.<name>getBuilder</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getIndexAccessMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>SegmentedFile</name>.<name>Builder</name></name></type> <name>dbuilder</name> <init>= <expr><name>compression</name>
                                          ? <call><name><name>SegmentedFile</name>.<name>getCompressedBuilder</name></name><argument_list>()</argument_list></call>
                                          : <call><name><name>SegmentedFile</name>.<name>getBuilder</name></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getDiskAccessMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// we read the positions in a BRAF so we don't have to worry about an entry spanning a mmap boundary.</comment>
        <decl_stmt><decl><type><name>RandomAccessReader</name></type> <name>input</name> <init>= <expr><call><name><name>RandomAccessReader</name>.<name>open</name></name><argument_list>(<argument><expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>PRIMARY_INDEX</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>left</name> <init>= <expr>null</expr></init>, <name>right</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>indexSize</name> <init>= <expr><call><name><name>input</name>.<name>length</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>histogramCount</name> <init>= <expr><call><name><name>sstableMetadata</name>.<name>estimatedRowSize</name>.<name>count</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>estimatedKeys</name> <init>= <expr><name>histogramCount</name> &gt; 0 &amp;&amp; !<call><name><name>sstableMetadata</name>.<name>estimatedRowSize</name>.<name>isOverflowed</name></name><argument_list>()</argument_list></call>
                               ? <name>histogramCount</name>
                               : <call><name><name>SSTable</name>.<name>estimateRowsFromIndex</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// statistics is supposed to be optional</comment>
            <expr_stmt><expr><name>indexSummary</name> = new <call><name>IndexSummary</name><argument_list>(<argument><expr><name>estimatedKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>recreatebloom</name></expr>)</condition><then>
                <expr_stmt><expr><name>bf</name> = <call><name><name>LegacyBloomFilter</name>.<name>getFilter</name></name><argument_list>(<argument><expr><name>estimatedKeys</name></expr></argument>, <argument><expr>15</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <while>while <condition>(<expr>true</expr>)</condition>
            <block>{
                <decl_stmt><decl><type><name>long</name></type> <name>indexPosition</name> <init>= <expr><call><name><name>input</name>.<name>getFilePointer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>indexPosition</name> == <name>indexSize</name></expr>)</condition><then>
                    <break>break;</break></then></if>

                <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>decoratedKey</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name><name>ByteBufferUtil</name>.<name>readShortLength</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <decl_stmt><decl><type><name>boolean</name></type> <name>firstKey</name> <init>= <expr><name>left</name> == null</expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>boolean</name></type> <name>lastKey</name> <init>= <expr><name>indexPosition</name> + <name><name>DBConstants</name>.<name>shortSize</name></name> + <name>len</name> + <name><name>DBConstants</name>.<name>longSize</name></name> == <name>indexSize</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>boolean</name></type> <name>shouldAddEntry</name> <init>= <expr><call><name><name>indexSummary</name>.<name>shouldAddEntry</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>shouldAddEntry</name> || <name>cacheLoading</name> || <name>recreatebloom</name> || <name>firstKey</name> || <name>lastKey</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>decoratedKey</name> = <call><name>decodeKey</name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>descriptor</name></expr></argument>, <argument><expr><call><name><name>ByteBufferUtil</name>.<name>read</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>firstKey</name></expr>)</condition><then>
                        <expr_stmt><expr><name>left</name> = <name>decoratedKey</name></expr>;</expr_stmt></then></if>
                    <if>if <condition>(<expr><name>lastKey</name></expr>)</condition><then>
                        <expr_stmt><expr><name>right</name> = <name>decoratedKey</name></expr>;</expr_stmt></then></if>
                }</block></then>
                <else>else
                <block>{
                    <expr_stmt><expr><call><name><name>FileUtils</name>.<name>skipBytesFully</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>

                <decl_stmt><decl><type><name>long</name></type> <name>dataPosition</name> <init>= <expr><call><name><name>input</name>.<name>readLong</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>decoratedKey</name> != null</expr>)</condition><then>
                <block>{
                    <if>if <condition>(<expr><name>recreatebloom</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>bf</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>decoratedKey</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <if>if <condition>(<expr><name>shouldAddEntry</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>indexSummary</name>.<name>addEntry</name></name><argument_list>(<argument><expr><name>decoratedKey</name></expr></argument>, <argument><expr><name>indexPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    <comment type="line">// if key cache could be used and we have key already pre-loaded</comment>
                    <if>if <condition>(<expr><name>cacheLoading</name> &amp;&amp; <call><name><name>keysToLoadInCache</name>.<name>contains</name></name><argument_list>(<argument><expr><name>decoratedKey</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name>cacheKey</name><argument_list>(<argument><expr><name>decoratedKey</name></expr></argument>, <argument><expr><name>dataPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></then></if>

                <expr_stmt><expr><call><name><name>indexSummary</name>.<name>incrementRowid</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>ibuilder</name>.<name>addPotentialBoundary</name></name><argument_list>(<argument><expr><name>indexPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>dbuilder</name>.<name>addPotentialBoundary</name></name><argument_list>(<argument><expr><name>dataPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><call><name><name>indexSummary</name>.<name>complete</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>FileUtils</name>.<name>closeQuietly</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
        <expr_stmt><expr><name><name>this</name>.<name>first</name></name> = <call><name>getMinimalKey</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>last</name></name> = <call><name>getMinimalKey</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// finalize the state of the reader</comment>
        <expr_stmt><expr><name>ifile</name> = <call><name><name>ibuilder</name>.<name>complete</name></name><argument_list>(<argument><expr><call><name><name>descriptor</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>PRIMARY_INDEX</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dfile</name> = <call><name><name>dbuilder</name>.<name>complete</name></name><argument_list>(<argument><expr><call><name><name>descriptor</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>DATA</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>validate</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>this</name>.<name>first</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>last</name></name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"SSTable first key %s &gt; last key %s"</expr></argument>, <argument><expr><name><name>this</name>.<name>first</name></name></expr></argument>, <argument><expr><name><name>this</name>.<name>last</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/** get the position in the index file to start scanning to find the given key (at most indexInterval keys away) */</comment>
    <function><type><specifier>private</specifier> <name>long</name></type> <name>getIndexScanPosition</name><parameter_list>(<param><decl><type><name>RowPosition</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><call><name><name>indexSummary</name>.<name>getKeys</name></name><argument_list>()</argument_list></call> != null &amp;&amp; <call><name><name>indexSummary</name>.<name>getKeys</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> &gt; 0</expr>;</assert>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><call><name><name>Collections</name>.<name>binarySearch</name></name><argument_list>(<argument><expr><call><name><name>indexSummary</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index</name> &lt; 0</expr>)</condition><then>
        <block>{
            <comment type="line">// binary search gives us the first index _greater_ than the key searched for,</comment>
            <comment type="line">// i.e., its insertion position</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>greaterThan</name> <init>= <expr>(<name>index</name> + 1) * -1</expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>greaterThan</name> == 0</expr>)</condition><then>
                <return>return <expr>-1</expr>;</return></then></if>
            <return>return <expr><call><name><name>indexSummary</name>.<name>getPosition</name></name><argument_list>(<argument><expr><name>greaterThan</name> - 1</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
        <else>else
        <block>{
            <return>return <expr><call><name><name>indexSummary</name>.<name>getPosition</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Returns the compression metadata for this sstable.
     * @throws IllegalStateException if the sstable is not compressed
     */</comment>
    <function><type><specifier>public</specifier> <name>CompressionMetadata</name></type> <name>getCompressionMetadata</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<name>compression</name></expr>)</condition><then>
            <throw>throw <expr>new <call><name>IllegalStateException</name><argument_list>(<argument><expr><name>this</name> + " is not compressed"</expr></argument>)</argument_list></call></expr>;</throw></then></if>

        <return>return <expr>((<name>CompressedSegmentedFile</name>)<name>dfile</name>).<name>metadata</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * For testing purposes only.
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceFilterFailures</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><name>bf</name> = <call><name><name>LegacyBloomFilter</name>.<name>alwaysMatchingBloomFilter</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>Filter</name></type> <name>getBloomFilter</name><parameter_list>()</parameter_list>
    <block>{
      <return>return <expr><name>bf</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getBloomFilterSerializedSize</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><name><name>descriptor</name>.<name>usesOldBloomFilter</name></name></expr>)</condition><then>
            <return>return <expr><call><name><name>LegacyBloomFilter</name>.<name>serializer</name></name><argument_list>()</argument_list></call>.<call><name>serializedSize</name><argument_list>(<argument><expr>(<name>LegacyBloomFilter</name>) <name>bf</name></expr></argument>)</argument_list></call></expr>;</return></then>
        <else>else
            <return>return <expr><call><name><name>BloomFilter</name>.<name>serializer</name></name><argument_list>()</argument_list></call>.<call><name>serializedSize</name><argument_list>(<argument><expr>(<name>BloomFilter</name>) <name>bf</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return An estimate of the number of keys in this SSTable.
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>estimatedKeys</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>indexSummary</name>.<name>getKeys</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call> * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param ranges
     * @return An estimate of the number of keys for given ranges in this SSTable.
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>estimatedKeysForRanges</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>sampleKeyCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>sampleIndexes</name> <init>= <expr><call><name>getSampleIndexesForRanges</name><argument_list>(<argument><expr><call><name><name>indexSummary</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>sampleIndexRange</name> <range>: <expr><name>sampleIndexes</name></expr></range></decl></init>)
            <expr_stmt><expr><name>sampleKeyCount</name> += (<name><name>sampleIndexRange</name>.<name>right</name></name> - <name><name>sampleIndexRange</name>.<name>left</name></name> + 1)</expr>;</expr_stmt></for>
        <return>return <expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>sampleKeyCount</name> * <call><name><name>DatabaseDescriptor</name>.<name>getIndexInterval</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return Approximately 1/INDEX_INTERVALth of the keys in this SSTable.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getKeySamples</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>indexSummary</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>,<argument><name>Integer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getSampleIndexesForRanges</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>samples</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// use the index to determine a minimal section for each range</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>,<argument><name>Integer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>positions</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>,<argument><name>Integer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>samples</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>positions</name></expr>;</return></then></if>

        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name><name>Range</name>.<name>normalize</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>RowPosition</name></type> <name>leftPosition</name> <init>= <expr><call><name><name>range</name>.<name>left</name>.<name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>RowPosition</name></type> <name>rightPosition</name> <init>= <expr><call><name><name>range</name>.<name>right</name>.<name>maxKeyBound</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><call><name><name>Collections</name>.<name>binarySearch</name></name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><name>leftPosition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>left</name> &lt; 0</expr>)</condition><then>
                <expr_stmt><expr><name>left</name> = (<name>left</name> + 1) * -1</expr>;</expr_stmt></then>
            <else>else
                <comment type="line">// left range are start exclusive</comment>
                <expr_stmt><expr><name>left</name> = <name>left</name> + 1</expr>;</expr_stmt></else></if>
            <if>if <condition>(<expr><name>left</name> == <call><name><name>samples</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <comment type="line">// left is past the end of the sampling</comment>
                <continue>continue;</continue></then></if>

            <decl_stmt><decl><type><name>int</name></type> <name>right</name> <init>= <expr><call><name><name>Range</name>.<name>isWrapAround</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call>
                      ? <call><name><name>samples</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1
                      : <call><name><name>Collections</name>.<name>binarySearch</name></name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><name>rightPosition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>right</name> &lt; 0</expr>)</condition><then>
            <block>{
                <comment type="line">// range are end inclusive so we use the previous index from what binarySearch give us</comment>
                <comment type="line">// since that will be the last index we will return</comment>
                <expr_stmt><expr><name>right</name> = (<name>right</name> + 1) * -1</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>right</name> == 0</expr>)</condition><then>
                    <comment type="line">// Means the first key is already stricly greater that the right bound</comment>
                    <continue>continue;</continue></then></if>
                <expr_stmt><expr><name>right</name>--</expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>left</name> &gt; <name>right</name></expr>)</condition><then>
                <comment type="line">// empty range</comment>
                <continue>continue;</continue></then></if>
            <expr_stmt><expr><call><name><name>positions</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>Pair</name><argument_list>(<argument><expr><call><name><name>Integer</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Integer</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>positions</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getKeySamples</name><parameter_list>(<param><decl><type><specifier>final</specifier> <name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>samples</name> <init>= <expr><call><name><name>indexSummary</name>.<name>getKeys</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>indexRanges</name> <init>= <expr><call><name>getSampleIndexesForRanges</name><argument_list>(<argument><expr><name>samples</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>indexRanges</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>Collections</name>.<name>emptyList</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <return>return <expr>new <class><super><name><name>Iterable</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
        <block>{
            <function><type><specifier>public</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>iterator</name><parameter_list>()</parameter_list>
            <block>{
                <return>return <expr>new <class><super><name><name>Iterator</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></super><argument_list>()</argument_list>
                <block>{
                    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Iterator</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>rangeIter</name> <init>= <expr><call><name><name>indexRanges</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>private</specifier> <name><name>Pair</name><argument_list>&lt;<argument><name>Integer</name></argument>, <argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>current</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><specifier>private</specifier> <name>int</name></type> <name>idx</name></decl>;</decl_stmt>

                    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasNext</name><parameter_list>()</parameter_list>
                    <block>{
                        <if>if <condition>(<expr><name>current</name> == null || <name>idx</name> &gt; <name><name>current</name>.<name>right</name></name></expr>)</condition><then>
                        <block>{
                            <if>if <condition>(<expr><call><name><name>rangeIter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <block>{
                                <expr_stmt><expr><name>current</name> = <call><name><name>rangeIter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>idx</name> = <name><name>current</name>.<name>left</name></name></expr>;</expr_stmt>
                                <return>return <expr>true</expr>;</return>
                            }</block></then></if>
                            <return>return <expr>false</expr>;</return>
                        }</block></then></if>

                        <return>return <expr>true</expr>;</return>
                    }</block></function>

                    <function><type><specifier>public</specifier> <name>DecoratedKey</name></type> <name>next</name><parameter_list>()</parameter_list>
                    <block>{
                        <decl_stmt><decl><type><name>RowPosition</name></type> <name>k</name> <init>= <expr><call><name><name>samples</name>.<name>get</name></name><argument_list>(<argument><expr><name>idx</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <comment type="line">// the index should only contain valid row key, we only allow RowPosition in KeyPosition for search purposes</comment>
                        <assert>assert <expr><name>k</name> instanceof <name>DecoratedKey</name></expr>;</assert>
                        <return>return <expr>(<name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name>)<name>k</name></expr>;</return>
                    }</block></function>

                    <function><type><specifier>public</specifier> <name>void</name></type> <name>remove</name><parameter_list>()</parameter_list>
                    <block>{
                        <throw>throw <expr>new <call><name>UnsupportedOperationException</name><argument_list>()</argument_list></call></expr>;</throw>
                    }</block></function>
                }</block></class></expr>;</return>
            }</block></function>
        }</block></class></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Determine the minimal set of sections that can be extracted from this SSTable to cover the given ranges.
     * @return A sorted list of (offset,end) pairs that cover the given ranges in the datafile for this SSTable.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Long</name></argument>,<argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>getPositionsForRanges</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// use the index to determine a minimal section for each range</comment>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Long</name></argument>,<argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>positions</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Long</name></argument>,<argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name> <range>: <expr><call><name><name>Range</name>.<name>normalize</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>keyRange</name> <init>= <expr><call><name><name>range</name>.<name>toRowBounds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>left</name> <init>= <expr><call><name>getPosition</name><argument_list>(<argument><expr><name><name>keyRange</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>Operator</name>.<name>GT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>left</name> == -1</expr>)</condition><then>
                <comment type="line">// left is past the end of the file</comment>
                <continue>continue;</continue></then></if>
            <decl_stmt><decl><type><name>long</name></type> <name>right</name> <init>= <expr><call><name>getPosition</name><argument_list>(<argument><expr><name><name>keyRange</name>.<name>right</name></name></expr></argument>, <argument><expr><name><name>Operator</name>.<name>GT</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>right</name> == -1 || <call><name><name>Range</name>.<name>isWrapAround</name></name><argument_list>(<argument><expr><name><name>range</name>.<name>left</name></name></expr></argument>, <argument><expr><name><name>range</name>.<name>right</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <comment type="line">// right is past the end of the file, or it wraps</comment>
                <expr_stmt><expr><name>right</name> = <call><name>uncompressedLength</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr><name>left</name> == <name>right</name></expr>)</condition><then>
                <comment type="line">// empty range</comment>
                <continue>continue;</continue></then></if>
            <expr_stmt><expr><call><name><name>positions</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>Pair</name><argument_list>(<argument><expr><call><name><name>Long</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Long</name>.<name>valueOf</name></name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><name>positions</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>cacheKey</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>Long</name></type> <name>info</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>CFMetaData</name>.<name>Caching</name></name></type> <name>caching</name> <init>= <expr><call><name><name>metadata</name>.<name>getCaching</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>keyCache</name> == null
                || <name>caching</name> == <name><name>CFMetaData</name>.<name>Caching</name>.<name>NONE</name></name>
                || <name>caching</name> == <name><name>CFMetaData</name>.<name>Caching</name>.<name>ROWS_ONLY</name></name>
                || <call><name><name>keyCache</name>.<name>getCapacity</name></name><argument_list>()</argument_list></call> == 0</expr>)</condition><then>
            <return>return;</return></then></if>

        <comment type="line">// avoid keeping a permanent reference to the original key buffer</comment>
        <decl_stmt><decl><type><name>KeyCacheKey</name></type> <name>cacheKey</name> <init>= <expr>new <call><name>KeyCacheKey</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><call><name><name>ByteBufferUtil</name>.<name>clone</name></name><argument_list>(<argument><expr><name><name>key</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Adding cache entry for {} -&gt; {}"</expr></argument>, <argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>keyCache</name>.<name>put</name></name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>Long</name></type> <name>getCachedPosition</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>updateStats</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getCachedPosition</name><argument_list>(<argument><expr>new <call><name>KeyCacheKey</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name><name>key</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>updateStats</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>Long</name></type> <name>getCachedPosition</name><parameter_list>(<param><decl><type><name>KeyCacheKey</name></type> <name>unifiedKey</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>updateStats</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>keyCache</name> != null &amp;&amp; <call><name><name>keyCache</name>.<name>getCapacity</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
            <return>return <expr><name>updateStats</name> ? <call><name><name>keyCache</name>.<name>get</name></name><argument_list>(<argument><expr><name>unifiedKey</name></expr></argument>)</argument_list></call> : <call><name><name>keyCache</name>.<name>getInternal</name></name><argument_list>(<argument><expr><name>unifiedKey</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <return>return <expr>null</expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get position updating key cache and stats.
     * @see #getPosition(org.apache.cassandra.db.RowPosition, org.apache.cassandra.io.sstable.SSTableReader.Operator, boolean)
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getPosition</name><parameter_list>(<param><decl><type><name>RowPosition</name></type> <name>key</name></decl></param>, <param><decl><type><name>Operator</name></type> <name>op</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getPosition</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param key The key to apply as the rhs to the given Operator. A 'fake' key is allowed to
     * allow key selection by token bounds but only if op != * EQ
     * @param op The Operator defining matching keys: the nearest key to the target matching the operator wins.
     * @param updateCacheAndStats true if updating stats and cache
     * @return The position in the data file to find the key, or -1 if the key is not present
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getPosition</name><parameter_list>(<param><decl><type><name>RowPosition</name></type> <name>key</name></decl></param>, <param><decl><type><name>Operator</name></type> <name>op</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>updateCacheAndStats</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// first, check bloom filter</comment>
        <if>if <condition>(<expr><name>op</name> == <name><name>Operator</name>.<name>EQ</name></name></expr>)</condition><then>
        <block>{
            <assert>assert <expr><name>key</name> instanceof <name>DecoratedKey</name></expr>;</assert> <comment type="line">// EQ only make sense if the key is a valid row key</comment>
            <if>if <condition>(<expr>!<call><name><name>bf</name>.<name>isPresent</name></name><argument_list>(<argument><expr>((<name>DecoratedKey</name>)<name>key</name>).<name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>-1</expr>;</return></then></if>
        }</block></then></if>

        <comment type="line">// next, the key cache (only make sense for valid row key)</comment>
        <if>if <condition>(<expr>(<name>op</name> == <name><name>Operator</name>.<name>EQ</name></name> || <name>op</name> == <name><name>Operator</name>.<name>GE</name></name>) &amp;&amp; (<name>key</name> instanceof <name>DecoratedKey</name>)</expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>decoratedKey</name> <init>= <expr>(<name>DecoratedKey</name>)<name>key</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>KeyCacheKey</name></type> <name>cacheKey</name> <init>= <expr>new <call><name>KeyCacheKey</name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name><name>decoratedKey</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>Long</name></type> <name>cachedPosition</name> <init>= <expr><call><name>getCachedPosition</name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><name>updateCacheAndStats</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cachedPosition</name> != null</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>trace</name></name><argument_list>(<argument><expr>"Cache hit for {} -&gt; {}"</expr></argument>, <argument><expr><name>cacheKey</name></expr></argument>, <argument><expr><name>cachedPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>cachedPosition</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <comment type="line">// next, see if the sampled index says it's impossible for the key to be present</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>sampledPosition</name> <init>= <expr><call><name>getIndexScanPosition</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>sampledPosition</name> == -1</expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name>op</name> == <name><name>Operator</name>.<name>EQ</name></name> &amp;&amp; <name>updateCacheAndStats</name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>bloomFilterTracker</name>.<name>addFalsePositive</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            <comment type="line">// we matched the -1th position: if the operator might match forward, return the 0th position</comment>
            <return>return <expr><call><name><name>op</name>.<name>apply</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call> &gt;= 0 ? 0 : -1</expr>;</return>
        }</block></then></if>

        <comment type="line">// scan the on-disk index, starting at the nearest sampled position</comment>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>FileDataInput</name></argument>&gt;</argument_list></name></type> <name>segments</name> <init>= <expr><call><name><name>ifile</name>.<name>iterator</name></name><argument_list>(<argument><expr><name>sampledPosition</name></expr></argument>, <argument><expr><name>INDEX_FILE_BUFFER_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>segments</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>FileDataInput</name></type> <name>input</name> <init>= <expr><call><name><name>segments</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <try>try
            <block>{
                <while>while <condition>(<expr>!<call><name><name>input</name>.<name>isEOF</name></name><argument_list>()</argument_list></call></expr>)</condition>
                <block>{
                    <comment type="line">// read key &amp; data position from index entry</comment>
                    <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>indexDecoratedKey</name> <init>= <expr><call><name>decodeKey</name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>descriptor</name></expr></argument>, <argument><expr><call><name><name>ByteBufferUtil</name>.<name>readWithShortLength</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>long</name></type> <name>dataPosition</name> <init>= <expr><call><name><name>input</name>.<name>readLong</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

                    <decl_stmt><decl><type><name>int</name></type> <name>comparison</name> <init>= <expr><call><name><name>indexDecoratedKey</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name><name>op</name>.<name>apply</name></name><argument_list>(<argument><expr><name>comparison</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>v</name> == 0</expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>comparison</name> == 0</expr>)</condition><then>
                        <block>{
                            <assert>assert <expr><name>key</name> instanceof <name>DecoratedKey</name></expr>;</assert> <comment type="line">// key can be == to the index key only if it's a true row key</comment>
                            <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>decoratedKey</name> <init>= <expr>(<name>DecoratedKey</name>)<name>key</name></expr></init></decl>;</decl_stmt>

                            <if>if <condition>(<expr><call><name><name>logger</name>.<name>isTraceEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                            <block>{
                                <comment type="line">// expensive sanity check!  see CASSANDRA-4687</comment>
                                <decl_stmt><decl><type><name>FileDataInput</name></type> <name>fdi</name> <init>= <expr><call><name><name>dfile</name>.<name>getSegment</name></name><argument_list>(<argument><expr><name>dataPosition</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>keyInDisk</name> <init>= <expr><call><name><name>SSTableReader</name>.<name>decodeKey</name></name><argument_list>(<argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>descriptor</name></expr></argument>, <argument><expr><call><name><name>ByteBufferUtil</name>.<name>readWithShortLength</name></name><argument_list>(<argument><expr><name>fdi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                                <if>if <condition>(<expr>!<call><name><name>keyInDisk</name>.<name>equals</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                                    <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"%s != %s in %s"</expr></argument>, <argument><expr><name>keyInDisk</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name><name>fdi</name>.<name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
                                <expr_stmt><expr><call><name><name>fdi</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>

                            <if>if <condition>(<expr><name>keyCache</name> != null &amp;&amp; <call><name><name>keyCache</name>.<name>getCapacity</name></name><argument_list>()</argument_list></call> &gt; 0 &amp;&amp; <name>updateCacheAndStats</name></expr>)</condition><then>
                            <block>{
                                <comment type="line">// store exact match for the key</comment>
                                <expr_stmt><expr><call><name>cacheKey</name><argument_list>(<argument><expr><name>decoratedKey</name></expr></argument>, <argument><expr><name>dataPosition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></then></if>
                        <if>if <condition>(<expr><name>op</name> == <name><name>Operator</name>.<name>EQ</name></name> &amp;&amp; <name>updateCacheAndStats</name></expr>)</condition><then>
                            <expr_stmt><expr><call><name><name>bloomFilterTracker</name>.<name>addTruePositive</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                        <return>return <expr><name>dataPosition</name></expr>;</return>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>v</name> &lt; 0</expr>)</condition><then>
                    <block>{
                        <if>if <condition>(<expr><name>op</name> == <name><name>Operator</name>.<name>EQ</name></name> &amp;&amp; <name>updateCacheAndStats</name></expr>)</condition><then>
                            <expr_stmt><expr><call><name><name>bloomFilterTracker</name>.<name>addFalsePositive</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                        <return>return <expr>-1</expr>;</return>
                    }</block></then></if>
                }</block></while>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name>markSuspect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch>
            <finally>finally
            <block>{
                <expr_stmt><expr><call><name><name>FileUtils</name>.<name>closeQuietly</name></name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></while>

        <if>if <condition>(<expr><name>op</name> == <name><name>Operator</name>.<name>EQ</name></name> &amp;&amp; <name>updateCacheAndStats</name></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>bloomFilterTracker</name>.<name>addFalsePositive</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>-1</expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return The length in bytes of the data for this SSTable. For
     * compressed files, this is not the same thing as the on disk size (see
     * onDiskLength())
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>uncompressedLength</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>dfile</name>.<name>length</name></name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return The length in bytes of the on disk size for this SSTable. For
     * compressed files, this is not the same thing as the data length (see
     * length())
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>onDiskLength</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>dfile</name>.<name>onDiskLength</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>acquireReference</name><parameter_list>()</parameter_list>
    <block>{
        <while>while <condition>(<expr>true</expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name><name>references</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>n</name> &lt;= 0</expr>)</condition><then>
                <return>return <expr>false</expr>;</return></then></if>
            <if>if <condition>(<expr><call><name><name>references</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>true</expr>;</return></then></if>
        }</block></while>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>releaseReference</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>references</name>.<name>decrementAndGet</name></name><argument_list>()</argument_list></call> == 0 &amp;&amp; <call><name><name>isCompacted</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// Force finalizing mmapping if necessary</comment>
            <expr_stmt><expr><call><name><name>ifile</name>.<name>cleanup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>dfile</name>.<name>cleanup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>deletingTask</name>.<name>schedule</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <assert>assert <expr><call><name><name>references</name>.<name>get</name></name><argument_list>()</argument_list></call> &gt;= 0 : "Reference counter " +  <call><name><name>references</name>.<name>get</name></name><argument_list>()</argument_list></call> + " for " + <name><name>dfile</name>.<name>path</name></name></expr>;</assert>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Mark the sstable as compacted.
     * When calling this function, the caller must ensure that the SSTableReader is not referenced anywhere
     * except for threads holding a reference.
     *
     * @return true if the this is the first time the file was marked compacted.  With rare exceptions
     * (see DataTracker.unmarkCompacted) calling this multiple times would be buggy.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>markCompacted</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Marking " + <call><name>getFilename</name><argument_list>()</argument_list></call> + " compacted"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <return>return <expr>!<call><name><name>isCompacted</name>.<name>getAndSet</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>markSuspect</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Marking " + <call><name>getFilename</name><argument_list>()</argument_list></call> + " as a suspect for blacklisting."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name><name>isSuspect</name>.<name>getAndSet</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isMarkedSuspect</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>isSuspect</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     *
     * @param filter filter to use when reading the columns
     * @return A Scanner for seeking over the rows of the SSTable.
     */</comment>
    <function><type><specifier>public</specifier> <name>SSTableScanner</name></type> <name>getScanner</name><parameter_list>(<param><decl><type><name>QueryFilter</name></type> <name>filter</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr>new <call><name>SSTableScanner</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

   <comment type="block" format="javadoc">/**
    * Direct I/O SSTableScanner
    * @return A Scanner for seeking over the rows of the SSTable.
    */</comment>
    <function><type><specifier>public</specifier> <name>SSTableScanner</name></type> <name>getDirectScanner</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>new <call><name>SSTableScanner</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

   <comment type="block" format="javadoc">/**
    * Direct I/O SSTableScanner over a defined range of tokens.
    *
    * @param range the range of keys to cover
    * @return A Scanner for seeking over the rows of the SSTable.
    */</comment>
    <function><type><specifier>public</specifier> <name>SSTableScanner</name></type> <name>getDirectScanner</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>range</name> == null</expr>)</condition><then>
            <return>return <expr><call><name>getDirectScanner</name><argument_list>()</argument_list></call></expr>;</return></then></if>
        <return>return <expr>new <call><name>SSTableBoundedScanner</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>true</expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>FileDataInput</name></type> <name>getFileDataInput</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>decoratedKey</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>position</name> <init>= <expr><call><name>getPosition</name><argument_list>(<argument><expr><name>decoratedKey</name></expr></argument>, <argument><expr><name><name>Operator</name>.<name>EQ</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>position</name> &lt; 0</expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if>

        <return>return <expr><call><name><name>dfile</name>.<name>getSegment</name></name><argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Tests if the sstable contains data newer than the given age param (in localhost currentMilli time).
     * This works in conjunction with maxDataAge which is an upper bound on the create of data in this sstable.
     * @param age The age to compare the maxDataAre of this sstable. Measured in millisec since epoc on this host
     * @return True iff this sstable contains data that's newer than the given age parameter.
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>newSince</name><parameter_list>(<param><decl><type><name>long</name></type> <name>age</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><name>maxDataAge</name> &gt; <name>age</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>long</name></type> <name>readRowSize</name><parameter_list>(<param><decl><type><name>DataInput</name></type> <name>in</name></decl></param>, <param><decl><type><name>Descriptor</name></type> <name>d</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <if>if <condition>(<expr><name><name>d</name>.<name>hasIntRowSize</name></name></expr>)</condition><then>
            <return>return <expr><call><name><name>in</name>.<name>readInt</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>
        <return>return <expr><call><name><name>in</name>.<name>readLong</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>createLinks</name><parameter_list>(<param><decl><type><name>String</name></type> <name>snapshotDirectoryPath</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>Component</name></type> <name>component</name> <range>: <expr><name>components</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>File</name></type> <name>sourceFile</name> <init>= <expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>descriptor</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>File</name></type> <name>targetLink</name> <init>= <expr>new <call><name>File</name><argument_list>(<argument><expr><name>snapshotDirectoryPath</name></expr></argument>, <argument><expr><call><name><name>sourceFile</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>CLibrary</name>.<name>createHardLink</name></name><argument_list>(<argument><expr><name>sourceFile</name></expr></argument>, <argument><expr><name>targetLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Conditionally use the deprecated 'IPartitioner.convertFromDiskFormat' method.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>DecoratedKey</name></type> <name>decodeKey</name><parameter_list>(<param><decl><type><name>IPartitioner</name></type> <name>p</name></decl></param>, <param><decl><type><name>Descriptor</name></type> <name>d</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>bytes</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name><name>d</name>.<name>hasEncodedKeys</name></name></expr>)</condition><then>
            <return>return <expr><call><name><name>p</name>.<name>convertFromDiskFormat</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <return>return <expr><call><name><name>p</name>.<name>decorateKey</name></name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * TODO: Move someplace reusable
     */</comment>
    <class><specifier>public</specifier> <specifier>abstract</specifier> <specifier>static</specifier> class <name>Operator</name>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Operator</name></type> <name>EQ</name> <init>= <expr>new <call><name>Equals</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Operator</name></type> <name>GE</name> <init>= <expr>new <call><name>GreaterThanOrEqualTo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>Operator</name></type> <name>GT</name> <init>= <expr>new <call><name>GreaterThan</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block" format="javadoc">/**
         * @param comparison The result of a call to compare/compareTo, with the desired field on the rhs.
         * @return less than 0 if the operator cannot match forward, 0 if it matches, greater than 0 if it might match forward.
         */</comment>
        <function_decl><type><specifier>public</specifier> <specifier>abstract</specifier> <name>int</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>int</name></type> <name>comparison</name></decl></param>)</parameter_list>;</function_decl>

        <class><specifier>final</specifier> <specifier>static</specifier> class <name>Equals</name> <super><extends>extends <name>Operator</name></extends></super>
        <block>{
            <function><type><specifier>public</specifier> <name>int</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>int</name></type> <name>comparison</name></decl></param>)</parameter_list> <block>{ <return>return <expr>-<name>comparison</name></expr>;</return> }</block></function>
        }</block></class>

        <class><specifier>final</specifier> <specifier>static</specifier> class <name>GreaterThanOrEqualTo</name> <super><extends>extends <name>Operator</name></extends></super>
        <block>{
            <function><type><specifier>public</specifier> <name>int</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>int</name></type> <name>comparison</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name>comparison</name> &gt;= 0 ? 0 : -<name>comparison</name></expr>;</return> }</block></function>
        }</block></class>

        <class><specifier>final</specifier> <specifier>static</specifier> class <name>GreaterThan</name> <super><extends>extends <name>Operator</name></extends></super>
        <block>{
            <function><type><specifier>public</specifier> <name>int</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>int</name></type> <name>comparison</name></decl></param>)</parameter_list> <block>{ <return>return <expr><name>comparison</name> &gt; 0 ? 0 : 1</expr>;</return> }</block></function>
        }</block></class>
    }</block></class>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getBloomFilterFalsePositiveCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>bloomFilterTracker</name>.<name>getFalsePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getRecentBloomFilterFalsePositiveCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>bloomFilterTracker</name>.<name>getRecentFalsePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getBloomFilterTruePositiveCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>bloomFilterTracker</name>.<name>getTruePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getRecentBloomFilterTruePositiveCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>bloomFilterTracker</name>.<name>getRecentTruePositiveCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>InstrumentingCache</name><argument_list>&lt;<argument><name>KeyCacheKey</name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>getKeyCache</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>keyCache</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>EstimatedHistogram</name></type> <name>getEstimatedRowSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>sstableMetadata</name>.<name>estimatedRowSize</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>EstimatedHistogram</name></type> <name>getEstimatedColumnCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>sstableMetadata</name>.<name>estimatedColumnCount</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getCompressionRatio</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>sstableMetadata</name>.<name>compressionRatio</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>ReplayPosition</name></type> <name>getReplayPosition</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>sstableMetadata</name>.<name>replayPosition</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMaxTimestamp</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>sstableMetadata</name>.<name>maxTimestamp</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>getAncestors</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>sstableMetadata</name>.<name>ancestors</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>RandomAccessReader</name></type> <name>openDataReader</name><parameter_list>(<param><decl><type><name>boolean</name></type> <name>skipIOCache</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <return>return <expr><name>compression</name>
               ? <call><name><name>CompressedRandomAccessReader</name>.<name>open</name></name><argument_list>(<argument><expr><call><name>getFilename</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getCompressionMetadata</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>skipIOCache</name></expr></argument>)</argument_list></call>
               : <call><name><name>RandomAccessReader</name>.<name>open</name></name><argument_list>(<argument><expr>new <call><name>File</name><argument_list>(<argument><expr><call><name>getFilename</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skipIOCache</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param sstables
     * @return true if all desired references were acquired.  Otherwise, it will unreference any partial acquisition, and return false.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>boolean</name></type> <name>acquireReferences</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>SSTableReader</name></type> <name>failed</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr>!<call><name><name>sstable</name>.<name>acquireReference</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>failed</name> = <name>sstable</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>

        <if>if <condition>(<expr><name>failed</name> == null</expr>)</condition><then>
            <return>return <expr>true</expr>;</return></then></if>

        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><name>sstable</name> == <name>failed</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <expr_stmt><expr><call><name><name>sstable</name>.<name>releaseReference</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr>false</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>releaseReferences</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>sstable</name>.<name>releaseReference</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>ex</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>error</name></name><argument_list>(<argument><expr>"Failed releasing reference on " + <name>sstable</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></catch></try>
        }</block></for>
    }</block></function>
}</block></class>
</unit>
