<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" language="Java" filename="C:\Users\mrahimi1\Desktop\FSE-2015-LinkEvolution\srcML-Win\srcML-Win\cassandra-cassandra-1.1.12\src\java\org\apache\cassandra\db\ColumnFamilyStore.java"><comment type="block" format="javadoc">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<package>package <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name></name>;</package>

<import>import <name><name>java</name>.<name>io</name>.<name>File</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOError</name></name>;</import>
<import>import <name><name>java</name>.<name>io</name>.<name>IOException</name></name>;</import>
<import>import <name><name>java</name>.<name>lang</name>.<name>management</name>.<name>ManagementFactory</name></name>;</import>
<import>import <name><name>java</name>.<name>nio</name>.<name>ByteBuffer</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name></name>.*;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicInteger</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>concurrent</name>.<name>atomic</name>.<name>AtomicLong</name></name>;</import>
<import>import <name><name>java</name>.<name>util</name>.<name>regex</name>.<name>Pattern</name></name>;</import>
<import>import <name><name>javax</name>.<name>management</name></name>.*;</import>

<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>collect</name></name>.*;</import>
<import>import <name><name>com</name>.<name>google</name>.<name>common</name>.<name>util</name>.<name>concurrent</name>.<name>Futures</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>Logger</name></name>;</import>
<import>import <name><name>org</name>.<name>slf4j</name>.<name>LoggerFactory</name></name>;</import>

<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cache</name>.<name>AutoSavingCache</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cache</name>.<name>IRowCacheEntry</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cache</name>.<name>RowCacheKey</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>cache</name>.<name>RowCacheSentinel</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>JMXEnabledThreadPoolExecutor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>NamedThreadFactory</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>concurrent</name>.<name>StageManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>columniterator</name>.<name>IColumnIterator</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>commitlog</name>.<name>CommitLog</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>commitlog</name>.<name>ReplayPosition</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>AbstractCompactionStrategy</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>CompactionManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>LeveledCompactionStrategy</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>ExtendedFilter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>compaction</name>.<name>OperationType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>IFilter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>QueryFilter</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>filter</name>.<name>QueryPath</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>index</name>.<name>SecondaryIndex</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>index</name>.<name>SecondaryIndexManager</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>db</name>.<name>marshal</name>.<name>AbstractType</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>dht</name>.<name>Range</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>compress</name>.<name>CompressionParameters</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>sstable</name>.<name>Descriptor</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>io</name>.<name>util</name>.<name>FileUtils</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>CacheService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>service</name>.<name>StorageService</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>thrift</name>.<name>IndexExpression</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name></name>.*;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>IntervalTree</name>.<name>Interval</name></name>;</import>
<import>import <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>utils</name>.<name>IntervalTree</name>.<name>IntervalTree</name></name>;</import>
<import>import <name><name>org</name>.<name>cliffc</name>.<name>high_scale_lib</name>.<name>NonBlockingHashMap</name></name>;</import>

<import>import static <name><name>org</name>.<name>apache</name>.<name>cassandra</name>.<name>config</name>.<name>CFMetaData</name>.<name>Caching</name></name>;</import>

<class><specifier>public</specifier> class <name>ColumnFamilyStore</name> <super><implements>implements <name>ColumnFamilyStoreMBean</name></implements></super>
<block>{
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <name>Logger</name></type> <name>logger</name> <init>= <expr><call><name><name>LoggerFactory</name>.<name>getLogger</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name>.<name>class</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * maybeSwitchMemtable puts Memtable.getSortedContents on the writer executor.  When the write is complete,
     * we turn the writer into an SSTableReader and add it to ssTables_ where it is available for reads.
     *
     * There are two other things that maybeSwitchMemtable does.
     * First, it puts the Memtable into memtablesPendingFlush, where it stays until the flush is complete
     * and it's been added as an SSTableReader to ssTables_.  Second, it adds an entry to commitLogUpdater
     * that waits for the flush to complete, then calls onMemtableFlush.  This allows multiple flushes
     * to happen simultaneously on multicore systems, while still calling onMF in the correct order,
     * which is necessary for replay in case of a restart since CommitLog assumes that when onMF is
     * called, all data up to the given context has been persisted to SSTables.
     */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ExecutorService</name></type> <name>flushWriter</name>
            <init>= <expr>new <call><name>JMXEnabledThreadPoolExecutor</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getFlushWriters</name></name><argument_list>()</argument_list></call></expr></argument>,
                                               <argument><expr><name><name>StageManager</name>.<name>KEEPALIVE</name></name></expr></argument>,
                                               <argument><expr><name><name>TimeUnit</name>.<name>SECONDS</name></name></expr></argument>,
                                               <argument><expr>new <call><name><name>LinkedBlockingQueue</name><argument_list>&lt;<argument><name>Runnable</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getFlushQueueSize</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr>new <call><name>NamedThreadFactory</name><argument_list>(<argument><expr>"FlushWriter"</expr></argument>)</argument_list></call></expr></argument>,
                                               <argument><expr>"internal"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>ExecutorService</name></type> <name>postFlushExecutor</name> <init>= <expr>new <call><name>JMXEnabledThreadPoolExecutor</name><argument_list>(<argument><expr>"MemtablePostFlusher"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Table</name></type> <name>table</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>String</name></type> <name>columnFamily</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>CFMetaData</name></type> <name>metadata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>IPartitioner</name></type> <name>partitioner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>String</name></type> <name>mbeanName</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>boolean</name></type> <name>valid</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Memtables and SSTables on disk for this column family */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>DataTracker</name></type> <name>data</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>memtableSwitchCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* This is used to generate the next index for a SSTable */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <name>AtomicInteger</name></type> <name>fileIndexGenerator</name> <init>= <expr>new <call><name>AtomicInteger</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>SecondaryIndexManager</name></type> <name>indexManager</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <name>LatencyTracker</name></type> <name>readStats</name> <init>= <expr>new <call><name>LatencyTracker</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <name>LatencyTracker</name></type> <name>writeStats</name> <init>= <expr>new <call><name>LatencyTracker</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="line">// counts of sstables accessed by reads</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>EstimatedHistogram</name></type> <name>recentSSTablesPerRead</name> <init>= <expr>new <call><name>EstimatedHistogram</name><argument_list>(<argument><expr>35</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>EstimatedHistogram</name></type> <name>sstablesPerRead</name> <init>= <expr>new <call><name>EstimatedHistogram</name><argument_list>(<argument><expr>35</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>private</specifier> <specifier>static</specifier> <specifier>final</specifier> <name>int</name></type> <name>INTERN_CUTOFF</name> <init>= <expr>256</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>ConcurrentMap</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>internedNames</name> <init>= <expr>new <call><name><name>NonBlockingHashMap</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>, <argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* These are locally held copies to be changed from the config during runtime */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>DefaultInteger</name></type> <name>minCompactionThreshold</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>DefaultInteger</name></type> <name>maxCompactionThreshold</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>volatile</specifier> <name>AbstractCompactionStrategy</name></type> <name>compactionStrategy</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name>Directories</name></type> <name>directories</name></decl>;</decl_stmt>

    <comment type="block" format="javadoc">/** ratio of in-memory memtable size, to serialized size */</comment>
    <decl_stmt><decl><type><specifier>volatile</specifier> <name>double</name></type> <name>liveRatio</name> <init>= <expr>1.0</expr></init></decl>;</decl_stmt>
    <comment type="block" format="javadoc">/** ops count last time we computed liveRatio */</comment>
    <decl_stmt><decl><type><specifier>private</specifier> <specifier>final</specifier> <name>AtomicLong</name></type> <name>liveRatioComputedAt</name> <init>= <expr>new <call><name>AtomicLong</name><argument_list>(<argument><expr>32</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>reload</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <comment type="line">// metadata object has been mutated directly. make all the members jibe with new settings.</comment>

        <comment type="line">// only update these runtime-modifiable settings if they have not been modified.</comment>
        <if>if <condition>(<expr>!<call><name><name>minCompactionThreshold</name>.<name>isModified</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><name><name>cfs</name>.<name>minCompactionThreshold</name></name> = new <call><name>DefaultInteger</name><argument_list>(<argument><expr><call><name><name>metadata</name>.<name>getMinCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>
        <if>if <condition>(<expr>!<call><name><name>maxCompactionThreshold</name>.<name>isModified</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><name><name>cfs</name>.<name>maxCompactionThreshold</name></name> = new <call><name>DefaultInteger</name><argument_list>(<argument><expr><call><name><name>metadata</name>.<name>getMaxCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>

        <expr_stmt><expr><call><name>maybeReloadCompactionStrategy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>indexManager</name>.<name>reload</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>maybeReloadCompactionStrategy</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// Check if there is a need for reloading</comment>
        <if>if <condition>(<expr><call><name><name>metadata</name>.<name>compactionStrategyClass</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>compactionStrategy</name>.<name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>metadata</name>.<name>compactionStrategyOptions</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>compactionStrategy</name>.<name>getOptions</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <comment type="line">// TODO is there a way to avoid locking here?</comment>
        <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>getCompactionLock</name></name><argument_list>()</argument_list></call>.<call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>compactionStrategy</name>.<name>shutdown</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>compactionStrategy</name> = <call><name><name>metadata</name>.<name>createCompactionStrategyInstance</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>getCompactionLock</name></name><argument_list>()</argument_list></call>.<call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactionStrategyClass</name><parameter_list>(<param><decl><type><name>String</name></type> <name>compactionStrategyClass</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><name><name>metadata</name>.<name>compactionStrategyClass</name></name> = <call><name><name>CFMetaData</name>.<name>createCompactionStrategy</name></name><argument_list>(<argument><expr><name>compactionStrategyClass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>maybeReloadCompactionStrategy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getCompactionStrategyClass</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>metadata</name>.<name>compactionStrategyClass</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getCompressionParameters</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>metadata</name>.<name>compressionParameters</name></name><argument_list>()</argument_list></call>.<call><name>asThriftOptions</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompressionParameters</name><parameter_list>(<param><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>String</name></argument>,<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>opts</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><name><name>metadata</name>.<name>compressionParameters</name></name> = <call><name><name>CompressionParameters</name>.<name>create</name></name><argument_list>(<argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCrcCheckChance</name><parameter_list>(<param><decl><type><name>double</name></type> <name>crcCheckChance</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ConfigurationException</name></expr></argument></throws>
    <block>{
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name><name>table</name>.<name>getAllSSTables</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <if>if <condition>(<expr><name><name>sstable</name>.<name>compression</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>sstable</name>.<name>getCompressionMetadata</name></name><argument_list>()</argument_list></call>.<call><name><name>parameters</name>.<name>setCrcCheckChance</name></name><argument_list>(<argument><expr><name>crcCheckChance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
    }</block></function>

    <constructor><specifier>private</specifier> <name>ColumnFamilyStore</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>,
                              <param><decl><type><name>String</name></type> <name>columnFamilyName</name></decl></param>,
                              <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>,
                              <param><decl><type><name>int</name></type> <name>generation</name></decl></param>,
                              <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>,
                              <param><decl><type><name>Directories</name></type> <name>directories</name></decl></param>,
                              <param><decl><type><name>boolean</name></type> <name>loadSSTables</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><name>metadata</name> != null : "null metadata for " + <name>table</name> + ":" + <name>columnFamilyName</name></expr>;</assert>

        <expr_stmt><expr><name><name>this</name>.<name>table</name></name> = <name>table</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>columnFamily</name> = <name>columnFamilyName</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>metadata</name></name> = <name>metadata</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>minCompactionThreshold</name></name> = new <call><name>DefaultInteger</name><argument_list>(<argument><expr><call><name><name>metadata</name>.<name>getMinCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>maxCompactionThreshold</name></name> = new <call><name>DefaultInteger</name><argument_list>(<argument><expr><call><name><name>metadata</name>.<name>getMaxCompactionThreshold</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>partitioner</name></name> = <name>partitioner</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>directories</name></name> = <name>directories</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>this</name>.<name>indexManager</name></name> = new <call><name>SecondaryIndexManager</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>fileIndexGenerator</name>.<name>set</name></name><argument_list>(<argument><expr><name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Caching</name></type> <name>caching</name> <init>= <expr><call><name><name>metadata</name>.<name>getCaching</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Starting CFS {}"</expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="line">// scan for sstables corresponding to this cf and load them</comment>
        <expr_stmt><expr><name>data</name> = new <call><name>DataTracker</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>DecoratedKey</name></argument>&gt;</argument_list></name></type> <name>savedKeys</name> <init>= <expr><name>caching</name> == <name><name>Caching</name>.<name>NONE</name></name> || <name>caching</name> == <name><name>Caching</name>.<name>ROWS_ONLY</name></name>
                                       ? <name><name>Collections</name>.</name>&lt;<name>DecoratedKey</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call>
                                       : <call><name><name>CacheService</name>.<name>instance</name>.<name>keyCache</name>.<name>readSaved</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>loadSSTables</name></expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><name><name>Directories</name>.<name>SSTableLister</name></name></type> <name>sstableFiles</name> <init>= <expr><call><name><name>directories</name>.<name>sstableLister</name></name><argument_list>()</argument_list></call>.<call><name>skipCompacted</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call>.<call><name>skipTemporary</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name><name>SSTableReader</name>.<name>batchOpen</name></name><argument_list>(<argument><expr><call><name><name>sstableFiles</name>.<name>list</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>savedKeys</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name><name>this</name>.<name>partitioner</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>metadata</name>.<name>getDefaultValidator</name></name><argument_list>()</argument_list></call>.<call><name>isCommutative</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <comment type="line">// Filter non-compacted sstables, remove compacted ones</comment>
                <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>compactedSSTables</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
                    <expr_stmt><expr><call><name><name>compactedSSTables</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>sstable</name>.<name>getAncestors</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

                <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>liveSSTables</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
                <block>{
                    <if>if <condition>(<expr><call><name><name>compactedSSTables</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>sstable</name>.<name>descriptor</name>.<name>generation</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"{} is already compacted and will be removed."</expr></argument>, <argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name><name>sstable</name>.<name>markCompacted</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// we need to mark as compacted to be deleted</comment>
                        <expr_stmt><expr><call><name><name>sstable</name>.<name>releaseReference</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// this amount to deleting the sstable</comment>
                    }</block></then>
                    <else>else
                    <block>{
                        <expr_stmt><expr><call><name><name>liveSSTables</name>.<name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></for>
                <expr_stmt><expr><call><name><name>data</name>.<name>addInitialSSTables</name></name><argument_list>(<argument><expr><name>liveSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>data</name>.<name>addInitialSSTables</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>

        <comment type="line">// compaction strategy should be created after the CFS has been prepared</comment>
        <expr_stmt><expr><name><name>this</name>.<name>compactionStrategy</name></name> = <call><name><name>metadata</name>.<name>createCompactionStrategyInstance</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// create the private ColumnFamilyStores for the secondary column indexes</comment>
        <for>for (<init><decl><type><name>ColumnDefinition</name></type> <name>info</name> <range>: <expr><call><name><name>metadata</name>.<name>getColumn_metadata</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>info</name>.<name>getIndexType</name></name><argument_list>()</argument_list></call> != null</expr>)</condition><then>
                <expr_stmt><expr><call><name><name>indexManager</name>.<name>addIndexedColumn</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <comment type="line">// register the mbean</comment>
        <decl_stmt><decl><type><name>String</name></type> <name>type</name> <init>= <expr><name><name>this</name>.<name>partitioner</name></name> instanceof <name>LocalPartitioner</name> ? "IndexColumnFamilies" : "ColumnFamilies"</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>mbeanName</name> = "org.apache.cassandra.db:type=" + <name>type</name> + ",keyspace=" + <name><name>this</name>.<name>table</name>.<name>name</name></name> + ",columnfamily=" + <name>columnFamily</name></expr>;</expr_stmt>
        <try>try
        <block>{
            <decl_stmt><decl><type><name>MBeanServer</name></type> <name>mbs</name> <init>= <expr><call><name><name>ManagementFactory</name>.<name>getPlatformMBeanServer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ObjectName</name></type> <name>nameObj</name> <init>= <expr>new <call><name>ObjectName</name><argument_list>(<argument><expr><name>mbeanName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>mbs</name>.<name>registerMBean</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>nameObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></constructor>

    <comment type="block" format="javadoc">/** call when dropping or renaming a CF. Performs mbean housekeeping and invalidates CFS to other operations */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidate</name><parameter_list>()</parameter_list>
    <block>{
        <try>try
        <block>{
            <expr_stmt><expr><name>valid</name> = false</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>unregisterMBean</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name><name>data</name>.<name>unreferenceSSTables</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>indexManager</name>.<name>invalidate</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>Exception</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <comment type="line">// this shouldn't block anything.</comment>
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Failed unregistering mbean: " + <name>mbeanName</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></catch></try>
    }</block></function>

    <function><type><name>void</name></type> <name>unregisterMBean</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>MalformedObjectNameException</name></expr></argument>, <argument><expr><name>InstanceNotFoundException</name></expr></argument>, <argument><expr><name>MBeanRegistrationException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>MBeanServer</name></type> <name>mbs</name> <init>= <expr><call><name><name>ManagementFactory</name>.<name>getPlatformMBeanServer</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ObjectName</name></type> <name>nameObj</name> <init>= <expr>new <call><name>ObjectName</name><argument_list>(<argument><expr><name>mbeanName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>mbs</name>.<name>isRegistered</name></name><argument_list>(<argument><expr><name>nameObj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>mbs</name>.<name>unregisterMBean</name></name><argument_list>(<argument><expr><name>nameObj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMinRowSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getMinRowSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMaxRowSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getMaxRowSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMeanRowSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getMeanRowSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMeanColumns</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getMeanColumns</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamilyStore</name></type> <name>createColumnFamilyStore</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>loadSSTables</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>createColumnFamilyStore</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><call><name><name>StorageService</name>.<name>getPartitioner</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getCFMetaData</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>loadSSTables</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamilyStore</name></type> <name>createColumnFamilyStore</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>, <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>, <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>createColumnFamilyStore</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>ColumnFamilyStore</name></type> <name>createColumnFamilyStore</name><parameter_list>(<param><decl><type><name>Table</name></type> <name>table</name></decl></param>,
                                                                         <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>,
                                                                         <param><decl><type><name>IPartitioner</name></type> <name>partitioner</name></decl></param>,
                                                                         <param><decl><type><name>CFMetaData</name></type> <name>metadata</name></decl></param>,
                                                                         <param><decl><type><name>boolean</name></type> <name>loadSSTables</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// get the max generation number, to prevent generation conflicts</comment>
        <decl_stmt><decl><type><name>Directories</name></type> <name>directories</name> <init>= <expr><call><name><name>Directories</name>.<name>create</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Directories</name>.<name>SSTableLister</name></name></type> <name>lister</name> <init>= <expr><call><name><name>directories</name>.<name>sstableLister</name></name><argument_list>()</argument_list></call>.<call><name>includeBackups</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name></type> <name>generations</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Integer</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>lister</name>.<name>list</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Descriptor</name></type> <name>desc</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>generations</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>desc</name>.<name>generation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name><name>desc</name>.<name>isCompatible</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Can't open incompatible SSTable! Current version %s, found file: %s"</expr></argument>, <argument><expr><name><name>Descriptor</name>.<name>CURRENT_VERSION</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
        }</block></for>
        <expr_stmt><expr><call><name><name>Collections</name>.<name>sort</name></name><argument_list>(<argument><expr><name>generations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>value</name> <init>= <expr>(<call><name><name>generations</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt; 0) ? (<call><name><name>generations</name>.<name>get</name></name><argument_list>(<argument><expr><call><name><name>generations</name>.<name>size</name></name><argument_list>()</argument_list></call> - 1</expr></argument>)</argument_list></call>) : 0</expr></init></decl>;</decl_stmt>

        <return>return <expr>new <call><name>ColumnFamilyStore</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>directories</name></expr></argument>, <argument><expr><name>loadSSTables</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Removes unnecessary files from the cf directory at startup: these include temp files, orphans, zero-length files
     * and compacted sstables. Files that cannot be recognized will be ignored.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>scrubDataDirectories</name><parameter_list>(<param><decl><type><name>String</name></type> <name>table</name></decl></param>, <param><decl><type><name>String</name></type> <name>columnFamily</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Removing compacted SSTable files from {} (see http://wiki.apache.org/cassandra/MemtableSSTable)"</expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name>Directories</name></type> <name>directories</name> <init>= <expr><call><name><name>Directories</name>.<name>create</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Descriptor</name></argument>,<argument><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>sstableFiles</name> <range>: <expr><call><name><name>directories</name>.<name>sstableLister</name></name><argument_list>()</argument_list></call>.<call><name>list</name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Descriptor</name></type> <name>desc</name> <init>= <expr><call><name><name>sstableFiles</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></type> <name>components</name> <init>= <expr><call><name><name>sstableFiles</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>components</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>COMPACTED_MARKER</name></name></expr></argument>)</argument_list></call> || <name><name>desc</name>.<name>temporary</name></name></expr>)</condition><then>
            <block>{
                <try>try
                <block>{
                    <expr_stmt><expr><call><name><name>SSTable</name>.<name>delete</name></name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><name>components</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
                <continue>continue;</continue>
            }</block></then></if>

            <decl_stmt><decl><type><name>File</name></type> <name>dataFile</name> <init>= <expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>desc</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>DATA</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>components</name>.<name>contains</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>DATA</name></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name><name>dataFile</name>.<name>length</name></name><argument_list>()</argument_list></call> &gt; 0</expr>)</condition><then>
                <comment type="line">// everything appears to be in order... moving on.</comment>
                <continue>continue;</continue></then></if>

            <comment type="line">// missing the DATA file! all components are orphaned</comment>
            <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"Removing orphans for {}: {}"</expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>components</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>Component</name></type> <name>component</name> <range>: <expr><name>components</name></expr></range></decl></init>)
            <block>{
                <try>try
                <block>{
                    <expr_stmt><expr><call><name><name>FileUtils</name>.<name>deleteWithConfirm</name></name><argument_list>(<argument><expr><call><name><name>desc</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block>
                <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
                <block>{
                    <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                }</block></catch></try>
            }</block></for>
        }</block></for>

        <comment type="line">// cleanup incomplete saved caches</comment>
        <decl_stmt><decl><type><name>Pattern</name></type> <name>tmpCacheFilePattern</name> <init>= <expr><call><name><name>Pattern</name>.<name>compile</name></name><argument_list>(<argument><expr><name>table</name> + "-" + <name>columnFamily</name> + "-(Key|Row)Cache.*\\.tmp$"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>File</name></type> <name>dir</name> <init>= <expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>DatabaseDescriptor</name>.<name>getSavedCachesLocation</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name><name>dir</name>.<name>exists</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <assert>assert <expr><call><name><name>dir</name>.<name>isDirectory</name></name><argument_list>()</argument_list></call></expr>;</assert>
            <for>for (<init><decl><type><name>File</name></type> <name>file</name> <range>: <expr><call><name><name>dir</name>.<name>listFiles</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <if>if <condition>(<expr><call><name><name>tmpCacheFilePattern</name>.<name>matcher</name></name><argument_list>(<argument><expr><call><name><name>file</name>.<name>getName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>.<call><name>matches</name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <if>if <condition>(<expr>!<call><name><name>file</name>.<name>delete</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>warn</name></name><argument_list>(<argument><expr>"could not delete " + <call><name><name>file</name>.<name>getAbsolutePath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></then></if></for>
        }</block></then></if>

        <comment type="line">// also clean out any index leftovers.</comment>
        <decl_stmt><decl><type><name>CFMetaData</name></type> <name>cfm</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getCFMetaData</name></name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cfm</name> != null</expr>)</condition><then> <comment type="line">// secondary indexes aren't stored in DD.</comment>
        <block>{
            <for>for (<init><decl><type><name>ColumnDefinition</name></type> <name>def</name> <range>: <expr><call><name><name>cfm</name>.<name>getColumn_metadata</name></name><argument_list>()</argument_list></call>.<call><name>values</name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name>scrubDataDirectories</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><call><name><name>cfm</name>.<name>indexColumnFamilyName</name></name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if>
    }</block></function>

    <comment type="line">// must be called after all sstables are loaded since row cache merges all row versions</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>initRowCache</name><parameter_list>()</parameter_list>
    <block>{
        <if>if <condition>(<expr>!<call><name>isRowCacheEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return;</return></then></if>

        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>AutoSavingCache</name><argument_list>&lt;<argument><name>RowCacheKey</name></argument>, <argument><name>IRowCacheEntry</name></argument>&gt;</argument_list></name></type> <name>rowCache</name> <init>= <expr><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name></name></expr></init></decl>;</decl_stmt>

        <comment type="line">// results are sorted on read (via treeset) because there are few reads and many writes and reads only happen at startup</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>cachedRowsRead</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>DecoratedKey</name></type> <name>key</name> <range>: <expr><call><name><name>rowCache</name>.<name>readSaved</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>data</name> <init>= <expr><call><name>getTopLevelColumns</name><argument_list>(<argument><expr><call><name><name>QueryFilter</name>.<name>getIdentityFilter</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><name><name>Integer</name>.<name>MIN_VALUE</name></name></expr></argument>,
                                                   <argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>data</name> != null</expr>)</condition><then>
                <expr_stmt><expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>put</name></name><argument_list>(<argument><expr>new <call><name>RowCacheKey</name><argument_list>(<argument><expr><name><name>metadata</name>.<name>cfId</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>cachedRowsRead</name>++</expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><name>cachedRowsRead</name> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"completed loading (%d ms; %d keys) row cache for %s.%s"</expr></argument>,
                        <argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> - <name>start</name></expr></argument>,
                        <argument><expr><name>cachedRowsRead</name></expr></argument>,
                        <argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>,
                        <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * See #{@code StorageService.loadNewSSTables(String, String)} for more info
     *
     * @param ksName The keyspace name
     * @param cfName The columnFamily name
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>loadNewSSTables</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ksName</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>)</parameter_list>
    <block>{
        <comment type="block" format="javadoc">/** ks/cf existence checks will be done by open and getCFS methods for us */</comment>
        <decl_stmt><decl><type><name>Table</name></type> <name>table</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>table</name>.<name>getColumnFamilyStore</name></name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call>.<call><name>loadNewSSTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * #{@inheritDoc}
     */</comment>
    <function><type><specifier>public</specifier> <specifier>synchronized</specifier> <name>void</name></type> <name>loadNewSSTables</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Loading new SSTables for " + <name><name>table</name>.<name>name</name></name> + "/" + <name>columnFamily</name> + "..."</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>Descriptor</name></argument>&gt;</argument_list></name></type> <name>currentDescriptors</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>Descriptor</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name><name>data</name>.<name>getView</name></name><argument_list>()</argument_list></call>.<name>sstables</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>currentDescriptors</name>.<name>add</name></name><argument_list>(<argument><expr><name><name>sstable</name>.<name>descriptor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>newSSTables</name> <init>= <expr>new <call><name><name>HashSet</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Directories</name>.<name>SSTableLister</name></name></type> <name>lister</name> <init>= <expr><call><name><name>directories</name>.<name>sstableLister</name></name><argument_list>()</argument_list></call>.<call><name>skipCompacted</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call>.<call><name>skipTemporary</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entry</name> <range>: <expr><call><name><name>lister</name>.<name>list</name></name><argument_list>()</argument_list></call>.<call><name>entrySet</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name>Descriptor</name></type> <name>descriptor</name> <init>= <expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name><name>currentDescriptors</name>.<name>contains</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <continue>continue;</continue></then></if> <comment type="line">// old (initialized) SSTable found, skipping</comment>
            <if>if <condition>(<expr><name><name>descriptor</name>.<name>temporary</name></name></expr>)</condition><then> <comment type="line">// in the process of being written</comment>
                <continue>continue;</continue></then></if>

            <if>if <condition>(<expr>!<call><name><name>descriptor</name>.<name>isCompatible</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Can't open incompatible SSTable! Current version %s, found file: %s"</expr></argument>,
                                                         <argument><expr><name><name>Descriptor</name>.<name>CURRENT_VERSION</name></name></expr></argument>,
                                                         <argument><expr><name>descriptor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>

            <decl_stmt><decl><type><name>Descriptor</name></type> <name>newDescriptor</name> <init>= <expr>new <call><name>Descriptor</name><argument_list>(<argument><expr><name><name>descriptor</name>.<name>version</name></name></expr></argument>,
                                                      <argument><expr><name><name>descriptor</name>.<name>directory</name></name></expr></argument>,
                                                      <argument><expr><name><name>descriptor</name>.<name>ksname</name></name></expr></argument>,
                                                      <argument><expr><name><name>descriptor</name>.<name>cfname</name></name></expr></argument>,
                                                      <argument><expr><call><name><name>fileIndexGenerator</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></argument>,
                                                      <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Renaming new SSTable {} to {}"</expr></argument>, <argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>newDescriptor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>SSTableWriter</name>.<name>rename</name></name><argument_list>(<argument><expr><name>descriptor</name></expr></argument>, <argument><expr><name>newDescriptor</name></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <decl_stmt><decl><type><name>SSTableReader</name></type> <name>reader</name></decl>;</decl_stmt>
            <try>try
            <block>{
                <expr_stmt><expr><name>reader</name> = <call><name><name>SSTableReader</name>.<name>open</name></name><argument_list>(<argument><expr><name>newDescriptor</name></expr></argument>, <argument><expr><call><name><name>entry</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>Collections</name>.</name>&lt;<name>DecoratedKey</name>&gt;<call><name>emptySet</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>logOpenException</name></name><argument_list>(<argument><expr><call><name><name>entry</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></catch></try>
            <expr_stmt><expr><call><name><name>newSSTables</name>.<name>add</name></name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr><call><name><name>newSSTables</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"No new SSTables were found for " + <name><name>table</name>.<name>name</name></name> + "/" + <name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Loading new SSTables and building secondary indexes for " + <name><name>table</name>.<name>name</name></name> + "/" + <name>columnFamily</name> + ": " + <name>newSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>acquireReferences</name></name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>data</name>.<name>addSSTables</name></name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>indexManager</name>.<name>maybeBuildSecondaryIndexes</name></name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>, <argument><expr><call><name><name>indexManager</name>.<name>getIndexedColumns</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
           <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>releaseReferences</name></name><argument_list>(<argument><expr><name>newSSTables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>

        <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Done loading load new SSTables for " + <name><name>table</name>.<name>name</name></name> + "/" + <name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>rebuildSecondaryIndex</name><parameter_list>(<param><decl><type><name>String</name></type> <name>ksName</name></decl></param>, <param><decl><type><name>String</name></type> <name>cfName</name></decl></param>, <param><decl><type><name>String</name>...</type> <name>idxNames</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <init>= <expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name>ksName</name></expr></argument>)</argument_list></call>.<call><name>getColumnFamilyStore</name><argument_list>(<argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>SortedSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name></type> <name>indexes</name> <init>= <expr>new <call><name><name>TreeSet</name><argument_list>&lt;<argument><name>ByteBuffer</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>cfs</name>.<name>metadata</name>.<name>comparator</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>idxNames</name>.<name>length</name></name> == 0</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>indexes</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>cfs</name>.<name>indexManager</name>.<name>getIndexedColumns</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for (<init><decl><type><name>String</name></type> <name>idxName</name> <range>: <expr><name>idxNames</name></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>indexes</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>cfs</name>.<name>indexManager</name>.<name>getColumnByIdxName</name></name><argument_list>(<argument><expr><name>idxName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name><name>cfs</name>.<name>getSSTables</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>cfs</name>.<name>indexManager</name>.<name>setIndexRemoved</name></name><argument_list>(<argument><expr><name>indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>acquireReferences</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"User Requested secondary index re-build for %s/%s indexes"</expr></argument>, <argument><expr><name>ksName</name></expr></argument>, <argument><expr><name>cfName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cfs</name>.<name>indexManager</name>.<name>maybeBuildSecondaryIndexes</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>cfs</name>.<name>indexManager</name>.<name>setIndexBuilt</name></name><argument_list>(<argument><expr><name>indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>releaseReferences</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return the name of the column family
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getColumnFamilyName</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>columnFamily</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * @return a temporary file name for an sstable.
     * When the sstable object is closed, it will be renamed to a non-temporary
     * format, so incomplete sstables can be recognized and removed on startup.
     */</comment>
    <function><type><specifier>public</specifier> <name>String</name></type> <name>getFlushPath</name><parameter_list>(<param><decl><type><name>long</name></type> <name>estimatedSize</name></decl></param>, <param><decl><type><name>String</name></type> <name>version</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>File</name></type> <name>location</name> <init>= <expr><call><name><name>directories</name>.<name>getDirectoryForNewSSTables</name></name><argument_list>(<argument><expr><name>estimatedSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>location</name> == null</expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr>"Insufficient disk space to flush " + <name>estimatedSize</name> + " bytes"</expr></argument>)</argument_list></call></expr>;</throw></then></if>
        <return>return <expr><call><name>getTempSSTablePath</name><argument_list>(<argument><expr><name>location</name></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getTempSSTablePath</name><parameter_list>(<param><decl><type><name>File</name></type> <name>directory</name></decl></param>, <param><decl><type><name>String</name></type> <name>version</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Descriptor</name></type> <name>desc</name> <init>= <expr>new <call><name>Descriptor</name><argument_list>(<argument><expr><name>version</name></expr></argument>,
                                         <argument><expr><name>directory</name></expr></argument>,
                                         <argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>,
                                         <argument><expr><name>columnFamily</name></expr></argument>,
                                         <argument><expr><call><name><name>fileIndexGenerator</name>.<name>incrementAndGet</name></name><argument_list>()</argument_list></call></expr></argument>,
                                         <argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>desc</name>.<name>filenameFor</name></name><argument_list>(<argument><expr><name><name>Component</name>.<name>DATA</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>String</name></type> <name>getTempSSTablePath</name><parameter_list>(<param><decl><type><name>File</name></type> <name>directory</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getTempSSTablePath</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name><name>Descriptor</name>.<name>CURRENT_VERSION</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/** flush the given memtable and swap in a new one for its CFS, if it hasn't been frozen already.  threadsafe. */</comment>
    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>maybeSwitchMemtable</name><parameter_list>(<param><decl><type><name>Memtable</name></type> <name>oldMemtable</name></decl></param>, <param><decl><type><specifier>final</specifier> <name>boolean</name></type> <name>writeCommitLog</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>oldMemtable</name>.<name>isFrozen</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"memtable is already frozen; another thread must be flushing it"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>null</expr>;</return>
        }</block></then></if>

        <comment type="block">/*
         * If we can get the writelock, that means no new updates can come in and
         * all ongoing updates to memtables have completed. We can get the tail
         * of the log and use it as the starting position for log replay on recovery.
         *
         * This is why we Table.switchLock needs to be global instead of per-Table:
         * we need to schedule discardCompletedSegments calls in the same order as their
         * contexts (commitlog position) were read, even though the flush executor
         * is multithreaded.
         */</comment>
        <expr_stmt><expr><call><name><name>Table</name>.<name>switchLock</name>.<name>writeLock</name></name><argument_list>()</argument_list></call>.<call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <if>if <condition>(<expr><call><name><name>oldMemtable</name>.<name>isFrozen</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"memtable is already frozen; another thread must be flushing it"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>null</expr>;</return>
            }</block></then></if>

            <assert>assert <expr><call><name>getMemtableThreadSafe</name><argument_list>()</argument_list></call> == <name>oldMemtable</name></expr>;</assert>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>Future</name><argument_list>&lt;<argument><name>ReplayPosition</name></argument>&gt;</argument_list></name></type> <name>ctx</name> <init>= <expr><name>writeCommitLog</name> ? <call><name><name>CommitLog</name>.<name>instance</name>.<name>getContext</name></name><argument_list>()</argument_list></call> : <call><name><name>Futures</name>.<name>immediateFuture</name></name><argument_list>(<argument><expr><name><name>ReplayPosition</name>.<name>NONE</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// submit the memtable for any indexed sub-cfses, and our own.</comment>
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>icc</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// don't assume that this.memtable is dirty; forceFlush can bring us here during index build even if it is not</comment>
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>Memtable</name></type> <name>mt</name> <init>= <expr><call><name><name>cfs</name>.<name>getMemtableThreadSafe</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>!<call><name><name>mt</name>.<name>isClean</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>mt</name>.<name>isFrozen</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                <block>{
                    <comment type="line">// We need to freeze indexes too because they can be concurrently flushed too (#3547)</comment>
                    <expr_stmt><expr><call><name><name>mt</name>.<name>freeze</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name><name>icc</name>.<name>add</name></name><argument_list>(<argument><expr><name>cfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
            <decl_stmt><decl><type><specifier>final</specifier> <name>CountDownLatch</name></type> <name>latch</name> <init>= <expr>new <call><name>CountDownLatch</name><argument_list>(<argument><expr><call><name><name>icc</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><name>icc</name></expr></range></decl></init>)
            <block>{
                <decl_stmt><decl><type><name>Memtable</name></type> <name>memtable</name> <init>= <expr><call><name><name>cfs</name>.<name>data</name>.<name>switchMemtable</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Enqueuing flush of {}"</expr></argument>, <argument><expr><name>memtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>memtable</name>.<name>flushAndSignal</name></name><argument_list>(<argument><expr><name>latch</name></expr></argument>, <argument><expr><name>flushWriter</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

            <if>if <condition>(<expr><name>memtableSwitchCount</name> == <name><name>Integer</name>.<name>MAX_VALUE</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>memtableSwitchCount</name> = 0</expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>memtableSwitchCount</name>++</expr>;</expr_stmt>

            <comment type="line">// when all the memtables have been written, including for indexes, mark the flush in the commitlog header.</comment>
            <comment type="line">// a second executor makes sure the onMemtableFlushes get called in the right order,</comment>
            <comment type="line">// while keeping the wait-for-flush (future.get) out of anything latency-sensitive.</comment>
            <return>return <expr><call><name><name>postFlushExecutor</name>.<name>submit</name></name><argument_list>(<argument><expr>new <class><super><name>WrappedRunnable</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>public</specifier> <name>void</name></type> <name>runMayThrow</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
                <block>{
                    <expr_stmt><expr><call><name><name>latch</name>.<name>await</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr>!<call><name><name>icc</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <block>{
                        <comment type="line">//only valid when memtables exist</comment>

                        <for>for (<init><decl><type><name>SecondaryIndex</name></type> <name>index</name> <range>: <expr><call><name><name>indexManager</name>.<name>getIndexesNotBackedByCfs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                        <block>{
                            <comment type="line">// flush any non-cfs backed indexes</comment>
                            <expr_stmt><expr><call><name><name>logger</name>.<name>info</name></name><argument_list>(<argument><expr>"Flushing SecondaryIndex {}"</expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><call><name><name>index</name>.<name>forceBlockingFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                        }</block></for>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>writeCommitLog</name></expr>)</condition><then>
                    <block>{
                        <comment type="line">// if we're not writing to the commit log, we are replaying the log, so marking</comment>
                        <comment type="line">// the log header with "you can discard anything written before the context" is not valid</comment>
                        <expr_stmt><expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>discardCompletedSegments</name></name><argument_list>(<argument><expr><name><name>metadata</name>.<name>cfId</name></name></expr></argument>, <argument><expr><call><name><name>ctx</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></function>
            }</block></class></expr></argument>)</argument_list></call></expr>;</return>
        }</block>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>Table</name>.<name>switchLock</name>.<name>writeLock</name></name><argument_list>()</argument_list></call>.<call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>forceFlush</name><parameter_list>()</parameter_list>
    <block>{
        <comment type="line">// during index build, 2ary index memtables can be dirty even if parent is not.  if so,</comment>
        <comment type="line">// we want flushLargestMemtables to flush the 2ary index ones too.</comment>
        <decl_stmt><decl><type><name>boolean</name></type> <name>clean</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><name>clean</name> &amp;= <call><name><name>cfs</name>.<name>getMemtableThreadSafe</name></name><argument_list>()</argument_list></call>.<call><name>isClean</name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>

        <if>if <condition>(<expr><name>clean</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"forceFlush requested but everything is clean in {}"</expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>null</expr>;</return>
        }</block></then></if>

        <return>return <expr><call><name>maybeSwitchMemtable</name><argument_list>(<argument><expr><call><name>getMemtableThreadSafe</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceBlockingFlush</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>future</name> <init>= <expr><call><name>forceFlush</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>future</name> != null</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>future</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>updateRowCache</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>columnFamily</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name><name>metadata</name>.<name>cfId</name></name> == null</expr>)</condition><then>
            <return>return;</return></then></if> <comment type="line">// secondary index</comment>

        <decl_stmt><decl><type><name>RowCacheKey</name></type> <name>cacheKey</name> <init>= <expr>new <call><name>RowCacheKey</name><argument_list>(<argument><expr><name><name>metadata</name>.<name>cfId</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// always invalidate a copying cache value</comment>
        <if>if <condition>(<expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>isPutCopying</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>invalidateCachedRow</name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <comment type="line">// invalidate a normal cache value if it's a sentinel, so the read will retry (and include the new update)</comment>
        <decl_stmt><decl><type><name>IRowCacheEntry</name></type> <name>cachedRow</name> <init>= <expr><call><name>getCachedRowInternal</name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cachedRow</name> != null</expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name>cachedRow</name> instanceof <name>RowCacheSentinel</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>invalidateCachedRow</name><argument_list>(<argument><expr><name>cacheKey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
                <comment type="line">// columnFamily is what is written in the commit log. Because of the PeriodicCommitLog, this can be done in concurrency</comment>
                <comment type="line">// with this. So columnFamily shouldn't be modified and if it contains super columns, neither should they. So for super</comment>
                <comment type="line">// columns, we must make sure to clone them when adding to the cache. That's what addAllWithSCCopy does (see #3957)</comment>
                <expr_stmt><expr>((<name>ColumnFamily</name>) <name>cachedRow</name>).<call><name>addAllWithSCCopy</name><argument_list>(<argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name><name>HeapAllocator</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Insert/Update the column family for this key.
     * Caller is responsible for acquiring Table.flusherLock!
     * param @ lock - lock that needs to be used.
     * param @ key - key for update/insert
     * param @ columnFamily - columnFamily changes
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>apply</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>ColumnFamily</name></type> <name>columnFamily</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>Memtable</name></type> <name>mt</name> <init>= <expr><call><name>getMemtableThreadSafe</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>mt</name>.<name>put</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>updateRowCache</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>writeStats</name>.<name>addNano</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// recompute liveRatio, if we have doubled the number of ops since last calculated</comment>
        <while>while <condition>(<expr>true</expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>last</name> <init>= <expr><call><name><name>liveRatioComputedAt</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>operations</name> <init>= <expr><call><name><name>writeStats</name>.<name>getOpCount</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>operations</name> &lt; 2 * <name>last</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <if>if <condition>(<expr><call><name><name>liveRatioComputedAt</name>.<name>compareAndSet</name></name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><name>operations</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"computing liveRatio of {} at {} ops"</expr></argument>, <argument><expr><name>this</name></expr></argument>, <argument><expr><name>operations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>mt</name>.<name>updateLiveRatio</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamily</name></type> <name>removeDeletedCF</name><parameter_list>(<param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>cf</name>.<name>getColumnCount</name></name><argument_list>()</argument_list></call> == 0 &amp;&amp; (!<call><name><name>cf</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call> || <call><name><name>cf</name>.<name>getLocalDeletionTime</name></name><argument_list>()</argument_list></call> &lt; <name>gcBefore</name>)</expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if>

        <expr_stmt><expr><call><name><name>cf</name>.<name>maybeResetDeletionTimes</name></name><argument_list>(<argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>cf</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     This is complicated because we need to preserve deleted columns, supercolumns, and columnfamilies
     until they have been deleted for at least GC_GRACE_IN_SECONDS.  But, we do not need to preserve
     their contents; just the object itself as a "tombstone" that can be used to repair other
     replicas that do not know about the deletion.
     */</comment>
    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>ColumnFamily</name></type> <name>removeDeleted</name><parameter_list>(<param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>cf</name> == null</expr>)</condition><then>
        <block>{
            <return>return <expr>null</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>removeDeletedColumnsOnly</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>removeDeletedCF</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name>void</name></type> <name>removeDeletedColumnsOnly</name><parameter_list>(<param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>cf</name>.<name>isSuper</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>removeDeletedSuper</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>removeDeletedStandard</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>removeDeletedStandard</name><parameter_list>(<param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>cf</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>IColumn</name></type> <name>c</name> <init>= <expr><call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>cname</name> <init>= <expr><call><name><name>c</name>.<name>name</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// remove columns if</comment>
            <comment type="line">// (a) the column itself is tombstoned or</comment>
            <comment type="line">// (b) the CF is tombstoned and the column is not newer than it</comment>
            <if>if <condition>(<expr><call><name><name>c</name>.<name>getLocalDeletionTime</name></name><argument_list>()</argument_list></call> &lt; <name>gcBefore</name>
                || <call><name><name>c</name>.<name>timestamp</name></name><argument_list>()</argument_list></call> &lt;= <call><name><name>cf</name>.<name>getMarkedForDeleteAt</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>iter</name>.<name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
    }</block></function>

    <function><type><specifier>private</specifier> <specifier>static</specifier> <name>void</name></type> <name>removeDeletedSuper</name><parameter_list>(<param><decl><type><name>ColumnFamily</name></type> <name>cf</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <comment type="line">// TODO assume deletion means "most are deleted?" and add to clone, instead of remove from original?</comment>
        <comment type="line">// this could be improved by having compaction, or possibly even removeDeleted, r/m the tombstone</comment>
        <comment type="line">// once gcBefore has passed, so if new stuff is added in it doesn't used the wrong algorithm forever</comment>
        <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>iter</name> <init>= <expr><call><name><name>cf</name>.<name>iterator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><call><name><name>iter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name>SuperColumn</name></type> <name>c</name> <init>= <expr>(<name>SuperColumn</name>)<call><name><name>iter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>long</name></type> <name>minTimestamp</name> <init>= <expr><call><name><name>Math</name>.<name>max</name></name><argument_list>(<argument><expr><call><name><name>c</name>.<name>getMarkedForDeleteAt</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>cf</name>.<name>getMarkedForDeleteAt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name><name>Iterator</name><argument_list>&lt;<argument><name>IColumn</name></argument>&gt;</argument_list></name></type> <name>subIter</name> <init>= <expr><call><name><name>c</name>.<name>getSubColumns</name></name><argument_list>()</argument_list></call>.<call><name>iterator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><call><name><name>subIter</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <decl_stmt><decl><type><name>IColumn</name></type> <name>subColumn</name> <init>= <expr><call><name><name>subIter</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <comment type="line">// remove subcolumns if</comment>
                <comment type="line">// (a) the subcolumn itself is tombstoned or</comment>
                <comment type="line">// (b) the supercolumn is tombstoned and the subcolumn is not newer than it</comment>
                <if>if <condition>(<expr><call><name><name>subColumn</name>.<name>timestamp</name></name><argument_list>()</argument_list></call> &lt;= <name>minTimestamp</name>
                    || <call><name><name>subColumn</name>.<name>getLocalDeletionTime</name></name><argument_list>()</argument_list></call> &lt; <name>gcBefore</name></expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><call><name><name>subIter</name>.<name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></while>
            <if>if <condition>(<expr><call><name><name>c</name>.<name>getSubColumns</name></name><argument_list>()</argument_list></call>.<call><name>isEmpty</name><argument_list>()</argument_list></call> &amp;&amp; (!<call><name><name>c</name>.<name>isMarkedForDelete</name></name><argument_list>()</argument_list></call> || <call><name><name>c</name>.<name>getLocalDeletionTime</name></name><argument_list>()</argument_list></call> &lt; <name>gcBefore</name>)</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name><name>iter</name>.<name>remove</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else
            <block>{
                <expr_stmt><expr><call><name><name>c</name>.<name>maybeResetDeletionTimes</name></name><argument_list>(<argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @param sstables
     * @return sstables whose key range overlaps with that of the given sstables, not including itself.
     * (The given sstables may or may not overlap with each other.)
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getOverlappingSSTables</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Checking for sstables overlapping {}"</expr></argument>, <argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// a normal compaction won't ever have an empty sstables list, but we create a skeleton</comment>
        <comment type="line">// compaction controller for streaming, and that passes an empty list.</comment>
        <if>if <condition>(<expr><call><name><name>sstables</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name><name>ImmutableSet</name>.<name>of</name></name><argument_list>()</argument_list></call></expr>;</return></then></if>

        <decl_stmt><decl><type><name><name>IntervalTree</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>tree</name> <init>= <expr><call><name><name>data</name>.<name>getView</name></name><argument_list>()</argument_list></call>.<name>intervalTree</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>results</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>overlaps</name> <init>= <expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>tree</name>.<name>search</name></name><argument_list>(<argument><expr>new <call><name><name>Interval</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>sstable</name>.<name>first</name></name></expr></argument>, <argument><expr><name><name>sstable</name>.<name>last</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <assert>assert <expr><call><name><name>overlaps</name>.<name>contains</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</assert>
            <expr_stmt><expr><name>results</name> = <name>results</name> == null ? <name>overlaps</name> : <call><name><name>Sets</name>.<name>union</name></name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>overlaps</name></expr></argument>)</argument_list></call>.<call><name>immutableCopy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>results</name> = <call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>results</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     * Called after a BinaryMemtable flushes its in-memory data, or we add a file
     * via bootstrap. This information is cached in the ColumnFamilyStore.
     * This is useful for reads because the ColumnFamilyStore first looks in
     * the in-memory store and the into the disk to find the key. If invoked
     * during recoveryMode the onMemtableFlush() need not be invoked.
     *
     * param @ filename - filename just flushed to disk
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>addSSTable</name><parameter_list>(<param><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><call><name><name>sstable</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call>.<call><name>equals</name><argument_list>(<argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</assert>
        <expr_stmt><expr><call><name>addSSTables</name><argument_list>(<argument><expr><call><name><name>Arrays</name>.<name>asList</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>addSSTables</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>data</name>.<name>addSSTables</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>submitBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Calculate expected file size of SSTable after compaction.
     *
     * If operation type is {@code CLEANUP} and we're not dealing with an index sstable,
     * then we calculate expected file size with checking token range to be eliminated.
     *
     * Otherwise, we just add up all the files' size, which is the worst case file
     * size for compaction of all the list of files given.
     *
     * @param sstables SSTables to calculate expected compacted file size
     * @param operation Operation type
     * @return Expected file size of SSTable after compaction
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>getExpectedCompactedFileSize</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>, <param><decl><type><name>OperationType</name></type> <name>operation</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>operation</name> != <name><name>OperationType</name>.<name>CLEANUP</name></name> || <call><name>isIndex</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <return>return <expr><call><name><name>SSTable</name>.<name>getTotalBytes</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>long</name></type> <name>expectedFileSize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>ranges</name> <init>= <expr><call><name><name>StorageService</name>.<name>instance</name>.<name>getLocalRanges</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Pair</name><argument_list>&lt;<argument><name>Long</name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>positions</name> <init>= <expr><call><name><name>sstable</name>.<name>getPositionsForRanges</name></name><argument_list>(<argument><expr><name>ranges</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name><name>Pair</name><argument_list>&lt;<argument><name>Long</name></argument>, <argument><name>Long</name></argument>&gt;</argument_list></name></type> <name>position</name> <range>: <expr><name>positions</name></expr></range></decl></init>)
                <expr_stmt><expr><name>expectedFileSize</name> += <name><name>position</name>.<name>right</name></name> - <name><name>position</name>.<name>left</name></name></expr>;</expr_stmt></for>
        }</block></for>
        <return>return <expr><name>expectedFileSize</name></expr>;</return>
    }</block></function>

    <comment type="block">/*
     *  Find the maximum size file in the list .
     */</comment>
    <function><type><specifier>public</specifier> <name>SSTableReader</name></type> <name>getMaxSizeFile</name><parameter_list>(<param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>maxSize</name> <init>= <expr>0L</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SSTableReader</name></type> <name>maxFile</name> <init>= <expr>null</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr><call><name><name>sstable</name>.<name>onDiskLength</name></name><argument_list>()</argument_list></call> &gt; <name>maxSize</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>maxSize</name> = <call><name><name>sstable</name>.<name>onDiskLength</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>maxFile</name> = <name>sstable</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>maxFile</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceCleanup</name><parameter_list>(<param><decl><type><name><name>NodeId</name>.<name>OneShotRenewer</name></name></type> <name>renewer</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>performCleanup</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name>.<name>this</name></name></expr></argument>, <argument><expr><name>renewer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>scrub</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name>snapshotWithoutFlush</name><argument_list>(<argument><expr>"pre-scrub-" + <call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>performScrub</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name>.<name>this</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>sstablesRewrite</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>performSSTableRewrite</name></name><argument_list>(<argument><expr><name><name>ColumnFamilyStore</name>.<name>this</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>markCompacted</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>, <param><decl><type><name>OperationType</name></type> <name>compactionType</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr>!<call><name><name>sstables</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <expr_stmt><expr><call><name><name>data</name>.<name>markCompacted</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>compactionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>replaceCompactedSSTables</name><parameter_list>(<param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>replacements</name></decl></param>, <param><decl><type><name>OperationType</name></type> <name>compactionType</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>data</name>.<name>replaceCompactedSSTables</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><name>replacements</name></expr></argument>, <argument><expr><name>compactionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><name>void</name></type> <name>replaceFlushed</name><parameter_list>(<param><decl><type><name>Memtable</name></type> <name>memtable</name></decl></param>, <param><decl><type><name>SSTableReader</name></type> <name>sstable</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>data</name>.<name>replaceFlushed</name></name><argument_list>(<argument><expr><name>memtable</name></expr></argument>, <argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>submitBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isValid</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>valid</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMemtableColumnsCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getMemtableThreadSafe</name><argument_list>()</argument_list></call>.<call><name>getOperations</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getMemtableDataSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getMemtableThreadSafe</name><argument_list>()</argument_list></call>.<call><name>getLiveSize</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalMemtableLiveSize</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getMemtableDataSize</name><argument_list>()</argument_list></call> + <call><name><name>indexManager</name>.<name>getTotalLiveSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMemtableSwitchCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>memtableSwitchCount</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * get the current memtable in a threadsafe fashion.  note that simply "return memtable_" is
     * incorrect; you need to lock to introduce a thread safe happens-before ordering.
     *
     * do NOT use this method to do either a put or get on the memtable object, since it could be
     * flushed in the meantime (and its executor terminated).
     *
     * also do NOT make this method public or it will really get impossible to reason about these things.
     * @return
     */</comment>
    <function><type><specifier>private</specifier> <name>Memtable</name></type> <name>getMemtableThreadSafe</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getMemtable</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Package protected for access from the CompactionManager.
     */</comment>
    <function><type><specifier>public</specifier> <name>DataTracker</name></type> <name>getDataTracker</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>data</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getSSTables</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getSSTables</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getUncompactingSSTables</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getUncompactingSSTables</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getRecentSSTablesPerReadHistogram</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>recentSSTablesPerRead</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getSSTablesPerReadHistogram</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>sstablesPerRead</name>.<name>getBuckets</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getReadCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readStats</name>.<name>getOpCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getRecentReadLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readStats</name>.<name>getRecentLatencyMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getLifetimeReadLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readStats</name>.<name>getTotalLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getRecentReadLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readStats</name>.<name>getRecentLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalReadLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>readStats</name>.<name>getTotalLatencyMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

<comment type="line">// TODO this actually isn't a good meature of pending tasks</comment>
    <function><type><specifier>public</specifier> <name>int</name></type> <name>getPendingTasks</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Table</name>.<name>switchLock</name>.<name>getQueueLength</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getWriteCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeStats</name>.<name>getOpCount</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalWriteLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeStats</name>.<name>getTotalLatencyMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getRecentWriteLatencyMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeStats</name>.<name>getRecentLatencyMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getLifetimeWriteLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeStats</name>.<name>getTotalLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getRecentWriteLatencyHistogramMicros</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>writeStats</name>.<name>getRecentLatencyHistogramMicros</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>ColumnFamily</name></type> <name>getColumnFamily</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>, <param><decl><type><name>QueryPath</name></type> <name>path</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>start</name></decl></param>, <param><decl><type><name>ByteBuffer</name></type> <name>finish</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>reversed</name></decl></param>, <param><decl><type><name>int</name></type> <name>limit</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getColumnFamily</name><argument_list>(<argument><expr><call><name><name>QueryFilter</name>.<name>getSliceFilter</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>finish</name></expr></argument>, <argument><expr><name>reversed</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * get a list of columns starting from a given column, in a specified order.
     * only the latest version of a column is returned.
     * @return null if there is no data and no tombstones; otherwise a ColumnFamily
     */</comment>
    <function><type><specifier>public</specifier> <name>ColumnFamily</name></type> <name>getColumnFamily</name><parameter_list>(<param><decl><type><name>QueryFilter</name></type> <name>filter</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getColumnFamily</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><call><name>gcBefore</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>ColumnFamily</name></type> <name>getColumnFamily</name><parameter_list>(<param><decl><type><name>QueryFilter</name></type> <name>filter</name></decl></param>, <param><decl><type><name><name>ISortedColumns</name>.<name>Factory</name></name></type> <name>factory</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getColumnFamily</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><call><name>gcBefore</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>gcBefore</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call>(<name>int</name>) <argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call> - <call><name><name>metadata</name>.<name>getGcGraceSeconds</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * fetch the row given by filter.key if it is in the cache; if not, read it from disk and cache it
     * @param cfId the column family to read the row from
     * @param filter the columns being queried.  Note that we still cache entire rows, but if a row is uncached
     *               and we race to cache it, only the winner will read the entire row
     * @return the entire row for filter.key, if present in the cache (or we can cache it), or just the column
     *         specified by filter otherwise
     */</comment>
    <function><type><specifier>private</specifier> <name>ColumnFamily</name></type> <name>getThroughCache</name><parameter_list>(<param><decl><type><name>Integer</name></type> <name>cfId</name></decl></param>, <param><decl><type><name>QueryFilter</name></type> <name>filter</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><call><name>isRowCacheEnabled</name><argument_list>()</argument_list></call>
               : <call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"Row cache is not enabled on column family [" + <call><name>getColumnFamilyName</name><argument_list>()</argument_list></call> + "]"</expr></argument>)</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name>RowCacheKey</name></type> <name>key</name> <init>= <expr>new <call><name>RowCacheKey</name><argument_list>(<argument><expr><name>cfId</name></expr></argument>, <argument><expr><name><name>filter</name>.<name>key</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// attempt a sentinel-read-cache sequence.  if a write invalidates our sentinel, we'll return our</comment>
        <comment type="line">// (now potentially obsolete) data, but won't cache it. see CASSANDRA-3862</comment>
        <decl_stmt><decl><type><name>IRowCacheEntry</name></type> <name>cached</name> <init>= <expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>get</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cached</name> != null</expr>)</condition><then>
        <block>{
            <if>if <condition>(<expr><name>cached</name> instanceof <name>RowCacheSentinel</name></expr>)</condition><then>
            <block>{
                <comment type="line">// Some other read is trying to cache the value, just do a normal non-caching read</comment>
                <return>return <expr><call><name>getTopLevelColumns</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name><name>Integer</name>.<name>MIN_VALUE</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <return>return <expr>(<name>ColumnFamily</name>) <name>cached</name></expr>;</return>
        }</block></then></if>

        <decl_stmt><decl><type><name>RowCacheSentinel</name></type> <name>sentinel</name> <init>= <expr>new <call><name>RowCacheSentinel</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>boolean</name></type> <name>sentinelSuccess</name> <init>= <expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>putIfAbsent</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>sentinel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <try>try
        <block>{
            <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>data</name> <init>= <expr><call><name>getTopLevelColumns</name><argument_list>(<argument><expr><call><name><name>QueryFilter</name>.<name>getIdentityFilter</name></name><argument_list>(<argument><expr><name><name>filter</name>.<name>key</name></name></expr></argument>, <argument><expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr><name><name>Integer</name>.<name>MIN_VALUE</name></name></expr></argument>,
                                                   <argument><expr>true</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>sentinelSuccess</name> &amp;&amp; <name>data</name> != null</expr>)</condition><then>
                <expr_stmt><expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>replace</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>sentinel</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            <return>return <expr><name>data</name></expr>;</return>
        }</block>
        <finally>finally
        <block>{
            <if>if <condition>(<expr><name>sentinelSuccess</name> &amp;&amp; <name>data</name> == null</expr>)</condition><then>
                <expr_stmt><expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></finally></try>
    }</block></function>

    <function><type><name>ColumnFamily</name></type> <name>getColumnFamily</name><parameter_list>(<param><decl><type><name>QueryFilter</name></type> <name>filter</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr><call><name><name>columnFamily</name>.<name>equals</name></name><argument_list>(<argument><expr><call><name><name>filter</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> : <call><name><name>filter</name>.<name>getColumnFamilyName</name></name><argument_list>()</argument_list></call></expr>;</assert>

        <decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <if>if <condition>(<expr>!<call><name>isRowCacheEnabled</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <block>{
                <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>cf</name> <init>= <expr><call><name>getTopLevelColumns</name><argument_list>(<argument><expr><name>filter</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>cf</name> == null</expr>)</condition><then>
                    <return>return <expr>null</expr>;</return></then></if>

                <comment type="line">// TODO this is necessary because when we collate supercolumns together, we don't check</comment>
                <comment type="line">// their subcolumns for relevance, so we need to do a second prune post facto here.</comment>
                <return>return <expr><call><name><name>cf</name>.<name>isSuper</name></name><argument_list>()</argument_list></call> ? <call><name>removeDeleted</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call> : <call><name>removeDeletedCF</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <decl_stmt><decl><type><name>Integer</name></type> <name>cfId</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getId</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><name><name>this</name>.<name>columnFamily</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cfId</name> == null</expr>)</condition><then>
                <return>return <expr>null</expr>;</return></then></if> <comment type="line">// secondary index</comment>

            <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>cached</name> <init>= <expr><call><name>getThroughCache</name><argument_list>(<argument><expr><name>cfId</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>cached</name> == null</expr>)</condition><then>
                <return>return <expr>null</expr>;</return></then></if>

            <return>return <expr><call><name>filterColumnFamily</name><argument_list>(<argument><expr><name>cached</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>readStats</name>.<name>addNano</name></name><argument_list>(<argument><expr><call><name><name>System</name>.<name>nanoTime</name></name><argument_list>()</argument_list></call> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     *  Filter a cached row, which will not be modified by the filter, but may be modified by throwing out
     *  tombstones that are no longer relevant.
     *  The returned column family won't be thread safe.
     */</comment>
    <function><type><name>ColumnFamily</name></type> <name>filterColumnFamily</name><parameter_list>(<param><decl><type><name>ColumnFamily</name></type> <name>cached</name></decl></param>, <param><decl><type><name>QueryFilter</name></type> <name>filter</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>cf</name> <init>= <expr><call><name><name>cached</name>.<name>cloneMeShallow</name></name><argument_list>(<argument><expr><call><name><name>ArrayBackedSortedColumns</name>.<name>factory</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>filter</name>.<name>filter</name>.<name>isReversed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>IColumnIterator</name></type> <name>ci</name> <init>= <expr><call><name><name>filter</name>.<name>getMemtableColumnIterator</name></name><argument_list>(<argument><expr><name>cached</name></expr></argument>, <argument><expr>null</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>filter</name>.<name>collateColumns</name></name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>singletonList</name></name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// TODO this is necessary because when we collate supercolumns together, we don't check</comment>
        <comment type="line">// their subcolumns for relevance, so we need to do a second prune post facto here.</comment>
        <return>return <expr><call><name><name>cf</name>.<name>isSuper</name></name><argument_list>()</argument_list></call> ? <call><name>removeDeleted</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call> : <call><name>removeDeletedCF</name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current view and acquires references on all its sstables.
     * This is a bit tricky because we must ensure that between the time we
     * get the current view and the time we acquire the references the set of
     * sstables hasn't changed. Otherwise we could get a view for which an
     * sstable have been deleted in the meantime.
     *
     * At the end of this method, a reference on all the sstables of the
     * returned view will have been acquired and must thus be released when
     * appropriate.
     */</comment>
    <function><type><specifier>private</specifier> <name><name>DataTracker</name>.<name>View</name></name></type> <name>markCurrentViewReferenced</name><parameter_list>()</parameter_list>
    <block>{
        <while>while <condition>(<expr>true</expr>)</condition>
        <block>{
            <decl_stmt><decl><type><name><name>DataTracker</name>.<name>View</name></name></type> <name>currentView</name> <init>= <expr><call><name><name>data</name>.<name>getView</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name><name>SSTableReader</name>.<name>acquireReferences</name></name><argument_list>(<argument><expr><name><name>currentView</name>.<name>sstables</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>currentView</name></expr>;</return></then></if>
        }</block></while>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Get the current sstables, acquiring references on all of them.
     * The caller is in charge of releasing the references on the sstables.
     *
     * See markCurrentViewReferenced() above.
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>markCurrentSSTablesReferenced</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>markCurrentViewReferenced</name><argument_list>()</argument_list></call>.<name>sstables</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return a ViewFragment containing the sstables and memtables that may need to be merged
     * for the given @param key, according to the interval tree
     */</comment>
    <function><type><specifier>public</specifier> <name>ViewFragment</name></type> <name>markReferenced</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr>!<call><name><name>key</name>.<name>isMinimum</name></name><argument_list>()</argument_list></call></expr>;</assert>
        <decl_stmt><decl><type><name><name>DataTracker</name>.<name>View</name></name></type> <name>view</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl>;</decl_stmt>
        <while>while <condition>(<expr>true</expr>)</condition>
        <block>{
            <expr_stmt><expr><name>view</name> = <call><name><name>data</name>.<name>getView</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>sstables</name> = <call><name><name>view</name>.<name>intervalTree</name>.<name>search</name></name><argument_list>(<argument><expr>new <call><name>Interval</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>SSTableReader</name>.<name>acquireReferences</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <break>break;</break></then></if>
            <comment type="line">// retry w/ new view</comment>
        }</block></while>
        <return>return <expr>new <call><name>ViewFragment</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name><name>view</name>.<name>memtable</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>view</name>.<name>memtablesPendingFlush</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return a ViewFragment containing the sstables and memtables that may need to be merged
     * for rows between @param startWith and @param stopAt, inclusive, according to the interval tree
     */</comment>
    <function><type><specifier>public</specifier> <name>ViewFragment</name></type> <name>markReferenced</name><parameter_list>(<param><decl><type><name>RowPosition</name></type> <name>startWith</name></decl></param>, <param><decl><type><name>RowPosition</name></type> <name>stopAt</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>DataTracker</name>.<name>View</name></name></type> <name>view</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl>;</decl_stmt>
        <while>while <condition>(<expr>true</expr>)</condition>
        <block>{
            <expr_stmt><expr><name>view</name> = <call><name><name>data</name>.<name>getView</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// startAt == minimum is ok, but stopAt == minimum is confusing because all IntervalTree deals with</comment>
            <comment type="line">// is Comparable, so it won't know to special-case that.</comment>
            <decl_stmt><decl><type><name>Comparable</name></type> <name>stopInTree</name> <init>= <expr><call><name><name>stopAt</name>.<name>isMinimum</name></name><argument_list>()</argument_list></call> ? <call><name><name>view</name>.<name>intervalTree</name>.<name>max</name></name><argument_list>()</argument_list></call> : <name>stopAt</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>sstables</name> = <call><name><name>view</name>.<name>intervalTree</name>.<name>search</name></name><argument_list>(<argument><expr>new <call><name>Interval</name><argument_list>(<argument><expr><name>startWith</name></expr></argument>, <argument><expr><name>stopInTree</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name><name>SSTableReader</name>.<name>acquireReferences</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <break>break;</break></then></if>
            <comment type="line">// retry w/ new view</comment>
        }</block></while>
        <return>return <expr>new <call><name>ViewFragment</name><argument_list>(<argument><expr><name>sstables</name></expr></argument>, <argument><expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name><name>view</name>.<name>memtable</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>view</name>.<name>memtablesPendingFlush</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getSSTablesForKey</name><parameter_list>(<param><decl><type><name>String</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>dk</name> <init>= <expr>new <call><name>DecoratedKey</name><argument_list>(<argument><expr><call><name><name>partitioner</name>.<name>getToken</name></name><argument_list>(<argument><expr><call><name><name>ByteBuffer</name>.<name>wrap</name></name><argument_list>(<argument><expr><call><name><name>key</name>.<name>getBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>ByteBuffer</name>.<name>wrap</name></name><argument_list>(<argument><expr><call><name><name>key</name>.<name>getBytes</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ViewFragment</name></type> <name>view</name> <init>= <expr><call><name>markReferenced</name><argument_list>(<argument><expr><name>dk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>files</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstr</name> <range>: <expr><name><name>view</name>.<name>sstables</name></name></expr></range></decl></init>)
            <block>{
                <comment type="line">// check if the key actually exists in this sstable, without updating cache and stats</comment>
                <if>if <condition>(<expr><call><name><name>sstr</name>.<name>getPosition</name></name><argument_list>(<argument><expr><name>dk</name></expr></argument>, <argument><expr><name><name>SSTableReader</name>.<name>Operator</name>.<name>EQ</name></name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call> &gt; -1</expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>files</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>sstr</name>.<name>getFilename</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
            <return>return <expr><name>files</name></expr>;</return>
        }</block>
        <finally>finally <block>{
            <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>releaseReferences</name></name><argument_list>(<argument><expr><name><name>view</name>.<name>sstables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ColumnFamily</name></type> <name>getTopLevelColumns</name><parameter_list>(<param><decl><type><name>QueryFilter</name></type> <name>filter</name></decl></param>, <param><decl><type><name>int</name></type> <name>gcBefore</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>forCache</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>CollationController</name></type> <name>controller</name> <init>= <expr>new <call><name>CollationController</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>forCache</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>columns</name> <init>= <expr><call><name><name>controller</name>.<name>getTopLevelColumns</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>recentSSTablesPerRead</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>controller</name>.<name>getSstablesIterated</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>sstablesPerRead</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>controller</name>.<name>getSstablesIterated</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>columns</name></expr>;</return>
    }</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> <specifier>abstract</specifier> class <name>AbstractScanIterator</name> <super><extends>extends <name><name>AbstractIterator</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></extends> <implements>implements <name><name>CloseableIterator</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></implements></super> <block>{}</block></class>

    <comment type="block" format="javadoc">/**
      * Iterate over a range of rows and columns from memtables/sstables.
      *
      * @param superColumn optional SuperColumn to slice subcolumns of; null to slice top-level columns
      * @param range Either a Bounds, which includes start key, or a Range, which does not.
      * @param columnFilter description of the columns we're interested in for each row
     */</comment>
    <function><type><specifier>public</specifier> <name>AbstractScanIterator</name></type> <name>getSequentialIterator</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>superColumn</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name>IFilter</name></type> <name>columnFilter</name></decl></param>)</parameter_list>
    <block>{
        <assert>assert <expr>!(<name>range</name> instanceof <name>Range</name>) || !((<name>Range</name>)<name>range</name>).<call><name>isWrapAround</name><argument_list>()</argument_list></call> || <call><name><name>range</name>.<name>right</name>.<name>isMinimum</name></name><argument_list>()</argument_list></call> : <name>range</name></expr>;</assert>

        <decl_stmt><decl><type><specifier>final</specifier> <name>RowPosition</name></type> <name>startWith</name> <init>= <expr><name><name>range</name>.<name>left</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>RowPosition</name></type> <name>stopAt</name> <init>= <expr><name><name>range</name>.<name>right</name></name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>QueryFilter</name></type> <name>filter</name> <init>= <expr>new <call><name>QueryFilter</name><argument_list>(<argument><expr>null</expr></argument>, <argument><expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><name>columnFamily</name></expr></argument>, <argument><expr><name>superColumn</name></expr></argument>, <argument><expr>null</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>columnFilter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>final</specifier> <name>ViewFragment</name></type> <name>view</name> <init>= <expr><call><name>markReferenced</name><argument_list>(<argument><expr><name>startWith</name></expr></argument>, <argument><expr><name>stopAt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <decl_stmt><decl><type><specifier>final</specifier> <name><name>CloseableIterator</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>iterator</name> <init>= <expr><call><name><name>RowIteratorFactory</name>.<name>getIterator</name></name><argument_list>(<argument><expr><name><name>view</name>.<name>memtables</name></name></expr></argument>, <argument><expr><name><name>view</name>.<name>sstables</name></name></expr></argument>, <argument><expr><name>startWith</name></expr></argument>, <argument><expr><name>stopAt</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>final</specifier> <name>int</name></type> <name>gcBefore</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> / 1000</expr></argument>)</argument_list></call> - <call><name><name>metadata</name>.<name>getGcGraceSeconds</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <return>return <expr>new <class><super><name>AbstractScanIterator</name></super><argument_list>()</argument_list>
            <block>{
                <function><type><specifier>protected</specifier> <name>Row</name></type> <name>computeNext</name><parameter_list>()</parameter_list>
                <block>{
                    <comment type="line">// pull a row out of the iterator</comment>
                    <if>if <condition>(<expr>!<call><name><name>iterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <return>return <expr><call><name>endOfData</name><argument_list>()</argument_list></call></expr>;</return></then></if>

                    <decl_stmt><decl><type><name>Row</name></type> <name>current</name> <init>= <expr><call><name><name>iterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>DecoratedKey</name></type> <name>key</name> <init>= <expr><name><name>current</name>.<name>key</name></name></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr>!<call><name><name>stopAt</name>.<name>isMinimum</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>stopAt</name>.<name>compareTo</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
                        <return>return <expr><call><name>endOfData</name><argument_list>()</argument_list></call></expr>;</return></then></if>

                    <comment type="line">// skipping outside of assigned range</comment>
                    <if>if <condition>(<expr>!<call><name><name>range</name>.<name>contains</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><call><name>computeNext</name><argument_list>()</argument_list></call></expr>;</return></then></if>

                    <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"scanned " + <name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                    <comment type="line">// TODO this is necessary because when we collate supercolumns together, we don't check</comment>
                    <comment type="line">// their subcolumns for relevance, so we need to do a second prune post facto here.</comment>
                    <return>return <expr><name><name>current</name>.<name>cf</name></name> != null &amp;&amp; <call><name><name>current</name>.<name>cf</name>.<name>isSuper</name></name><argument_list>()</argument_list></call>
                        ? new <call><name>Row</name><argument_list>(<argument><expr><name><name>current</name>.<name>key</name></name></expr></argument>, <argument><expr><call><name>removeDeleted</name><argument_list>(<argument><expr><name><name>current</name>.<name>cf</name></name></expr></argument>, <argument><expr><name>gcBefore</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
                        : <name>current</name></expr>;</return>
                }</block></function>

                <function><type><specifier>public</specifier> <name>void</name></type> <name>close</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
                <block>{
                    <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>releaseReferences</name></name><argument_list>(<argument><expr><name><name>view</name>.<name>sstables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <try>try
                    <block>{
                        <expr_stmt><expr><call><name><name>iterator</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block>
                    <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
                    <block>{
                        <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
                    }</block></catch></try>
                }</block></function>
            }</block></class></expr>;</return>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>RuntimeException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <comment type="line">// In case getIterator() throws, otherwise the iteror close method releases the references.</comment>
            <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>releaseReferences</name></name><argument_list>(<argument><expr><name><name>view</name>.<name>sstables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <throw>throw <expr><name>e</name></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>getRangeSlice</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>superColumn</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxResults</name></decl></param>, <param><decl><type><name>IFilter</name></type> <name>columnFilter</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>rowFilter</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>getRangeSlice</name><argument_list>(<argument><expr><name>superColumn</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>maxResults</name></expr></argument>, <argument><expr><name>columnFilter</name></expr></argument>, <argument><expr><name>rowFilter</name></expr></argument>, <argument><expr>false</expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>getRangeSlice</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>superColumn</name></decl></param>, <param><decl><type><specifier>final</specifier> <name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxResults</name></decl></param>, <param><decl><type><name>IFilter</name></type> <name>columnFilter</name></decl></param>, <param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>rowFilter</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>maxIsColumns</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>isPaging</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>filter</name><argument_list>(<argument><expr><call><name>getSequentialIterator</name><argument_list>(<argument><expr><name>superColumn</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>columnFilter</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>ExtendedFilter</name>.<name>create</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>columnFilter</name></expr></argument>, <argument><expr><name>rowFilter</name></expr></argument>, <argument><expr><name>maxResults</name></expr></argument>, <argument><expr><name>maxIsColumns</name></expr></argument>, <argument><expr><name>isPaging</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>search</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>clause</name></decl></param>, <param><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxResults</name></decl></param>, <param><decl><type><name>IFilter</name></type> <name>dataFilter</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name>search</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>maxResults</name></expr></argument>, <argument><expr><name>dataFilter</name></expr></argument>, <argument><expr>false</expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>search</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>IndexExpression</name></argument>&gt;</argument_list></name></type> <name>clause</name></decl></param>, <param><decl><type><name><name>AbstractBounds</name><argument_list>&lt;<argument><name>RowPosition</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxResults</name></decl></param>, <param><decl><type><name>IFilter</name></type> <name>dataFilter</name></decl></param>, <param><decl><type><name>boolean</name></type> <name>maxIsColumns</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>indexManager</name>.<name>search</name></name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>range</name></expr></argument>, <argument><expr><name>maxResults</name></expr></argument>, <argument><expr><name>dataFilter</name></expr></argument>, <argument><expr><name>maxIsColumns</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>filter</name><parameter_list>(<param><decl><type><name>AbstractScanIterator</name></type> <name>rowIterator</name></decl></param>, <param><decl><type><name>ExtendedFilter</name></type> <name>filter</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Filtering {} for rows matching {}"</expr></argument>, <argument><expr><name>rowIterator</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name></type> <name>rows</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>Row</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>columnsCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <try>try
        <block>{
            <while>while <condition>(<expr><call><name><name>rowIterator</name>.<name>hasNext</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>rows</name>.<name>size</name></name><argument_list>()</argument_list></call> &lt; <call><name><name>filter</name>.<name>maxRows</name></name><argument_list>()</argument_list></call> &amp;&amp; <name>columnsCount</name> &lt; <call><name><name>filter</name>.<name>maxColumns</name></name><argument_list>()</argument_list></call></expr>)</condition>
            <block>{
                <comment type="line">// get the raw columns requested, and additional columns for the expressions if necessary</comment>
                <decl_stmt><decl><type><name>Row</name></type> <name>rawRow</name> <init>= <expr><call><name><name>rowIterator</name>.<name>next</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>data</name> <init>= <expr><name><name>rawRow</name>.<name>cf</name></name></expr></init></decl>;</decl_stmt>

                <comment type="line">// roughtly</comment>
                <decl_stmt><decl><type><name>IFilter</name></type> <name>extraFilter</name> <init>= <expr><call><name><name>filter</name>.<name>getExtraFilter</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>extraFilter</name> != null</expr>)</condition><then>
                <block>{
                    <decl_stmt><decl><type><name>QueryPath</name></type> <name>path</name> <init>= <expr>new <call><name>QueryPath</name><argument_list>(<argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>ColumnFamily</name></type> <name>cf</name> <init>= <expr><call><name><name>filter</name>.<name>cfs</name>.<name>getColumnFamily</name></name><argument_list>(<argument><expr>new <call><name>QueryFilter</name><argument_list>(<argument><expr><name><name>rawRow</name>.<name>key</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>extraFilter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>cf</name> != null</expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>data</name>.<name>addAll</name></name><argument_list>(<argument><expr><name>cf</name></expr></argument>, <argument><expr><name><name>HeapAllocator</name>.<name>instance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></then></if>

                <if>if <condition>(<expr>!<call><name><name>filter</name>.<name>isSatisfiedBy</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <continue>continue;</continue></then></if>

                <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"{} satisfies all filter expressions"</expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="line">// cut the resultset back to what was requested, if necessary</comment>
                <expr_stmt><expr><name>data</name> = <call><name><name>filter</name>.<name>prune</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name><name>rows</name>.<name>add</name></name><argument_list>(<argument><expr>new <call><name>Row</name><argument_list>(<argument><expr><name><name>rawRow</name>.<name>key</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>data</name> != null</expr>)</condition><then>
                    <expr_stmt><expr><name>columnsCount</name> += <call><name><name>data</name>.<name>getLiveColumnCount</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
                <comment type="line">// Update the underlying filter to avoid querying more columns per slice than necessary and to handle paging</comment>
                <expr_stmt><expr><call><name><name>filter</name>.<name>updateFilter</name></name><argument_list>(<argument><expr><name>columnsCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <return>return <expr><name>rows</name></expr>;</return>
        }</block>
        <finally>finally
        <block>{
            <try>try
            <block>{
                <expr_stmt><expr><call><name><name>rowIterator</name>.<name>close</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch></try>
        }</block></finally></try>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>AbstractType</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>getComparator</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>metadata</name>.<name>comparator</name></name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>snapshotWithoutFlush</name><parameter_list>(<param><decl><type><name>String</name></type> <name>snapshotName</name></decl></param>)</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <decl_stmt><decl><type><name><name>DataTracker</name>.<name>View</name></name></type> <name>currentView</name> <init>= <expr><call><name><name>cfs</name>.<name>markCurrentViewReferenced</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

            <try>try
            <block>{
                <for>for (<init><decl><type><name>SSTableReader</name></type> <name>ssTable</name> <range>: <expr><name><name>currentView</name>.<name>sstables</name></name></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>File</name></type> <name>snapshotDirectory</name> <init>= <expr><call><name><name>Directories</name>.<name>getSnapshotDirectory</name></name><argument_list>(<argument><expr><name><name>ssTable</name>.<name>descriptor</name></name></expr></argument>, <argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <comment type="line">// hard links</comment>
                    <expr_stmt><expr><call><name><name>ssTable</name>.<name>createLinks</name></name><argument_list>(<argument><expr><call><name><name>snapshotDirectory</name>.<name>getPath</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name><name>logger</name>.<name>isDebugEnabled</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"Snapshot for " + <name>table</name> + " keyspace data file " + <call><name><name>ssTable</name>.<name>getFilename</name></name><argument_list>()</argument_list></call> +
                                     " created in " + <name>snapshotDirectory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></for>

                <if>if <condition>(<expr><name><name>cfs</name>.<name>compactionStrategy</name></name> instanceof <name>LeveledCompactionStrategy</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>cfs</name>.<name>directories</name>.<name>snapshotLeveledManifest</name></name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block>
            <catch>catch <parameter_list>(<param><decl><type><name>IOException</name></type> <name>e</name></decl></param>)</parameter_list>
            <block>{
                <throw>throw <expr>new <call><name>IOError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
            }</block></catch>
            <finally>finally
            <block>{
                <expr_stmt><expr><call><name><name>SSTableReader</name>.<name>releaseReferences</name></name><argument_list>(<argument><expr><name><name>currentView</name>.<name>sstables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></for>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>getSnapshotSSTableReader</name><parameter_list>(<param><decl><type><name>String</name></type> <name>tag</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>Map</name><argument_list>&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>snapshots</name> <init>= <expr><call><name><name>directories</name>.<name>sstableLister</name></name><argument_list>()</argument_list></call>.<call><name>snapshots</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call>.<call><name>list</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>readers</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>snapshots</name>.<name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name><name>Map</name>.<name><name>Entry</name><argument_list>&lt;<argument><name>Descriptor</name></argument>, <argument><name><name>Set</name><argument_list>&lt;<argument><name>Component</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></name></type> <name>entries</name> <range>: <expr><call><name><name>snapshots</name>.<name>entrySet</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>readers</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>SSTableReader</name>.<name>open</name></name><argument_list>(<argument><expr><call><name><name>entries</name>.<name>getKey</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>entries</name>.<name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>readers</name></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Take a snap shot of this columnfamily store.
     *
     * @param snapshotName the name of the associated with the snapshot
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>snapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>snapshotName</name></decl></param>)</parameter_list>
    <block>{
        <try>try
        <block>{
            <expr_stmt><expr><call><name>forceBlockingFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>

        <expr_stmt><expr><call><name>snapshotWithoutFlush</name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>snapshotExists</name><parameter_list>(<param><decl><type><name>String</name></type> <name>snapshotName</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>directories</name>.<name>snapshotExists</name></name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>clearSnapshot</name><parameter_list>(<param><decl><type><name>String</name></type> <name>snapshotName</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>directories</name>.<name>clearSnapshot</name></name><argument_list>(<argument><expr><name>snapshotName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>hasUnreclaimedSpace</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getLiveSize</name></name><argument_list>()</argument_list></call> &lt; <call><name><name>data</name>.<name>getTotalSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getTotalDiskSpaceUsed</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getTotalSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getLiveDiskSpaceUsed</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getLiveSize</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getLiveSSTableCount</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getSSTables</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return the cached row for @param key if it is already present in the cache.
     * That is, unlike getThroughCache, it will not readAndCache the row if it is not present, nor
     * are these calls counted in cache statistics.
     *
     * Note that this WILL cause deserialization of a SerializingCache row, so if all you
     * need to know is whether a row is present or not, use containsCachedRow instead.
     */</comment>
    <function><type><specifier>public</specifier> <name>ColumnFamily</name></type> <name>getRawCachedRow</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name><name>metadata</name>.<name>cfId</name></name> == null</expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if> <comment type="line">// secondary index</comment>

        <decl_stmt><decl><type><name>IRowCacheEntry</name></type> <name>cached</name> <init>= <expr><call><name>getCachedRowInternal</name><argument_list>(<argument><expr>new <call><name>RowCacheKey</name><argument_list>(<argument><expr><name><name>metadata</name>.<name>cfId</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><name>cached</name> == null || <name>cached</name> instanceof <name>RowCacheSentinel</name> ? null : (<name>ColumnFamily</name>) <name>cached</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>IRowCacheEntry</name></type> <name>getCachedRowInternal</name><parameter_list>(<param><decl><type><name>RowCacheKey</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>getCapacity</name></name><argument_list>()</argument_list></call> == 0 ? null : <call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>getInternal</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * @return true if @param key is contained in the row cache
     */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>containsCachedRow</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <return>return <expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>getCapacity</name></name><argument_list>()</argument_list></call> != 0 &amp;&amp; <call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>containsKey</name></name><argument_list>(<argument><expr>new <call><name>RowCacheKey</name><argument_list>(<argument><expr><name><name>metadata</name>.<name>cfId</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidateCachedRow</name><parameter_list>(<param><decl><type><name>RowCacheKey</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>remove</name></name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>invalidateCachedRow</name><parameter_list>(<param><decl><type><name>DecoratedKey</name></type> <name>key</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>Integer</name></type> <name>cfId</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getId</name></name><argument_list>(<argument><expr><name><name>table</name>.<name>name</name></name></expr></argument>, <argument><expr><name><name>this</name>.<name>columnFamily</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>cfId</name> == null</expr>)</condition><then>
            <return>return;</return></then></if> <comment type="line">// secondary index</comment>

        <expr_stmt><expr><call><name>invalidateCachedRow</name><argument_list>(<argument><expr>new <call><name>RowCacheKey</name><argument_list>(<argument><expr><name>cfId</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>forceMajorCompaction</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>InterruptedException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument></throws>
    <block>{
        <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>performMaximal</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>all</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>stores</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Schema</name>.<name>instance</name>.<name>getTables</name></name><argument_list>()</argument_list></call>.<call><name>size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>stores</name>.<name>add</name></name><argument_list>(<argument><expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><name>stores</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <specifier>static</specifier> <name><name>List</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>allUserDefined</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>cfses</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Table</name></type> <name>table</name> <range>: <expr><call><name><name>Sets</name>.<name>difference</name></name><argument_list>(<argument><expr><call><name><name>ImmutableSet</name>.<name>copyOf</name></name><argument_list>(<argument><expr><call><name><name>Table</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>ImmutableSet</name>.<name>of</name></name><argument_list>(<argument><expr><call><name><name>Table</name>.<name>open</name></name><argument_list>(<argument><expr><name><name>Table</name>.<name>SYSTEM_TABLE</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>cfses</name>.<name>addAll</name></name><argument_list>(<argument><expr><call><name><name>table</name>.<name>getColumnFamilyStores</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>cfses</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name></type> <name>keySamples</name><parameter_list>(<param><decl><type><name><name>Range</name><argument_list>&lt;<argument><name>Token</name></argument>&gt;</argument_list></name></type> <name>range</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name> <init>= <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name><name>DecoratedKey</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></argument>&gt;</argument_list></name><index>[]</index></type> <name>samples</name> <init>= <expr>new <name><name>Iterable</name><index>[<expr><call><name><name>sstables</name>.<name>size</name></name><argument_list>()</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name><range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><name><name>samples</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name><name>sstable</name>.<name>getKeySamples</name></name><argument_list>(<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <return>return <expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><name>samples</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * For testing.  No effort is made to clear historical or even the current memtables, nor for
     * thread safety.  All we do is wipe the sstable containers clean, while leaving the actual
     * data files present on disk.  (This allows tests to easily call loadNewSSTables on them.)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>clearUnsafe</name><parameter_list>()</parameter_list>
    <block>{
        <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><call><name><name>cfs</name>.<name>data</name>.<name>init</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Waits for flushes started BEFORE THIS METHOD IS CALLED to finish.
     * Does NOT guarantee that no flush is active when it returns.
     */</comment>
    <function><type><specifier>private</specifier> <name>void</name></type> <name>waitForActiveFlushes</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>future</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name><name>Table</name>.<name>switchLock</name>.<name>writeLock</name></name><argument_list>()</argument_list></call>.<call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <try>try
        <block>{
            <expr_stmt><expr><name>future</name> = <call><name><name>postFlushExecutor</name>.<name>submit</name></name><argument_list>(<argument><expr>new <class><super><name>Runnable</name></super><argument_list>()</argument_list> <block>{ <function><type><specifier>public</specifier> <name>void</name></type> <name>run</name><parameter_list>()</parameter_list> <block>{ }</block></function> }</block></class></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <finally>finally
        <block>{
            <expr_stmt><expr><call><name><name>Table</name>.<name>switchLock</name>.<name>writeLock</name></name><argument_list>()</argument_list></call>.<call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></finally></try>

        <try>try
        <block>{
            <expr_stmt><expr><call><name><name>future</name>.<name>get</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch>
        <catch>catch <parameter_list>(<param><decl><type><name>ExecutionException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Truncate practically deletes the entire column family's data
     * @return a Future to the delete operation. Call the future's get() to make
     * sure the column family has been deleted
     */</comment>
    <function><type><specifier>public</specifier> <name><name>Future</name><argument_list>&lt;<argument><name>?</name></argument>&gt;</argument_list></name></type> <name>truncate</name><parameter_list>()</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument>, <argument><expr><name>ExecutionException</name></expr></argument>, <argument><expr><name>InterruptedException</name></expr></argument></throws>
    <block>{
        <comment type="line">// We have two goals here:</comment>
        <comment type="line">// - truncate should delete everything written before truncate was invoked</comment>
        <comment type="line">// - but not delete anything that isn't part of the snapshot we create.</comment>
        <comment type="line">// We accomplish this by first flushing manually, then snapshotting, and</comment>
        <comment type="line">// recording the timestamp IN BETWEEN those actions. Any sstables created</comment>
        <comment type="line">// with this timestamp or greater time, will not be marked for delete.</comment>
        <comment type="line">//</comment>
        <comment type="line">// Bonus complication: since we store replay position in sstable metadata,</comment>
        <comment type="line">// truncating those sstables means we will replay any CL segments from the</comment>
        <comment type="line">// beginning if we restart before they are discarded for normal reasons</comment>
        <comment type="line">// post-truncate.  So we need to (a) force a new segment so the currently</comment>
        <comment type="line">// active one can be discarded, and (b) flush *all* CFs so that unflushed</comment>
        <comment type="line">// data in others don't keep any pre-truncate CL segments alive.</comment>
        <comment type="line">//</comment>
        <comment type="line">// Bonus bonus: simply forceFlush of all the CF is not enough, because if</comment>
        <comment type="line">// for a given column family the memtable is clean, forceFlush will return</comment>
        <comment type="line">// immediately, even though there could be a memtable being flushed at the same</comment>
        <comment type="line">// time.  So to guarantee that all segments can be cleaned out, we need to</comment>
        <comment type="line">// "waitForActiveFlushes" after the new segment has been created.</comment>
        <expr_stmt><expr><call><name><name>logger</name>.<name>debug</name></name><argument_list>(<argument><expr>"truncating {}"</expr></argument>, <argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name>.<name>isAutoSnapshot</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
        <block>{
            <comment type="line">// flush the CF being truncated before forcing the new segment</comment>
            <expr_stmt><expr><call><name>forceBlockingFlush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
            <comment type="line">// just nuke the memtable data w/o writing to disk first</comment>
            <expr_stmt><expr><call><name><name>Table</name>.<name>switchLock</name>.<name>writeLock</name></name><argument_list>()</argument_list></call>.<call><name>lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <try>try
            <block>{
                <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name>concatWithIndexes</name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <block>{
                    <decl_stmt><decl><type><name>Memtable</name></type> <name>mt</name> <init>= <expr><call><name><name>cfs</name>.<name>getMemtableThreadSafe</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr>!<call><name><name>mt</name>.<name>isClean</name></name><argument_list>()</argument_list></call> &amp;&amp; !<call><name><name>mt</name>.<name>isFrozen</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <block>{
                        <expr_stmt><expr><call><name><name>mt</name>.<name>cfs</name>.<name>data</name>.<name>renewMemtable</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block>
            <finally>finally
            <block>{
                <expr_stmt><expr><call><name><name>Table</name>.<name>switchLock</name>.<name>writeLock</name></name><argument_list>()</argument_list></call>.<call><name>unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></finally></try>
        }</block></else></if>

        <decl_stmt><decl><type><name>KSMetaData</name></type> <name>ksm</name> <init>= <expr><call><name><name>Schema</name>.<name>instance</name>.<name>getKSMetaData</name></name><argument_list>(<argument><expr><name><name>this</name>.<name>table</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>ksm</name>.<name>durableWrites</name></name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>forceNewSegment</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name><name>Future</name><argument_list>&lt;<argument><name>ReplayPosition</name></argument>&gt;</argument_list></name></type> <name>position</name> <init>= <expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>getContext</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">// now flush everyone else.  re-flushing ourselves is not necessary, but harmless</comment>
            <for>for (<init><decl><type><name>ColumnFamilyStore</name></type> <name>cfs</name> <range>: <expr><call><name><name>ColumnFamilyStore</name>.<name>all</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
                <expr_stmt><expr><call><name><name>cfs</name>.<name>forceFlush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
            <expr_stmt><expr><call><name>waitForActiveFlushes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// if everything was clean, flush won't have called discard</comment>
            <expr_stmt><expr><call><name><name>CommitLog</name>.<name>instance</name>.<name>discardCompletedSegments</name></name><argument_list>(<argument><expr><name><name>metadata</name>.<name>cfId</name></name></expr></argument>, <argument><expr><call><name><name>position</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// sleep a little to make sure that our truncatedAt comes after any sstable</comment>
        <comment type="line">// that was part of the flushed we forced; otherwise on a tie, it won't get deleted.</comment>
        <try>try
        <block>{
            <decl_stmt><decl><type><name>long</name></type> <name>starttime</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr>(<call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call> - <name>starttime</name>) &lt; 1</expr>)</condition>
            <block>{
                <expr_stmt><expr><call><name><name>Thread</name>.<name>sleep</name></name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block>
        <catch>catch <parameter_list>(<param><decl><type><name>InterruptedException</name></type> <name>e</name></decl></param>)</parameter_list>
        <block>{
            <throw>throw <expr>new <call><name>AssertionError</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</throw>
        }</block></catch></try>
        <decl_stmt><decl><type><name>long</name></type> <name>truncatedAt</name> <init>= <expr><call><name><name>System</name>.<name>currentTimeMillis</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name><name>DatabaseDescriptor</name>.<name>isAutoSnapshot</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>snapshot</name><argument_list>(<argument><expr><call><name><name>Table</name>.<name>getTimestampedSnapshotName</name></name><argument_list>(<argument><expr><name>columnFamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <return>return <expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>submitTruncate</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getBloomFilterFalsePositives</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getBloomFilterFalsePositives</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getRecentBloomFilterFalsePositives</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getRecentBloomFilterFalsePositives</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getBloomFilterFalseRatio</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getBloomFilterFalseRatio</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getRecentBloomFilterFalseRatio</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getRecentBloomFilterFalseRatio</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>getBloomFilterDiskSpaceUsed</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>total</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sst</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <expr_stmt><expr><name>total</name> += <call><name><name>sst</name>.<name>getBloomFilterSerializedSize</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>total</name></expr>;</return>
    }</block></function>

    <function><type><annotation>@<name>Override</name></annotation>
    <specifier>public</specifier> <name>String</name></type> <name>toString</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>"CFS(" +
               "Keyspace='" + <name><name>table</name>.<name>name</name></name> + '\'' +
               ", ColumnFamily='" + <name>columnFamily</name> + '\'' +
               ')'</expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>disableAutoCompaction</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>minCompactionThreshold</name>.<name>set</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>maxCompactionThreshold</name>.<name>set</name></name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>enableAutoCompaction</name><parameter_list>()</parameter_list>
    <block>{
        <expr_stmt><expr><call><name><name>minCompactionThreshold</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>maxCompactionThreshold</name>.<name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <comment type="block">/*
     JMX getters and setters for the Default&lt;T&gt;s.
       - get/set minCompactionThreshold
       - get/set maxCompactionThreshold
       - get     memsize
       - get     memops
       - get/set memtime
     */</comment>

    <function><type><specifier>public</specifier> <name>AbstractCompactionStrategy</name></type> <name>getCompactionStrategy</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>compactionStrategy</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setCompactionThresholds</name><parameter_list>(<param><decl><type><name>int</name></type> <name>minThreshold</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxThreshold</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>validateCompactionThresholds</name><argument_list>(<argument><expr><name>minThreshold</name></expr></argument>, <argument><expr><name>maxThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name><name>minCompactionThreshold</name>.<name>set</name></name><argument_list>(<argument><expr><name>minThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>maxCompactionThreshold</name>.<name>set</name></name><argument_list>(<argument><expr><name>maxThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// this is called as part of CompactionStrategy constructor; avoid circular dependency by checking for null</comment>
        <if>if <condition>(<expr><name>compactionStrategy</name> != null</expr>)</condition><then>
            <expr_stmt><expr><call><name><name>CompactionManager</name>.<name>instance</name>.<name>submitBackground</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMinimumCompactionThreshold</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>minCompactionThreshold</name>.<name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMinimumCompactionThreshold</name><parameter_list>(<param><decl><type><name>int</name></type> <name>minCompactionThreshold</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>validateCompactionThresholds</name><argument_list>(<argument><expr><name>minCompactionThreshold</name></expr></argument>, <argument><expr><call><name><name>maxCompactionThreshold</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name>.<name>minCompactionThreshold</name>.<name>set</name></name><argument_list>(<argument><expr><name>minCompactionThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getMaximumCompactionThreshold</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>maxCompactionThreshold</name>.<name>value</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>void</name></type> <name>setMaximumCompactionThreshold</name><parameter_list>(<param><decl><type><name>int</name></type> <name>maxCompactionThreshold</name></decl></param>)</parameter_list>
    <block>{
        <expr_stmt><expr><call><name>validateCompactionThresholds</name><argument_list>(<argument><expr><call><name><name>minCompactionThreshold</name>.<name>value</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>maxCompactionThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>this</name>.<name>maxCompactionThreshold</name>.<name>set</name></name><argument_list>(<argument><expr><name>maxCompactionThreshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></function>

    <function><type><specifier>private</specifier> <name>void</name></type> <name>validateCompactionThresholds</name><parameter_list>(<param><decl><type><name>int</name></type> <name>minThreshold</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxThreshold</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><name>minThreshold</name> &gt; <name>maxThreshold</name> &amp;&amp; <name>maxThreshold</name> != 0</expr>)</condition><then>
            <throw>throw <expr>new <call><name>RuntimeException</name><argument_list>(<argument><expr><call><name><name>String</name>.<name>format</name></name><argument_list>(<argument><expr>"The min_compaction_threshold cannot be larger than the max_compaction_threshold. " +
                                                     "Min is '%d', Max is '%d'."</expr></argument>, <argument><expr><name>minThreshold</name></expr></argument>, <argument><expr><name>maxThreshold</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</throw></then></if>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isCompactionDisabled</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name>getMinimumCompactionThreshold</name><argument_list>()</argument_list></call> &lt;= 0 || <call><name>getMaximumCompactionThreshold</name><argument_list>()</argument_list></call> &lt;= 0</expr>;</return>
    }</block></function>

    <comment type="line">// End JMX get/set.</comment>

    <function><type><specifier>public</specifier> <name>long</name></type> <name>estimateKeys</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>estimatedKeys</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getEstimatedRowSizeHistogram</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getEstimatedRowSizeHistogram</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>long</name><index>[]</index></type> <name>getEstimatedColumnCountHistogram</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getEstimatedColumnCountHistogram</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>double</name></type> <name>getCompressionRatio</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getCompressionRatio</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/** true if this CFS contains secondary index data */</comment>
    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isIndex</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name>partitioner</name> instanceof <name>LocalPartitioner</name></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>String</name></type> <name>getParentColumnfamily</name><parameter_list>()</parameter_list>
    <block>{
        <assert>assert <expr><call><name>isIndex</name><argument_list>()</argument_list></call></expr>;</assert>
        <return>return <expr><call><name><name>columnFamily</name>.<name>split</name></name><argument_list>(<argument><expr>"\\."</expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>ByteBuffer</name></type> <name>intern</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>internedName</name> <init>= <expr><call><name><name>internedNames</name>.<name>get</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>internedName</name> == null</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>internedName</name> = <call><name><name>ByteBufferUtil</name>.<name>clone</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>ByteBuffer</name></type> <name>concurrentName</name> <init>= <expr><call><name><name>internedNames</name>.<name>putIfAbsent</name></name><argument_list>(<argument><expr><name>internedName</name></expr></argument>, <argument><expr><name>internedName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>concurrentName</name> != null</expr>)</condition><then>
                <expr_stmt><expr><name>internedName</name> = <name>concurrentName</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
        <return>return <expr><name>internedName</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>internOrCopy</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>, <param><decl><type><name>Allocator</name></type> <name>allocator</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>internedNames</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt;= <name>INTERN_CUTOFF</name></expr>)</condition><then>
            <return>return <expr><call><name><name>allocator</name>.<name>clone</name></name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <return>return <expr><call><name>intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>ByteBuffer</name></type> <name>maybeIntern</name><parameter_list>(<param><decl><type><name>ByteBuffer</name></type> <name>name</name></decl></param>)</parameter_list>
    <block>{
        <if>if <condition>(<expr><call><name><name>internedNames</name>.<name>size</name></name><argument_list>()</argument_list></call> &gt;= <name>INTERN_CUTOFF</name></expr>)</condition><then>
            <return>return <expr>null</expr>;</return></then></if>

        <return>return <expr><call><name>intern</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>SSTableWriter</name></type> <name>createFlushWriter</name><parameter_list>(<param><decl><type><name>long</name></type> <name>estimatedRows</name></decl></param>, <param><decl><type><name>long</name></type> <name>estimatedSize</name></decl></param>, <param><decl><type><name>ReplayPosition</name></type> <name>context</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name><name>SSTableMetadata</name>.<name>Collector</name></name></type> <name>sstableMetadataCollector</name> <init>= <expr><call><name><name>SSTableMetadata</name>.<name>createCollector</name></name><argument_list>()</argument_list></call>.<call><name>replayPosition</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr>new <call><name>SSTableWriter</name><argument_list>(<argument><expr><call><name>getFlushPath</name><argument_list>(<argument><expr><name>estimatedSize</name></expr></argument>, <argument><expr><name><name>Descriptor</name>.<name>CURRENT_VERSION</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>estimatedRows</name></expr></argument>,
                                 <argument><expr><name>metadata</name></expr></argument>,
                                 <argument><expr><name>partitioner</name></expr></argument>,
                                 <argument><expr><name>sstableMetadataCollector</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>SSTableWriter</name></type> <name>createCompactionWriter</name><parameter_list>(<param><decl><type><name>long</name></type> <name>estimatedRows</name></decl></param>, <param><decl><type><name>File</name></type> <name>location</name></decl></param>, <param><decl><type><name><name>Collection</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>)</parameter_list> <throws>throws <argument><expr><name>IOException</name></expr></argument></throws>
    <block>{
        <decl_stmt><decl><type><name>ReplayPosition</name></type> <name>rp</name> <init>= <expr><call><name><name>ReplayPosition</name>.<name>getReplayPosition</name></name><argument_list>(<argument><expr><name>sstables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name><name>SSTableMetadata</name>.<name>Collector</name></name></type> <name>sstableMetadataCollector</name> <init>= <expr><call><name><name>SSTableMetadata</name>.<name>createCollector</name></name><argument_list>()</argument_list></call>.<call><name>replayPosition</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="line">// Get the max timestamp of the precompacted sstables</comment>
        <comment type="line">// and adds generation of live ancestors</comment>
        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><name>sstables</name></expr></range></decl></init>)
        <block>{
            <expr_stmt><expr><call><name><name>sstableMetadataCollector</name>.<name>updateMaxTimestamp</name></name><argument_list>(<argument><expr><call><name><name>sstable</name>.<name>getMaxTimestamp</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>sstableMetadataCollector</name>.<name>addAncestor</name></name><argument_list>(<argument><expr><name><name>sstable</name>.<name>descriptor</name>.<name>generation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><decl><type><name>Integer</name></type> <name>i</name> <range>: <expr><call><name><name>sstable</name>.<name>getAncestors</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)
            <block>{
                <if>if <condition>(<expr>new <call><name>File</name><argument_list>(<argument><expr><call><name><name>sstable</name>.<name>descriptor</name>.<name>withGeneration</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call>.<call><name>filenameFor</name><argument_list>(<argument><expr><name><name>Component</name>.<name>DATA</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>.<call><name>exists</name><argument_list>()</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><call><name><name>sstableMetadataCollector</name>.<name>addAncestor</name></name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
        }</block></for>

        <return>return <expr>new <call><name>SSTableWriter</name><argument_list>(<argument><expr><call><name>getTempSSTablePath</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>estimatedRows</name></expr></argument>, <argument><expr><name>metadata</name></expr></argument>, <argument><expr><name>partitioner</name></expr></argument>, <argument><expr><name>sstableMetadataCollector</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>ColumnFamilyStore</name></argument>&gt;</argument_list></name></type> <name>concatWithIndexes</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>Iterables</name>.<name>concat</name></name><argument_list>(<argument><expr><call><name><name>indexManager</name>.<name>getIndexesBackedByCfs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Collections</name>.<name>singleton</name></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>Set</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>getMemtablesPendingFlush</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><call><name><name>data</name>.<name>getMemtablesPendingFlush</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name><name>List</name><argument_list>&lt;<argument><name>String</name></argument>&gt;</argument_list></name></type> <name>getBuiltIndexes</name><parameter_list>()</parameter_list>
    <block>{
       <return>return <expr><call><name><name>indexManager</name>.<name>getBuiltIndexes</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>int</name></type> <name>getUnleveledSSTables</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr><name><name>this</name>.<name>compactionStrategy</name></name> instanceof <name>LeveledCompactionStrategy</name>
               ? ((<name>LeveledCompactionStrategy</name>) <name><name>this</name>.<name>compactionStrategy</name></name>).<call><name>getLevelSize</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>
               : 0</expr>;</return>
    }</block></function>

    <class><specifier>public</specifier> <specifier>static</specifier> class <name>ViewFragment</name>
    <block>{
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>public</specifier> <specifier>final</specifier> <name><name>Iterable</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name></decl>;</decl_stmt>

        <constructor><specifier>public</specifier> <name>ViewFragment</name><parameter_list>(<param><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>sstables</name></decl></param>, <param><decl><type><name><name>Iterable</name><argument_list>&lt;<argument><name>Memtable</name></argument>&gt;</argument_list></name></type> <name>memtables</name></decl></param>)</parameter_list>
        <block>{
            <expr_stmt><expr><name><name>this</name>.<name>sstables</name></name> = <name>sstables</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>this</name>.<name>memtables</name></name> = <name>memtables</name></expr>;</expr_stmt>
        }</block></constructor>
    }</block></class>

    <comment type="block" format="javadoc">/**
     * Returns the creation time of the oldest memtable not fully flushed yet.
     */</comment>
    <function><type><specifier>public</specifier> <name>long</name></type> <name>oldestUnflushedMemtable</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>DataTracker</name>.<name>View</name></name></type> <name>view</name> <init>= <expr><call><name><name>data</name>.<name>getView</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>oldest</name> <init>= <expr><call><name><name>view</name>.<name>memtable</name>.<name>creationTime</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <for>for (<init><decl><type><name>Memtable</name></type> <name>memtable</name> <range>: <expr><name><name>view</name>.<name>memtablesPendingFlush</name></name></expr></range></decl></init>)
            <expr_stmt><expr><name>oldest</name> = <call><name><name>Math</name>.<name>min</name></name><argument_list>(<argument><expr><name>oldest</name></expr></argument>, <argument><expr><call><name><name>memtable</name>.<name>creationTime</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        <return>return <expr><name>oldest</name></expr>;</return>
    }</block></function>

    <function><type><specifier>public</specifier> <name>boolean</name></type> <name>isEmpty</name><parameter_list>()</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>DataTracker</name>.<name>View</name></name></type> <name>view</name> <init>= <expr><call><name><name>data</name>.<name>getView</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr><call><name><name>view</name>.<name>sstables</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call> &amp;&amp; <call><name><name>view</name>.<name>memtable</name>.<name>getOperations</name></name><argument_list>()</argument_list></call> == 0 &amp;&amp; <call><name><name>view</name>.<name>memtablesPendingFlush</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>;</return>
    }</block></function>

    <function><type><specifier>private</specifier> <name>boolean</name></type> <name>isRowCacheEnabled</name><parameter_list>()</parameter_list>
    <block>{
        <return>return <expr>!(<call><name><name>metadata</name>.<name>getCaching</name></name><argument_list>()</argument_list></call> == <name><name>Caching</name>.<name>NONE</name></name>
              || <call><name><name>metadata</name>.<name>getCaching</name></name><argument_list>()</argument_list></call> == <name><name>Caching</name>.<name>KEYS_ONLY</name></name>
              || <call><name><name>CacheService</name>.<name>instance</name>.<name>rowCache</name>.<name>getCapacity</name></name><argument_list>()</argument_list></call> == 0)</expr>;</return>
    }</block></function>

    <comment type="block" format="javadoc">/**
     * Discard all SSTables that were created before given timestamp. Caller is responsible to obtain compactionLock.
     *
     * @param truncatedAt The timestamp of the truncation
     *                    (all SSTables before that timestamp are going be marked as compacted)
     */</comment>
    <function><type><specifier>public</specifier> <name>void</name></type> <name>discardSSTables</name><parameter_list>(<param><decl><type><name>long</name></type> <name>truncatedAt</name></decl></param>)</parameter_list>
    <block>{
        <decl_stmt><decl><type><name><name>List</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name></type> <name>truncatedSSTables</name> <init>= <expr>new <call><name><name>ArrayList</name><argument_list>&lt;<argument><name>SSTableReader</name></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

        <for>for (<init><decl><type><name>SSTableReader</name></type> <name>sstable</name> <range>: <expr><call><name>getSSTables</name><argument_list>()</argument_list></call></expr></range></decl></init>)
        <block>{
            <if>if <condition>(<expr>!<call><name><name>sstable</name>.<name>newSince</name></name><argument_list>(<argument><expr><name>truncatedAt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name><name>truncatedSSTables</name>.<name>add</name></name><argument_list>(<argument><expr><name>sstable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>

        <if>if <condition>(<expr>!<call><name><name>truncatedSSTables</name>.<name>isEmpty</name></name><argument_list>()</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>markCompacted</name><argument_list>(<argument><expr><name>truncatedSSTables</name></expr></argument>, <argument><expr><name><name>OperationType</name>.<name>UNKNOWN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></function>
}</block></class>
</unit>
